/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@js-joda/core/dist/js-joda.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@js-joda/core/dist/js-joda.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArithmeticException": () => (/* binding */ ArithmeticException),
/* harmony export */   "ChronoField": () => (/* binding */ ChronoField),
/* harmony export */   "ChronoLocalDate": () => (/* binding */ ChronoLocalDate),
/* harmony export */   "ChronoLocalDateTime": () => (/* binding */ ChronoLocalDateTime),
/* harmony export */   "ChronoUnit": () => (/* binding */ ChronoUnit),
/* harmony export */   "ChronoZonedDateTime": () => (/* binding */ ChronoZonedDateTime),
/* harmony export */   "Clock": () => (/* binding */ Clock),
/* harmony export */   "DateTimeException": () => (/* binding */ DateTimeException),
/* harmony export */   "DateTimeFormatter": () => (/* binding */ DateTimeFormatter),
/* harmony export */   "DateTimeFormatterBuilder": () => (/* binding */ DateTimeFormatterBuilder),
/* harmony export */   "DateTimeParseException": () => (/* binding */ DateTimeParseException),
/* harmony export */   "DayOfWeek": () => (/* binding */ DayOfWeek),
/* harmony export */   "DecimalStyle": () => (/* binding */ DecimalStyle),
/* harmony export */   "Duration": () => (/* binding */ Duration),
/* harmony export */   "IllegalArgumentException": () => (/* binding */ IllegalArgumentException),
/* harmony export */   "IllegalStateException": () => (/* binding */ IllegalStateException),
/* harmony export */   "Instant": () => (/* binding */ Instant),
/* harmony export */   "IsoChronology": () => (/* binding */ IsoChronology),
/* harmony export */   "IsoFields": () => (/* binding */ IsoFields),
/* harmony export */   "LocalDate": () => (/* binding */ LocalDate),
/* harmony export */   "LocalDateTime": () => (/* binding */ LocalDateTime),
/* harmony export */   "LocalTime": () => (/* binding */ LocalTime),
/* harmony export */   "Month": () => (/* binding */ Month),
/* harmony export */   "MonthDay": () => (/* binding */ MonthDay),
/* harmony export */   "NullPointerException": () => (/* binding */ NullPointerException),
/* harmony export */   "OffsetDateTime": () => (/* binding */ OffsetDateTime),
/* harmony export */   "OffsetTime": () => (/* binding */ OffsetTime),
/* harmony export */   "Period": () => (/* binding */ Period),
/* harmony export */   "ResolverStyle": () => (/* binding */ ResolverStyle),
/* harmony export */   "SignStyle": () => (/* binding */ SignStyle),
/* harmony export */   "Temporal": () => (/* binding */ Temporal),
/* harmony export */   "TemporalAccessor": () => (/* binding */ TemporalAccessor),
/* harmony export */   "TemporalAdjuster": () => (/* binding */ TemporalAdjuster),
/* harmony export */   "TemporalAdjusters": () => (/* binding */ TemporalAdjusters),
/* harmony export */   "TemporalAmount": () => (/* binding */ TemporalAmount),
/* harmony export */   "TemporalField": () => (/* binding */ TemporalField),
/* harmony export */   "TemporalQueries": () => (/* binding */ TemporalQueries),
/* harmony export */   "TemporalQuery": () => (/* binding */ TemporalQuery),
/* harmony export */   "TemporalUnit": () => (/* binding */ TemporalUnit),
/* harmony export */   "TextStyle": () => (/* binding */ TextStyle),
/* harmony export */   "UnsupportedTemporalTypeException": () => (/* binding */ UnsupportedTemporalTypeException),
/* harmony export */   "ValueRange": () => (/* binding */ ValueRange),
/* harmony export */   "Year": () => (/* binding */ Year),
/* harmony export */   "YearConstants": () => (/* binding */ YearConstants),
/* harmony export */   "YearMonth": () => (/* binding */ YearMonth),
/* harmony export */   "ZoneId": () => (/* binding */ ZoneId),
/* harmony export */   "ZoneOffset": () => (/* binding */ ZoneOffset),
/* harmony export */   "ZoneOffsetTransition": () => (/* binding */ ZoneOffsetTransition),
/* harmony export */   "ZoneRegion": () => (/* binding */ ZoneRegion),
/* harmony export */   "ZoneRules": () => (/* binding */ ZoneRules),
/* harmony export */   "ZoneRulesProvider": () => (/* binding */ ZoneRulesProvider),
/* harmony export */   "ZonedDateTime": () => (/* binding */ ZonedDateTime),
/* harmony export */   "_": () => (/* binding */ _),
/* harmony export */   "convert": () => (/* binding */ convert),
/* harmony export */   "nativeJs": () => (/* binding */ nativeJs),
/* harmony export */   "use": () => (/* binding */ use)
/* harmony export */ });
//! @version @js-joda/core - 5.2.0
//! @copyright (c) 2015-present, Philipp Thürwächter, Pattrick Hüper & js-joda contributors
//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function createErrorType(name, init, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }

  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }

    this.message = message;
    init && init.apply(this, arguments);

    this.toString = function () {
      return this.name + ": " + this.message;
    };
  }

  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}

var DateTimeException = createErrorType('DateTimeException', messageWithCause);
var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);
var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);
var ArithmeticException = createErrorType('ArithmeticException');
var IllegalArgumentException = createErrorType('IllegalArgumentException');
var IllegalStateException = createErrorType('IllegalStateException');
var NullPointerException = createErrorType('NullPointerException');

function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }

  var msg = message || this.name;

  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }

  this.message = msg;
}

function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = '';
  }

  if (index === void 0) {
    index = 0;
  }

  if (cause === void 0) {
    cause = null;
  }

  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;

  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }

  this.message = msg;

  this.parsedString = function () {
    return text;
  };

  this.errorIndex = function () {
    return index;
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }

  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ''));
  }

  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError("abstract method \"" + methodName + "\" is not implemented");
}

var assert$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    assert: assert,
    requireNonNull: requireNonNull,
    requireInstance: requireInstance,
    abstractMethodFail: abstractMethodFail
});

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_SAFE_INTEGER = 9007199254740991;
var MIN_SAFE_INTEGER = -9007199254740991;
var MathUtil = function () {
  function MathUtil() {}

  MathUtil.intDiv = function intDiv(x, y) {
    var r = x / y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };

  MathUtil.intMod = function intMod(x, y) {
    var r = x - MathUtil.intDiv(x, y) * y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };

  MathUtil.roundDown = function roundDown(r) {
    if (r < 0) {
      return Math.ceil(r);
    } else {
      return Math.floor(r);
    }
  };

  MathUtil.floorDiv = function floorDiv(x, y) {
    var r = Math.floor(x / y);
    return MathUtil.safeZero(r);
  };

  MathUtil.floorMod = function floorMod(x, y) {
    var r = x - MathUtil.floorDiv(x, y) * y;
    return MathUtil.safeZero(r);
  };

  MathUtil.safeAdd = function safeAdd(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);

    if (x === 0) {
      return MathUtil.safeZero(y);
    }

    if (y === 0) {
      return MathUtil.safeZero(x);
    }

    var r = MathUtil.safeToInt(x + y);

    if (r === x || r === y) {
      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');
    }

    return r;
  };

  MathUtil.safeSubtract = function safeSubtract(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);

    if (x === 0 && y === 0) {
      return 0;
    } else if (x === 0) {
      return MathUtil.safeZero(-1 * y);
    } else if (y === 0) {
      return MathUtil.safeZero(x);
    }

    return MathUtil.safeToInt(x - y);
  };

  MathUtil.safeMultiply = function safeMultiply(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);

    if (x === 1) {
      return MathUtil.safeZero(y);
    }

    if (y === 1) {
      return MathUtil.safeZero(x);
    }

    if (x === 0 || y === 0) {
      return 0;
    }

    var r = MathUtil.safeToInt(x * y);

    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
      throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
    }

    return r;
  };

  MathUtil.parseInt = function (_parseInt) {
    function parseInt(_x) {
      return _parseInt.apply(this, arguments);
    }

    parseInt.toString = function () {
      return _parseInt.toString();
    };

    return parseInt;
  }(function (value) {
    var r = parseInt(value);
    return MathUtil.safeToInt(r);
  });

  MathUtil.safeToInt = function safeToInt(value) {
    MathUtil.verifyInt(value);
    return MathUtil.safeZero(value);
  };

  MathUtil.verifyInt = function verifyInt(value) {
    if (value == null) {
      throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
    }

    if (isNaN(value)) {
      throw new ArithmeticException('Invalid int value, using NaN as argument');
    }

    if (value % 1 !== 0) {
      throw new ArithmeticException("Invalid value: '" + value + "' is a float");
    }

    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
      throw new ArithmeticException("Calculation overflows an int: " + value);
    }
  };

  MathUtil.safeZero = function safeZero(value) {
    return value === 0 ? 0 : +value;
  };

  MathUtil.compareNumbers = function compareNumbers(a, b) {
    if (a < b) {
      return -1;
    }

    if (a > b) {
      return 1;
    }

    return 0;
  };

  MathUtil.smi = function smi(int) {
    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;
  };

  MathUtil.hash = function hash(number) {
    if (number !== number || number === Infinity) {
      return 0;
    }

    var result = number;

    while (number > 0xFFFFFFFF) {
      number /= 0xFFFFFFFF;
      result ^= number;
    }

    return MathUtil.smi(result);
  };

  MathUtil.hashCode = function hashCode() {
    var result = 17;

    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }

    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
      var n = _numbers[_i];
      result = (result << 5) - result + MathUtil.hash(n);
    }

    return MathUtil.hash(result);
  };

  return MathUtil;
}();
MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var Enum = function () {
  function Enum(name) {
    this._name = name;
  }

  var _proto = Enum.prototype;

  _proto.equals = function equals(other) {
    return this === other;
  };

  _proto.toString = function toString() {
    return this._name;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return Enum;
}();

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAmount = function () {
  function TemporalAmount() {}

  var _proto = TemporalAmount.prototype;

  _proto.get = function get(unit) {
    abstractMethodFail('get');
  };

  _proto.units = function units() {
    abstractMethodFail('units');
  };

  _proto.addTo = function addTo(temporal) {
    abstractMethodFail('addTo');
  };

  _proto.subtractFrom = function subtractFrom(temporal) {
    abstractMethodFail('subtractFrom');
  };

  return TemporalAmount;
}();

if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  TemporalAmount.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }

    throw new TypeError('A conversion from TemporalAmount to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalUnit = function () {
  function TemporalUnit() {}

  var _proto = TemporalUnit.prototype;

  _proto.duration = function duration() {
    abstractMethodFail('duration');
  };

  _proto.isDurationEstimated = function isDurationEstimated() {
    abstractMethodFail('isDurationEstimated');
  };

  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };

  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };

  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };

  _proto.addTo = function addTo(dateTime, periodToAdd) {
    abstractMethodFail('addTo');
  };

  _proto.between = function between(temporal1, temporal2) {
    abstractMethodFail('between');
  };

  return TemporalUnit;
}();

var Duration = function (_TemporalAmount) {
  _inheritsLoose(Duration, _TemporalAmount);

  function Duration(seconds, nanos) {
    var _this;

    _this = _TemporalAmount.call(this) || this;
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanos);
    return _this;
  }

  Duration.ofDays = function ofDays(days) {
    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
  };

  Duration.ofHours = function ofHours(hours) {
    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
  };

  Duration.ofMinutes = function ofMinutes(minutes) {
    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
  };

  Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }

    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Duration._create(secs, nos);
  };

  Duration.ofMillis = function ofMillis(millis) {
    var secs = MathUtil.intDiv(millis, 1000);
    var mos = MathUtil.intMod(millis, 1000);

    if (mos < 0) {
      mos += 1000;
      secs--;
    }

    return Duration._create(secs, mos * 1000000);
  };

  Duration.ofNanos = function ofNanos(nanos) {
    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);

    if (nos < 0) {
      nos += LocalTime.NANOS_PER_SECOND;
      secs--;
    }

    return this._create(secs, nos);
  };

  Duration.of = function of(amount, unit) {
    return Duration.ZERO.plus(amount, unit);
  };

  Duration.from = function from(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount);
    var duration = Duration.ZERO;
    amount.units().forEach(function (unit) {
      duration = duration.plus(amount.get(unit), unit);
    });
    return duration;
  };

  Duration.between = function between(startInclusive, endExclusive) {
    requireNonNull(startInclusive, 'startInclusive');
    requireNonNull(endExclusive, 'endExclusive');
    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
    var nanos = 0;

    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
      try {
        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;

        if (secs > 0 && nanos < 0) {
          nanos += LocalTime.NANOS_PER_SECOND;
        } else if (secs < 0 && nanos > 0) {
          nanos -= LocalTime.NANOS_PER_SECOND;
        } else if (secs === 0 && nanos !== 0) {
          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
        }
      } catch (e) {}
    }

    return this.ofSeconds(secs, nanos);
  };

  Duration.parse = function parse(text) {
    requireNonNull(text, 'text');
    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');
    var matches = PATTERN.exec(text);

    if (matches !== null) {
      if ('T' === matches[3] === false) {
        var negate = '-' === matches[1];
        var dayMatch = matches[2];
        var hourMatch = matches[4];
        var minuteMatch = matches[5];
        var secondMatch = matches[6];
        var fractionMatch = matches[7];

        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');

          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');

          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');

          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');

          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';

          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);

          try {
            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
          } catch (ex) {
            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);
          }
        }
      }
    }

    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);
  };

  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
    if (parsed == null) {
      return 0;
    }

    try {
      if (parsed[0] === '+') {
        parsed = parsed.substring(1);
      }

      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
    } catch (ex) {
      throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
    }
  };

  Duration._parseFraction = function _parseFraction(text, parsed, negate) {
    if (parsed == null || parsed.length === 0) {
      return 0;
    }

    parsed = (parsed + "000000000").substring(0, 9);
    return parseFloat(parsed) * negate;
  };

  Duration._create = function _create() {
    if (arguments.length <= 2) {
      return Duration._createSecondsNanos(arguments[0], arguments[1]);
    } else {
      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
    }
  };

  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));

    if (negate) {
      return Duration.ofSeconds(seconds, nanos).negated();
    }

    return Duration.ofSeconds(seconds, nanos);
  };

  Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
    if (seconds === void 0) {
      seconds = 0;
    }

    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }

    if (seconds === 0 && nanoAdjustment === 0) {
      return Duration.ZERO;
    }

    return new Duration(seconds, nanoAdjustment);
  };

  var _proto = Duration.prototype;

  _proto.get = function get(unit) {
    if (unit === ChronoUnit.SECONDS) {
      return this._seconds;
    } else if (unit === ChronoUnit.NANOS) {
      return this._nanos;
    } else {
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
  };

  _proto.units = function units() {
    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
  };

  _proto.isZero = function isZero() {
    return this._seconds === 0 && this._nanos === 0;
  };

  _proto.isNegative = function isNegative() {
    return this._seconds < 0;
  };

  _proto.seconds = function seconds() {
    return this._seconds;
  };

  _proto.nano = function nano() {
    return this._nanos;
  };

  _proto.withSeconds = function withSeconds(seconds) {
    return Duration._create(seconds, this._nanos);
  };

  _proto.withNanos = function withNanos(nanoOfSecond) {
    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
    return Duration._create(this._seconds, nanoOfSecond);
  };

  _proto.plusDuration = function plusDuration(duration) {
    requireNonNull(duration, 'duration');
    return this.plus(duration.seconds(), duration.nano());
  };

  _proto.plus = function plus(durationOrNumber, unitOrNumber) {
    if (arguments.length === 1) {
      return this.plusDuration(durationOrNumber);
    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
      return this.plusAmountUnit(durationOrNumber, unitOrNumber);
    } else {
      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
    }
  };

  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');

    if (unit === ChronoUnit.DAYS) {
      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
    }

    if (unit.isDurationEstimated()) {
      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');
    }

    if (amountToAdd === 0) {
      return this;
    }

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);

        case ChronoUnit.MICROS:
          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);

        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);

        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
      }

      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
    }

    var duration = unit.duration().multipliedBy(amountToAdd);
    return this.plusSecondsNanos(duration.seconds(), duration.nano());
  };

  _proto.plusDays = function plusDays(daysToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
  };

  _proto.plusHours = function plusHours(hoursToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
  };

  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
  };

  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this.plusSecondsNanos(secondsToAdd, 0);
  };

  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);
  };

  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this.plusSecondsNanos(0, nanosToAdd);
  };

  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
    requireNonNull(secondsToAdd, 'secondsToAdd');
    requireNonNull(nanosToAdd, 'nanosToAdd');

    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }

    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
    return Duration.ofSeconds(epochSec, nanoAdjustment);
  };

  _proto.minus = function minus(durationOrNumber, unit) {
    if (arguments.length === 1) {
      return this.minusDuration(durationOrNumber);
    } else {
      return this.minusAmountUnit(durationOrNumber, unit);
    }
  };

  _proto.minusDuration = function minusDuration(duration) {
    requireNonNull(duration, 'duration');
    var secsToSubtract = duration.seconds();
    var nanosToSubtract = duration.nano();

    if (secsToSubtract === MIN_SAFE_INTEGER) {
      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
    }

    return this.plus(-secsToSubtract, -nanosToSubtract);
  };

  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
  };

  _proto.minusDays = function minusDays(daysToSubtract) {
    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
  };

  _proto.minusHours = function minusHours(hoursToSubtract) {
    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
  };

  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
  };

  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
  };

  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
  };

  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
  };

  _proto.multipliedBy = function multipliedBy(multiplicand) {
    if (multiplicand === 0) {
      return Duration.ZERO;
    }

    if (multiplicand === 1) {
      return this;
    }

    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
    return Duration.ofSeconds(secs, nos);
  };

  _proto.dividedBy = function dividedBy(divisor) {
    if (divisor === 0) {
      throw new ArithmeticException('Cannot divide by zero');
    }

    if (divisor === 1) {
      return this;
    }

    var secs = MathUtil.intDiv(this._seconds, divisor);
    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intDiv(this._nanos, divisor);
    nos = secsMod + nos;
    return Duration.ofSeconds(secs, nos);
  };

  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };

  _proto.abs = function abs() {
    return this.isNegative() ? this.negated() : this;
  };

  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');

    if (this._seconds !== 0) {
      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
    }

    if (this._nanos !== 0) {
      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
    }

    return temporal;
  };

  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');

    if (this._seconds !== 0) {
      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
    }

    if (this._nanos !== 0) {
      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
    }

    return temporal;
  };

  _proto.toDays = function toDays() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
  };

  _proto.toHours = function toHours() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
  };

  _proto.toMinutes = function toMinutes() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
  };

  _proto.toMillis = function toMillis() {
    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));
    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));
    return millis;
  };

  _proto.toNanos = function toNanos() {
    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
    return totalNanos;
  };

  _proto.compareTo = function compareTo(otherDuration) {
    requireNonNull(otherDuration, 'otherDuration');
    requireInstance(otherDuration, Duration, 'otherDuration');
    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());

    if (cmp !== 0) {
      return cmp;
    }

    return this._nanos - otherDuration.nano();
  };

  _proto.equals = function equals(otherDuration) {
    if (this === otherDuration) {
      return true;
    }

    if (otherDuration instanceof Duration) {
      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
    }

    return false;
  };

  _proto.toString = function toString() {
    if (this === Duration.ZERO) {
      return 'PT0S';
    }

    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
    var rval = 'PT';

    if (hours !== 0) {
      rval += hours + "H";
    }

    if (minutes !== 0) {
      rval += minutes + "M";
    }

    if (secs === 0 && this._nanos === 0 && rval.length > 2) {
      return rval;
    }

    if (secs < 0 && this._nanos > 0) {
      if (secs === -1) {
        rval += '-0';
      } else {
        rval += secs + 1;
      }
    } else {
      rval += secs;
    }

    if (this._nanos > 0) {
      rval += '.';
      var nanoString;

      if (secs < 0) {
        nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
      } else {
        nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
      }

      nanoString = nanoString.slice(1, nanoString.length);
      rval += nanoString;

      while (rval.charAt(rval.length - 1) === '0') {
        rval = rval.slice(0, rval.length - 1);
      }
    }

    rval += 'S';
    return rval;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return Duration;
}(TemporalAmount);
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
 */
var YearConstants = function YearConstants() {};
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}

var ChronoUnit = function (_TemporalUnit) {
  _inheritsLoose(ChronoUnit, _TemporalUnit);

  function ChronoUnit(name, estimatedDuration) {
    var _this;

    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }

  var _proto = ChronoUnit.prototype;

  _proto.duration = function duration() {
    return this._duration;
  };

  _proto.isDurationEstimated = function isDurationEstimated() {
    return this.isDateBased() || this === ChronoUnit.FOREVER;
  };

  _proto.isDateBased = function isDateBased() {
    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;
  };

  _proto.isTimeBased = function isTimeBased() {
    return this.compareTo(ChronoUnit.DAYS) < 0;
  };

  _proto.isSupportedBy = function isSupportedBy(temporal) {
    if (this === ChronoUnit.FOREVER) {
      return false;
    }

    try {
      temporal.plus(1, this);
      return true;
    } catch (e) {
      try {
        temporal.plus(-1, this);
        return true;
      } catch (e2) {
        return false;
      }
    }
  };

  _proto.addTo = function addTo(temporal, amount) {
    return temporal.plus(amount, this);
  };

  _proto.between = function between(temporal1, temporal2) {
    return temporal1.until(temporal2, this);
  };

  _proto.toString = function toString() {
    return this._name;
  };

  _proto.compareTo = function compareTo(other) {
    return this.duration().compareTo(other.duration());
  };

  return ChronoUnit;
}(TemporalUnit);
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));
  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));
  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));
  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var TemporalField = function () {
  function TemporalField() {}

  var _proto = TemporalField.prototype;

  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };

  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };

  _proto.baseUnit = function baseUnit() {
    abstractMethodFail('baseUnit');
  };

  _proto.rangeUnit = function rangeUnit() {
    abstractMethodFail('rangeUnit');
  };

  _proto.range = function range() {
    abstractMethodFail('range');
  };

  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    abstractMethodFail('rangeRefinedBy');
  };

  _proto.getFrom = function getFrom(temporal) {
    abstractMethodFail('getFrom');
  };

  _proto.adjustInto = function adjustInto(temporal, newValue) {
    abstractMethodFail('adjustInto');
  };

  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };

  _proto.displayName = function displayName() {
    abstractMethodFail('displayName');
  };

  _proto.equals = function equals(other) {
    abstractMethodFail('equals');
  };

  _proto.name = function name() {
    abstractMethodFail('name');
  };

  return TemporalField;
}();

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ValueRange = function () {
  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {
    assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
    assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
    assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
    this._minSmallest = minSmallest;
    this._minLargest = minLargest;
    this._maxLargest = maxLargest;
    this._maxSmallest = maxSmallest;
  }

  var _proto = ValueRange.prototype;

  _proto.isFixed = function isFixed() {
    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
  };

  _proto.minimum = function minimum() {
    return this._minSmallest;
  };

  _proto.largestMinimum = function largestMinimum() {
    return this._minLargest;
  };

  _proto.maximum = function maximum() {
    return this._maxLargest;
  };

  _proto.smallestMaximum = function smallestMaximum() {
    return this._maxSmallest;
  };

  _proto.isValidValue = function isValidValue(value) {
    return this.minimum() <= value && value <= this.maximum();
  };

  _proto.checkValidValue = function checkValidValue(value, field) {
    var msg;

    if (!this.isValidValue(value)) {
      if (field != null) {
        msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
      } else {
        msg = "Invalid value (valid values " + this.toString() + "): " + value;
      }

      return assert(false, msg, DateTimeException);
    }

    return value;
  };

  _proto.checkValidIntValue = function checkValidIntValue(value, field) {
    if (this.isValidIntValue(value) === false) {
      throw new DateTimeException("Invalid int value for " + field + ": " + value);
    }

    return value;
  };

  _proto.isValidIntValue = function isValidIntValue(value) {
    return this.isIntValue() && this.isValidValue(value);
  };

  _proto.isIntValue = function isIntValue() {
    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
  };

  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }

    if (other instanceof ValueRange) {
      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
  };

  _proto.toString = function toString() {
    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : '');
    str += ' - ';
    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : '');
    return str;
  };

  ValueRange.of = function of() {
    if (arguments.length === 2) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);
    } else if (arguments.length === 3) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);
    } else if (arguments.length === 4) {
      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);
    } else {
      return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
    }
  };

  return ValueRange;
}();

var ChronoField = function (_TemporalField) {
  _inheritsLoose(ChronoField, _TemporalField);

  ChronoField.byName = function byName(fieldName) {
    for (var prop in ChronoField) {
      if (ChronoField[prop]) {
        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {
          return ChronoField[prop];
        }
      }
    }
  };

  function ChronoField(name, baseUnit, rangeUnit, range) {
    var _this;

    _this = _TemporalField.call(this) || this;
    _this._name = name;
    _this._baseUnit = baseUnit;
    _this._rangeUnit = rangeUnit;
    _this._range = range;
    return _this;
  }

  var _proto = ChronoField.prototype;

  _proto.name = function name() {
    return this._name;
  };

  _proto.baseUnit = function baseUnit() {
    return this._baseUnit;
  };

  _proto.rangeUnit = function rangeUnit() {
    return this._rangeUnit;
  };

  _proto.range = function range() {
    return this._range;
  };

  _proto.displayName = function displayName() {
    return this.toString();
  };

  _proto.checkValidValue = function checkValidValue(value) {
    return this.range().checkValidValue(value, this);
  };

  _proto.checkValidIntValue = function checkValidIntValue(value) {
    return this.range().checkValidIntValue(value, this);
  };

  _proto.isDateBased = function isDateBased() {
    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;
    return dateBased;
  };

  _proto.isTimeBased = function isTimeBased() {
    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;
    return timeBased;
  };

  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return temporal.range(this);
  };

  _proto.getFrom = function getFrom(temporal) {
    return temporal.getLong(this);
  };

  _proto.toString = function toString() {
    return this.name();
  };

  _proto.equals = function equals(other) {
    return this === other;
  };

  _proto.adjustInto = function adjustInto(temporal, newValue) {
    return temporal.with(this, newValue);
  };

  _proto.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(this);
  };

  return ChronoField;
}(TemporalField);
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');
  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(Math.floor(YearConstants.MIN_VALUE * 365.25), Math.floor(YearConstants.MAX_VALUE * 365.25)));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');
  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');
  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalQueries = function () {
  function TemporalQueries() {}

  TemporalQueries.zoneId = function zoneId() {
    return TemporalQueries.ZONE_ID;
  };

  TemporalQueries.chronology = function chronology() {
    return TemporalQueries.CHRONO;
  };

  TemporalQueries.precision = function precision() {
    return TemporalQueries.PRECISION;
  };

  TemporalQueries.zone = function zone() {
    return TemporalQueries.ZONE;
  };

  TemporalQueries.offset = function offset() {
    return TemporalQueries.OFFSET;
  };

  TemporalQueries.localDate = function localDate() {
    return TemporalQueries.LOCAL_DATE;
  };

  TemporalQueries.localTime = function localTime() {
    return TemporalQueries.LOCAL_TIME;
  };

  return TemporalQueries;
}();

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAccessor = function () {
  function TemporalAccessor() {}

  var _proto = TemporalAccessor.prototype;

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
      return null;
    }

    return _query.queryFrom(this);
  };

  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    abstractMethodFail('getLong');
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (this.isSupported(field)) {
        return field.range();
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.isSupported = function isSupported(field) {
    abstractMethodFail('isSupported');
  };

  return TemporalAccessor;
}();

var TemporalQuery = function (_Enum) {
  _inheritsLoose(TemporalQuery, _Enum);

  function TemporalQuery() {
    return _Enum.apply(this, arguments) || this;
  }

  var _proto = TemporalQuery.prototype;

  _proto.queryFrom = function queryFrom(temporal) {
    abstractMethodFail('queryFrom');
  };

  return TemporalQuery;
}(Enum);
function createTemporalQuery(name, queryFromFunction) {
  var ExtendedTemporalQuery = function (_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);

    function ExtendedTemporalQuery() {
      return _TemporalQuery.apply(this, arguments) || this;
    }

    return ExtendedTemporalQuery;
  }(TemporalQuery);

  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name);
}

var DayOfWeek = function (_TemporalAccessor) {
  _inheritsLoose(DayOfWeek, _TemporalAccessor);

  function DayOfWeek(ordinal, name) {
    var _this;

    _this = _TemporalAccessor.call(this) || this;
    _this._ordinal = ordinal;
    _this._name = name;
    return _this;
  }

  var _proto = DayOfWeek.prototype;

  _proto.ordinal = function ordinal() {
    return this._ordinal;
  };

  _proto.name = function name() {
    return this._name;
  };

  DayOfWeek.values = function values() {
    return ENUMS.slice();
  };

  DayOfWeek.valueOf = function valueOf(name) {
    var ordinal = 0;

    for (ordinal; ordinal < ENUMS.length; ordinal++) {
      if (ENUMS[ordinal].name() === name) {
        break;
      }
    }

    return DayOfWeek.of(ordinal + 1);
  };

  DayOfWeek.of = function of(dayOfWeek) {
    if (dayOfWeek < 1 || dayOfWeek > 7) {
      throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
    }

    return ENUMS[dayOfWeek - 1];
  };

  DayOfWeek.from = function from(temporal) {
    assert(temporal != null, 'temporal', NullPointerException);

    if (temporal instanceof DayOfWeek) {
      return temporal;
    }

    try {
      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
    } catch (ex) {
      if (ex instanceof DateTimeException) {
        throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''), ex);
      } else {
        throw ex;
      }
    }
  };

  _proto.value = function value() {
    return this._ordinal + 1;
  };

  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };

  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.DAY_OF_WEEK;
    }

    return field != null && field.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.get = function get(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    }

    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.plus = function plus(days) {
    var amount = MathUtil.floorMod(days, 7);
    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
  };

  _proto.minus = function minus(days) {
    return this.plus(-1 * MathUtil.floorMod(days, 7));
  };

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }

    assert(_query != null, 'query', NullPointerException);
    return _query.queryFrom(this);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
  };

  _proto.equals = function equals(other) {
    return this === other;
  };

  _proto.toString = function toString() {
    return this._name;
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, DayOfWeek, 'other');
    return this._ordinal - other._ordinal;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return DayOfWeek;
}(TemporalAccessor);
var ENUMS;
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');
  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');
  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');
  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');
  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');
  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');
  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}

var Month = function (_TemporalAccessor) {
  _inheritsLoose(Month, _TemporalAccessor);

  function Month(value, name) {
    var _this;

    _this = _TemporalAccessor.call(this) || this;
    _this._value = MathUtil.safeToInt(value);
    _this._name = name;
    return _this;
  }

  var _proto = Month.prototype;

  _proto.value = function value() {
    return this._value;
  };

  _proto.ordinal = function ordinal() {
    return this._value - 1;
  };

  _proto.name = function name() {
    return this._name;
  };

  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };

  _proto.isSupported = function isSupported(field) {
    if (null === field) {
      return false;
    }

    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR;
    }

    return field != null && field.isSupportedBy(this);
  };

  _proto.get = function get(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    }

    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.plus = function plus(months) {
    var amount = MathUtil.intMod(months, 12) + 12;
    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
    return Month.of(newMonthVal);
  };

  _proto.minus = function minus(months) {
    return this.plus(-1 * MathUtil.intMod(months, 12));
  };

  _proto.length = function length(leapYear) {
    switch (this) {
      case Month.FEBRUARY:
        return leapYear ? 29 : 28;

      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;

      default:
        return 31;
    }
  };

  _proto.minLength = function minLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 28;

      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;

      default:
        return 31;
    }
  };

  _proto.maxLength = function maxLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 29;

      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;

      default:
        return 31;
    }
  };

  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
    var leap = leapYear ? 1 : 0;

    switch (this) {
      case Month.JANUARY:
        return 1;

      case Month.FEBRUARY:
        return 32;

      case Month.MARCH:
        return 60 + leap;

      case Month.APRIL:
        return 91 + leap;

      case Month.MAY:
        return 121 + leap;

      case Month.JUNE:
        return 152 + leap;

      case Month.JULY:
        return 182 + leap;

      case Month.AUGUST:
        return 213 + leap;

      case Month.SEPTEMBER:
        return 244 + leap;

      case Month.OCTOBER:
        return 274 + leap;

      case Month.NOVEMBER:
        return 305 + leap;

      case Month.DECEMBER:
      default:
        return 335 + leap;
    }
  };

  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
    switch (this) {
      case Month.JANUARY:
      case Month.FEBRUARY:
      case Month.MARCH:
        return Month.JANUARY;

      case Month.APRIL:
      case Month.MAY:
      case Month.JUNE:
        return Month.APRIL;

      case Month.JULY:
      case Month.AUGUST:
      case Month.SEPTEMBER:
        return Month.JULY;

      case Month.OCTOBER:
      case Month.NOVEMBER:
      case Month.DECEMBER:
      default:
        return Month.OCTOBER;
    }
  };

  _proto.query = function query(_query) {
    assert(_query != null, 'query() parameter must not be null', DateTimeException);

    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    }

    return _TemporalAccessor.prototype.query.call(this, _query);
  };

  _proto.toString = function toString() {
    switch (this) {
      case Month.JANUARY:
        return 'JANUARY';

      case Month.FEBRUARY:
        return 'FEBRUARY';

      case Month.MARCH:
        return 'MARCH';

      case Month.APRIL:
        return 'APRIL';

      case Month.MAY:
        return 'MAY';

      case Month.JUNE:
        return 'JUNE';

      case Month.JULY:
        return 'JULY';

      case Month.AUGUST:
        return 'AUGUST';

      case Month.SEPTEMBER:
        return 'SEPTEMBER';

      case Month.OCTOBER:
        return 'OCTOBER';

      case Month.NOVEMBER:
        return 'NOVEMBER';

      case Month.DECEMBER:
        return 'DECEMBER';

      default:
        return "unknown Month, value: " + this.value();
    }
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Month, 'other');
    return this._value - other._value;
  };

  _proto.equals = function equals(other) {
    return this === other;
  };

  Month.valueOf = function valueOf(name) {
    var ordinal = 0;

    for (ordinal; ordinal < MONTHS.length; ordinal++) {
      if (MONTHS[ordinal].name() === name) {
        break;
      }
    }

    return Month.of(ordinal + 1);
  };

  Month.values = function values() {
    return MONTHS.slice();
  };

  Month.of = function of(month) {
    if (month < 1 || month > 12) {
      assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
    }

    return MONTHS[month - 1];
  };

  Month.from = function from(temporal) {
    if (temporal instanceof Month) {
      return temporal;
    }

    try {
      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);
    }
  };

  return Month;
}(TemporalAccessor);
var MONTHS;
function _init$i() {
  Month.JANUARY = new Month(1, 'JANUARY');
  Month.FEBRUARY = new Month(2, 'FEBRUARY');
  Month.MARCH = new Month(3, 'MARCH');
  Month.APRIL = new Month(4, 'APRIL');
  Month.MAY = new Month(5, 'MAY');
  Month.JUNE = new Month(6, 'JUNE');
  Month.JULY = new Month(7, 'JULY');
  Month.AUGUST = new Month(8, 'AUGUST');
  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');
  Month.OCTOBER = new Month(10, 'OCTOBER');
  Month.NOVEMBER = new Month(11, 'NOVEMBER');
  Month.DECEMBER = new Month(12, 'DECEMBER');
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}

var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
var Period = function (_TemporalAmount) {
  _inheritsLoose(Period, _TemporalAmount);

  function Period(years, months, days) {
    var _this;

    _this = _TemporalAmount.call(this) || this;

    var _years = MathUtil.safeToInt(years);

    var _months = MathUtil.safeToInt(months);

    var _days = MathUtil.safeToInt(days);

    if (_years === 0 && _months === 0 && _days === 0) {
      if (!Period.ZERO) {
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        Period.ZERO = _assertThisInitialized(_this);
      }

      return Period.ZERO || _assertThisInitialized(_this);
    }

    _this._years = _years;
    _this._months = _months;
    _this._days = _days;
    return _this;
  }

  Period.ofYears = function ofYears(years) {
    return Period.create(years, 0, 0);
  };

  Period.ofMonths = function ofMonths(months) {
    return Period.create(0, months, 0);
  };

  Period.ofWeeks = function ofWeeks(weeks) {
    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));
  };

  Period.ofDays = function ofDays(days) {
    return Period.create(0, 0, days);
  };

  Period.of = function of(years, months, days) {
    return Period.create(years, months, days);
  };

  Period.from = function from(amount) {
    if (amount instanceof Period) {
      return amount;
    }

    requireNonNull(amount, 'amount');
    var years = 0;
    var months = 0;
    var days = 0;
    var units = amount.units();

    for (var i = 0; i < units.length; i++) {
      var unit = units[i];
      var unitAmount = amount.get(unit);

      if (unit === ChronoUnit.YEARS) {
        years = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.MONTHS) {
        months = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.DAYS) {
        days = MathUtil.safeToInt(unitAmount);
      } else {
        throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
      }
    }

    return Period.create(years, months, days);
  };

  Period.between = function between(startDate, endDate) {
    requireNonNull(startDate, 'startDate');
    requireNonNull(endDate, 'endDate');
    requireInstance(startDate, LocalDate, 'startDate');
    requireInstance(endDate, LocalDate, 'endDate');
    return startDate.until(endDate);
  };

  Period.parse = function parse(text) {
    requireNonNull(text, 'text');

    try {
      return Period._parse(text);
    } catch (ex) {
      if (ex instanceof ArithmeticException) {
        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);
      } else {
        throw ex;
      }
    }
  };

  Period._parse = function _parse(text) {
    var matches = PATTERN.exec(text);

    if (matches != null) {
      var negate = '-' === matches[1] ? -1 : 1;
      var yearMatch = matches[2];
      var monthMatch = matches[3];
      var weekMatch = matches[4];
      var dayMatch = matches[5];

      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
        var years = Period._parseNumber(text, yearMatch, negate);

        var months = Period._parseNumber(text, monthMatch, negate);

        var weeks = Period._parseNumber(text, weekMatch, negate);

        var days = Period._parseNumber(text, dayMatch, negate);

        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
        return Period.create(years, months, days);
      }
    }

    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);
  };

  Period._parseNumber = function _parseNumber(text, str, negate) {
    if (str == null) {
      return 0;
    }

    var val = MathUtil.parseInt(str);
    return MathUtil.safeMultiply(val, negate);
  };

  Period.create = function create(years, months, days) {
    return new Period(years, months, days);
  };

  var _proto = Period.prototype;

  _proto.units = function units() {
    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
  };

  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };

  _proto.get = function get(unit) {
    if (unit === ChronoUnit.YEARS) {
      return this._years;
    }

    if (unit === ChronoUnit.MONTHS) {
      return this._months;
    }

    if (unit === ChronoUnit.DAYS) {
      return this._days;
    }

    throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
  };

  _proto.isZero = function isZero() {
    return this === Period.ZERO;
  };

  _proto.isNegative = function isNegative() {
    return this._years < 0 || this._months < 0 || this._days < 0;
  };

  _proto.years = function years() {
    return this._years;
  };

  _proto.months = function months() {
    return this._months;
  };

  _proto.days = function days() {
    return this._days;
  };

  _proto.withYears = function withYears(years) {
    if (years === this._years) {
      return this;
    }

    return Period.create(years, this._months, this._days);
  };

  _proto.withMonths = function withMonths(months) {
    if (months === this._months) {
      return this;
    }

    return Period.create(this._years, months, this._days);
  };

  _proto.withDays = function withDays(days) {
    if (days === this._days) {
      return this;
    }

    return Period.create(this._years, this._months, days);
  };

  _proto.plus = function plus(amountToAdd) {
    var amount = Period.from(amountToAdd);
    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
  };

  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }

    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
  };

  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }

    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
  };

  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }

    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
  };

  _proto.minus = function minus(amountToSubtract) {
    var amount = Period.from(amountToSubtract);
    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
  };

  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(-1 * yearsToSubtract);
  };

  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(-1 * monthsToSubtract);
  };

  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(-1 * daysToSubtract);
  };

  _proto.multipliedBy = function multipliedBy(scalar) {
    if (this === Period.ZERO || scalar === 1) {
      return this;
    }

    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
  };

  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };

  _proto.normalized = function normalized() {
    var totalMonths = this.toTotalMonths();
    var splitYears = MathUtil.intDiv(totalMonths, 12);
    var splitMonths = MathUtil.intMod(totalMonths, 12);

    if (splitYears === this._years && splitMonths === this._months) {
      return this;
    }

    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
  };

  _proto.toTotalMonths = function toTotalMonths() {
    return this._years * 12 + this._months;
  };

  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');

    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.plus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
    }

    if (this._days !== 0) {
      temporal = temporal.plus(this._days, ChronoUnit.DAYS);
    }

    return temporal;
  };

  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');

    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.minus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
    }

    if (this._days !== 0) {
      temporal = temporal.minus(this._days, ChronoUnit.DAYS);
    }

    return temporal;
  };

  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }

    if (obj instanceof Period) {
      var other = obj;
      return this._years === other._years && this._months === other._months && this._days === other._days;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._years, this._months, this._days);
  };

  _proto.toString = function toString() {
    if (this === Period.ZERO) {
      return 'P0D';
    } else {
      var buf = 'P';

      if (this._years !== 0) {
        buf += this._years + "Y";
      }

      if (this._months !== 0) {
        buf += this._months + "M";
      }

      if (this._days !== 0) {
        buf += this._days + "D";
      }

      return buf;
    }
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return Period;
}(TemporalAmount);
function _init$h() {
  Period.ofDays(0);
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ParsePosition = function () {
  function ParsePosition(index) {
    this._index = index;
    this._errorIndex = -1;
  }

  var _proto = ParsePosition.prototype;

  _proto.getIndex = function getIndex() {
    return this._index;
  };

  _proto.setIndex = function setIndex(index) {
    this._index = index;
  };

  _proto.getErrorIndex = function getErrorIndex() {
    return this._errorIndex;
  };

  _proto.setErrorIndex = function setErrorIndex(errorIndex) {
    this._errorIndex = errorIndex;
  };

  return ParsePosition;
}();

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var EnumMap = function () {
  function EnumMap() {
    this._map = {};
  }

  var _proto = EnumMap.prototype;

  _proto.putAll = function putAll(otherMap) {
    for (var key in otherMap._map) {
      this._map[key] = otherMap._map[key];
    }

    return this;
  };

  _proto.containsKey = function containsKey(key) {
    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;
  };

  _proto.get = function get(key) {
    return this._map[key.name()];
  };

  _proto.put = function put(key, val) {
    return this.set(key, val);
  };

  _proto.set = function set(key, val) {
    this._map[key.name()] = val;
    return this;
  };

  _proto.retainAll = function retainAll(keyList) {
    var map = {};

    for (var i = 0; i < keyList.length; i++) {
      var key = keyList[i].name();
      map[key] = this._map[key];
    }

    this._map = map;
    return this;
  };

  _proto.remove = function remove(key) {
    var keyName = key.name();
    var val = this._map[keyName];
    this._map[keyName] = undefined;
    return val;
  };

  _proto.keySet = function keySet() {
    return this._map;
  };

  _proto.clear = function clear() {
    this._map = {};
  };

  return EnumMap;
}();

var ResolverStyle = function (_Enum) {
  _inheritsLoose(ResolverStyle, _Enum);

  function ResolverStyle() {
    return _Enum.apply(this, arguments) || this;
  }

  return ResolverStyle;
}(Enum);
ResolverStyle.STRICT = new ResolverStyle('STRICT');
ResolverStyle.SMART = new ResolverStyle('SMART');
ResolverStyle.LENIENT = new ResolverStyle('LENIENT');

var Temporal = function (_TemporalAccessor) {
  _inheritsLoose(Temporal, _TemporalAccessor);

  function Temporal() {
    return _TemporalAccessor.apply(this, arguments) || this;
  }

  var _proto = Temporal.prototype;

  _proto.isSupported = function isSupported(fieldOrUnit) {
    abstractMethodFail('isSupported');
  };

  _proto.minus = function minus(amount, unit) {
    if (arguments.length < 2) {
      return this._minusAmount(amount);
    } else {
      return this._minusUnit(amount, unit);
    }
  };

  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.subtractFrom(this);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    return this._plusUnit(-amountToSubtract, unit);
  };

  _proto.plus = function plus(amount, unit) {
    if (arguments.length < 2) {
      return this._plusAmount(amount);
    } else {
      return this._plusUnit(amount, unit);
    }
  };

  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.addTo(this);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    abstractMethodFail('_plusUnit');
  };

  _proto.until = function until(endTemporal, unit) {
    abstractMethodFail('until');
  };

  _proto.with = function _with(adjusterOrField, newValue) {
    if (arguments.length < 2) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, newValue);
    }
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    assert(typeof adjuster.adjustInto === 'function', 'adjuster must be a TemporalAdjuster', IllegalArgumentException);
    return adjuster.adjustInto(this);
  };

  _proto._withField = function _withField(field, newValue) {
    abstractMethodFail('_withField');
  };

  return Temporal;
}(TemporalAccessor);

if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  Temporal.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }

    throw new TypeError('A conversion from Temporal to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

var ChronoLocalDate = function (_Temporal) {
  _inheritsLoose(ChronoLocalDate, _Temporal);

  function ChronoLocalDate() {
    return _Temporal.apply(this, arguments) || this;
  }

  var _proto = ChronoLocalDate.prototype;

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toEpochDay());
    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };

  return ChronoLocalDate;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringUtil = function () {
  function StringUtil() {}

  StringUtil.startsWith = function startsWith(text, pattern) {
    return text.indexOf(pattern) === 0;
  };

  StringUtil.hashCode = function hashCode(text) {
    var len = text.length;

    if (len === 0) {
      return 0;
    }

    var hash = 0;

    for (var i = 0; i < len; i++) {
      var chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }

    return MathUtil.smi(hash);
  };

  return StringUtil;
}();

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneId = function () {
  function ZoneId() {}

  ZoneId.systemDefault = function systemDefault() {
    throw new DateTimeException('not supported operation');
  };

  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {
    throw new DateTimeException('not supported operation');
  };

  ZoneId.of = function of(zoneId) {
    throw new DateTimeException("not supported operation" + zoneId);
  };

  ZoneId.ofOffset = function ofOffset(prefix, offset) {
    throw new DateTimeException("not supported operation" + prefix + offset);
  };

  ZoneId.from = function from(temporal) {
    throw new DateTimeException("not supported operation" + temporal);
  };

  var _proto = ZoneId.prototype;

  _proto.id = function id() {
    abstractMethodFail('ZoneId.id');
  };

  _proto.rules = function rules() {
    abstractMethodFail('ZoneId.rules');
  };

  _proto.normalized = function normalized() {
    var rules = this.rules();

    if (rules.isFixedOffset()) {
      return rules.offset(Instant.EPOCH);
    }

    return this;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof ZoneId) {
      return this.id() === other.id();
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return StringUtil.hashCode(this.id());
  };

  _proto.toString = function toString() {
    return this.id();
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return ZoneId;
}();

var ZoneRules = function () {
  function ZoneRules() {}

  ZoneRules.of = function of(offset) {
    requireNonNull(offset, 'offset');
    return new Fixed(offset);
  };

  var _proto = ZoneRules.prototype;

  _proto.isFixedOffset = function isFixedOffset() {
    abstractMethodFail('ZoneRules.isFixedOffset');
  };

  _proto.offset = function offset(instantOrLocalDateTime) {
    if (instantOrLocalDateTime instanceof Instant) {
      return this.offsetOfInstant(instantOrLocalDateTime);
    } else {
      return this.offsetOfLocalDateTime(instantOrLocalDateTime);
    }
  };

  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    abstractMethodFail('ZoneRules.offsetInstant');
  };

  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    abstractMethodFail('ZoneRules.offsetOfEpochMilli');
  };

  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    abstractMethodFail('ZoneRules.offsetLocalDateTime');
  };

  _proto.validOffsets = function validOffsets(localDateTime) {
    abstractMethodFail('ZoneRules.validOffsets');
  };

  _proto.transition = function transition(localDateTime) {
    abstractMethodFail('ZoneRules.transition');
  };

  _proto.standardOffset = function standardOffset(instant) {
    abstractMethodFail('ZoneRules.standardOffset');
  };

  _proto.daylightSavings = function daylightSavings(instant) {
    abstractMethodFail('ZoneRules.daylightSavings');
  };

  _proto.isDaylightSavings = function isDaylightSavings(instant) {
    abstractMethodFail('ZoneRules.isDaylightSavings');
  };

  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
    abstractMethodFail('ZoneRules.isValidOffset');
  };

  _proto.nextTransition = function nextTransition(instant) {
    abstractMethodFail('ZoneRules.nextTransition');
  };

  _proto.previousTransition = function previousTransition(instant) {
    abstractMethodFail('ZoneRules.previousTransition');
  };

  _proto.transitions = function transitions() {
    abstractMethodFail('ZoneRules.transitions');
  };

  _proto.transitionRules = function transitionRules() {
    abstractMethodFail('ZoneRules.transitionRules');
  };

  _proto.toString = function toString() {
    abstractMethodFail('ZoneRules.toString');
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return ZoneRules;
}();

var Fixed = function (_ZoneRules) {
  _inheritsLoose(Fixed, _ZoneRules);

  function Fixed(offset) {
    var _this;

    _this = _ZoneRules.call(this) || this;
    _this._offset = offset;
    return _this;
  }

  var _proto2 = Fixed.prototype;

  _proto2.isFixedOffset = function isFixedOffset() {
    return true;
  };

  _proto2.offsetOfInstant = function offsetOfInstant() {
    return this._offset;
  };

  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
    return this._offset;
  };

  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
    return this._offset;
  };

  _proto2.validOffsets = function validOffsets() {
    return [this._offset];
  };

  _proto2.transition = function transition() {
    return null;
  };

  _proto2.standardOffset = function standardOffset() {
    return this._offset;
  };

  _proto2.daylightSavings = function daylightSavings() {
    return Duration.ZERO;
  };

  _proto2.isDaylightSavings = function isDaylightSavings() {
    return false;
  };

  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
    return this._offset.equals(offset);
  };

  _proto2.nextTransition = function nextTransition() {
    return null;
  };

  _proto2.previousTransition = function previousTransition() {
    return null;
  };

  _proto2.transitions = function transitions() {
    return [];
  };

  _proto2.transitionRules = function transitionRules() {
    return [];
  };

  _proto2.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof Fixed) {
      return this._offset.equals(other._offset);
    }

    return false;
  };

  _proto2.toString = function toString() {
    return "FixedRules:" + this._offset.toString();
  };

  return Fixed;
}(ZoneRules);

var SECONDS_CACHE = {};
var ID_CACHE = {};
var ZoneOffset = function (_ZoneId) {
  _inheritsLoose(ZoneOffset, _ZoneId);

  function ZoneOffset(totalSeconds) {
    var _this;

    _this = _ZoneId.call(this) || this;

    ZoneOffset._validateTotalSeconds(totalSeconds);

    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
    _this._rules = ZoneRules.of(_assertThisInitialized(_this));
    _this._id = ZoneOffset._buildId(totalSeconds);
    return _this;
  }

  var _proto = ZoneOffset.prototype;

  _proto.totalSeconds = function totalSeconds() {
    return this._totalSeconds;
  };

  _proto.id = function id() {
    return this._id;
  };

  ZoneOffset._buildId = function _buildId(totalSeconds) {
    if (totalSeconds === 0) {
      return 'Z';
    } else {
      var absTotalSeconds = Math.abs(totalSeconds);
      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
      var buf = "" + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;
      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);

      if (absSeconds !== 0) {
        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;
      }

      return buf;
    }
  };

  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };

  ZoneOffset._validate = function _validate(hours, minutes, seconds) {
    if (hours < -18 || hours > 18) {
      throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
    }

    if (hours > 0) {
      if (minutes < 0 || seconds < 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');
      }
    } else if (hours < 0) {
      if (minutes > 0 || seconds > 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');
      }
    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');
    }

    if (Math.abs(minutes) > 59) {
      throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
    }

    if (Math.abs(seconds) > 59) {
      throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
    }

    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };

  ZoneOffset.of = function of(offsetId) {
    requireNonNull(offsetId, 'offsetId');
    var offset = ID_CACHE[offsetId];

    if (offset != null) {
      return offset;
    }

    var hours, minutes, seconds;

    switch (offsetId.length) {
      case 2:
        offsetId = offsetId[0] + "0" + offsetId[1];

      case 3:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = 0;
        seconds = 0;
        break;

      case 5:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = 0;
        break;

      case 6:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = 0;
        break;

      case 7:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = ZoneOffset._parseNumber(offsetId, 5, false);
        break;

      case 9:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = ZoneOffset._parseNumber(offsetId, 7, true);
        break;

      default:
        throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
    }

    var first = offsetId[0];

    if (first !== '+' && first !== '-') {
      throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
    }

    if (first === '-') {
      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
    } else {
      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);
    }
  };

  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
    if (precededByColon && offsetId[pos - 1] !== ':') {
      throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
    }

    var ch1 = offsetId[pos];
    var ch2 = offsetId[pos + 1];

    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
    }

    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
  };

  ZoneOffset.ofHours = function ofHours(hours) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);
  };

  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);
  };

  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
    ZoneOffset._validate(hours, minutes, seconds);

    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };

  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };

  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
      var totalSecs = totalSeconds;
      var result = SECONDS_CACHE[totalSecs];

      if (result == null) {
        result = new ZoneOffset(totalSeconds);
        SECONDS_CACHE[totalSecs] = result;
        ID_CACHE[result.id()] = result;
      }

      return result;
    } else {
      return new ZoneOffset(totalSeconds);
    }
  };

  _proto.rules = function rules() {
    return this._rules;
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    if (field === ChronoField.OFFSET_SECONDS) {
      return this._totalSeconds;
    } else if (field instanceof ChronoField) {
      throw new DateTimeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
      return null;
    }

    return _query.queryFrom(this);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    return other._totalSeconds - this._totalSeconds;
  };

  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }

    if (obj instanceof ZoneOffset) {
      return this._totalSeconds === obj._totalSeconds;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._totalSeconds;
  };

  _proto.toString = function toString() {
    return this._id;
  };

  return ZoneOffset;
}(ZoneId);
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}

var DateTimeBuilder = function (_TemporalAccessor) {
  _inheritsLoose(DateTimeBuilder, _TemporalAccessor);

  DateTimeBuilder.create = function create(field, value) {
    var dtb = new DateTimeBuilder();

    dtb._addFieldValue(field, value);

    return dtb;
  };

  function DateTimeBuilder() {
    var _this;

    _this = _TemporalAccessor.call(this) || this;
    _this.fieldValues = new EnumMap();
    _this.chrono = null;
    _this.zone = null;
    _this.date = null;
    _this.time = null;
    _this.leapSecond = false;
    _this.excessDays = null;
    return _this;
  }

  var _proto = DateTimeBuilder.prototype;

  _proto.getFieldValue0 = function getFieldValue0(field) {
    return this.fieldValues.get(field);
  };

  _proto._addFieldValue = function _addFieldValue(field, value) {
    requireNonNull(field, 'field');
    var old = this.getFieldValue0(field);

    if (old != null && old !== value) {
      throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
    }

    return this._putFieldValue0(field, value);
  };

  _proto._putFieldValue0 = function _putFieldValue0(field, value) {
    this.fieldValues.put(field, value);
    return this;
  };

  _proto.resolve = function resolve(resolverStyle, resolverFields) {
    if (resolverFields != null) {
      this.fieldValues.retainAll(resolverFields);
    }

    this._mergeDate(resolverStyle);

    this._mergeTime(resolverStyle);

    this._resolveTimeInferZeroes(resolverStyle);

    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
      this.date = this.date.plus(this.excessDays);
      this.excessDays = Period.ZERO;
    }

    this._resolveInstant();

    return this;
  };

  _proto._mergeDate = function _mergeDate(resolverStyle) {
    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
  };

  _proto._checkDate = function _checkDate(date) {
    if (date != null) {
      this._addObject(date);

      for (var fieldName in this.fieldValues.keySet()) {
        var field = ChronoField.byName(fieldName);

        if (field) {
          if (this.fieldValues.get(field) !== undefined) {
            if (field.isDateBased()) {
              var val1 = void 0;

              try {
                val1 = date.getLong(field);
              } catch (ex) {
                if (ex instanceof DateTimeException) {
                  continue;
                } else {
                  throw ex;
                }
              }

              var val2 = this.fieldValues.get(field);

              if (val1 !== val2) {
                throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
              }
            }
          }
        }
      }
    }
  };

  _proto._mergeTime = function _mergeTime(resolverStyle) {
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
        }
      }

      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
    }

    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
        }
      }

      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
    }

    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
      }

      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
      }
    }

    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);

      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
    }

    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.NANO_OF_DAY.checkValidValue(nod);
      }

      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));

      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));
    }

    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MICRO_OF_DAY.checkValidValue(cod);
      }

      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));

      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));
    }

    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MILLI_OF_DAY.checkValidValue(lod);
      }

      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));

      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));
    }

    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.SECOND_OF_DAY.checkValidValue(sod);
      }

      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));

      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));

      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
    }

    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);

      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
      }

      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));

      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
    }

    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
      }

      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
      }
    }

    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);

      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));
    }

    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);

      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));

      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
    }

    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);

      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));

      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
    }

    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);

      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);
    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);

      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);
    }
  };

  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);

    if (hod == null) {
      return;
    }

    if (moh == null && (som != null || nos != null)) {
      return;
    }

    if (moh != null && som == null && nos != null) {
      return;
    }

    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (hod != null) {
        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
          hod = 0;
          this.excessDays = Period.ofDays(1);
        }

        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);

        if (moh != null) {
          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);

          if (som != null) {
            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);

            if (nos != null) {
              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);

              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
            } else {
              this._addObject(LocalTime.of(hodVal, mohVal, somVal));
            }
          } else {
            if (nos == null) {
              this._addObject(LocalTime.of(hodVal, mohVal));
            }
          }
        } else {
          if (som == null && nos == null) {
            this._addObject(LocalTime.of(hodVal, 0));
          }
        }
      }
    } else {
      if (hod != null) {
        var _hodVal = hod;

        if (moh != null) {
          if (som != null) {
            if (nos == null) {
              nos = 0;
            }

            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, nos);
            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);
            var nod = MathUtil.floorMod(totalNanos, 86400000000000);

            this._addObject(LocalTime.ofNanoOfDay(nod));

            this.excessDays = Period.ofDays(excessDays);
          } else {
            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));

            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);

            var sod = MathUtil.floorMod(totalSecs, 86400);

            this._addObject(LocalTime.ofSecondOfDay(sod));

            this.excessDays = Period.ofDays(_excessDays);
          }
        } else {
          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));

          _hodVal = MathUtil.floorMod(_hodVal, 24);

          this._addObject(LocalTime.of(_hodVal, 0));

          this.excessDays = Period.ofDays(_excessDays2);
        }
      }
    }

    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
  };

  _proto._addObject = function _addObject(dateOrTime) {
    if (dateOrTime instanceof ChronoLocalDate) {
      this.date = dateOrTime;
    } else if (dateOrTime instanceof LocalTime) {
      this.time = dateOrTime;
    }
  };

  _proto._resolveInstant = function _resolveInstant() {
    if (this.date != null && this.time != null) {
      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);

      if (offsetSecs != null) {
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
      } else if (this.zone != null) {
        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);

        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
      }
    }
  };

  _proto.build = function build(type) {
    return type.queryFrom(this);
  };

  _proto.isSupported = function isSupported(field) {
    if (field == null) {
      return false;
    }

    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    var value = this.getFieldValue0(field);

    if (value == null) {
      if (this.date != null && this.date.isSupported(field)) {
        return this.date.getLong(field);
      }

      if (this.time != null && this.time.isSupported(field)) {
        return this.time.getLong(field);
      }

      throw new DateTimeException("Field not found: " + field);
    }

    return value;
  };

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId()) {
      return this.zone;
    } else if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    } else if (_query === TemporalQueries.localDate()) {
      return this.date != null ? LocalDate.from(this.date) : null;
    } else if (_query === TemporalQueries.localTime()) {
      return this.time;
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return _query.queryFrom(this);
    } else if (_query === TemporalQueries.precision()) {
      return null;
    }

    return _query.queryFrom(this);
  };

  return DateTimeBuilder;
}(TemporalAccessor);

var DateTimeParseContext = function () {
  function DateTimeParseContext() {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DateTimeParseContext) {
        this._constructorSelf.apply(this, arguments);

        return;
      } else {
        this._constructorFormatter.apply(this, arguments);
      }
    } else {
      this._constructorParam.apply(this, arguments);
    }

    this._caseSensitive = true;
    this._strict = true;
    this._parsed = [new Parsed(this)];
  }

  var _proto = DateTimeParseContext.prototype;

  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
    this._locale = locale;
    this._symbols = symbols;
    this._overrideChronology = chronology;
  };

  _proto._constructorFormatter = function _constructorFormatter(formatter) {
    this._locale = formatter.locale();
    this._symbols = formatter.decimalStyle();
    this._overrideChronology = formatter.chronology();
  };

  _proto._constructorSelf = function _constructorSelf(other) {
    this._locale = other._locale;
    this._symbols = other._symbols;
    this._overrideChronology = other._overrideChronology;
    this._overrideZone = other._overrideZone;
    this._caseSensitive = other._caseSensitive;
    this._strict = other._strict;
    this._parsed = [new Parsed(this)];
  };

  _proto.copy = function copy() {
    return new DateTimeParseContext(this);
  };

  _proto.symbols = function symbols() {
    return this._symbols;
  };

  _proto.isStrict = function isStrict() {
    return this._strict;
  };

  _proto.setStrict = function setStrict(strict) {
    this._strict = strict;
  };

  _proto.locale = function locale() {
    return this._locale;
  };

  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };

  _proto.startOptional = function startOptional() {
    this._parsed.push(this.currentParsed().copy());
  };

  _proto.endOptional = function endOptional(successful) {
    if (successful) {
      this._parsed.splice(this._parsed.length - 2, 1);
    } else {
      this._parsed.splice(this._parsed.length - 1, 1);
    }
  };

  _proto.isCaseSensitive = function isCaseSensitive() {
    return this._caseSensitive;
  };

  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
    this._caseSensitive = caseSensitive;
  };

  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
      return false;
    }

    if (!this.isCaseSensitive()) {
      cs1 = cs1.toLowerCase();
      cs2 = cs2.toLowerCase();
    }

    for (var i = 0; i < length; i++) {
      var ch1 = cs1[offset1 + i];
      var ch2 = cs2[offset2 + i];

      if (ch1 !== ch2) {
        return false;
      }
    }

    return true;
  };

  _proto.charEquals = function charEquals(ch1, ch2) {
    if (this.isCaseSensitive()) {
      return ch1 === ch2;
    }

    return this.charEqualsIgnoreCase(ch1, ch2);
  };

  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
  };

  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
    var currentParsedFieldValues = this.currentParsed().fieldValues;
    var old = currentParsedFieldValues.get(field);
    currentParsedFieldValues.set(field, value);
    return old != null && old !== value ? ~errorPos : successPos;
  };

  _proto.setParsedZone = function setParsedZone(zone) {
    requireNonNull(zone, 'zone');
    this.currentParsed().zone = zone;
  };

  _proto.getParsed = function getParsed(field) {
    return this.currentParsed().fieldValues.get(field);
  };

  _proto.toParsed = function toParsed() {
    return this.currentParsed();
  };

  _proto.currentParsed = function currentParsed() {
    return this._parsed[this._parsed.length - 1];
  };

  _proto.setParsedLeapSecond = function setParsedLeapSecond() {
    this.currentParsed().leapSecond = true;
  };

  _proto.getEffectiveChronology = function getEffectiveChronology() {
    var chrono = this.currentParsed().chrono;

    if (chrono == null) {
      chrono = this._overrideChronology;

      if (chrono == null) {
        chrono = IsoChronology.INSTANCE;
      }
    }

    return chrono;
  };

  return DateTimeParseContext;
}();

var Parsed = function (_Temporal) {
  _inheritsLoose(Parsed, _Temporal);

  function Parsed(dateTimeParseContext) {
    var _this;

    _this = _Temporal.call(this) || this;
    _this.chrono = null;
    _this.zone = null;
    _this.fieldValues = new EnumMap();
    _this.leapSecond = false;
    _this.dateTimeParseContext = dateTimeParseContext;
    return _this;
  }

  var _proto2 = Parsed.prototype;

  _proto2.copy = function copy() {
    var cloned = new Parsed();
    cloned.chrono = this.chrono;
    cloned.zone = this.zone;
    cloned.fieldValues.putAll(this.fieldValues);
    cloned.leapSecond = this.leapSecond;
    cloned.dateTimeParseContext = this.dateTimeParseContext;
    return cloned;
  };

  _proto2.toString = function toString() {
    return this.fieldValues + ", " + this.chrono + ", " + this.zone;
  };

  _proto2.isSupported = function isSupported(field) {
    return this.fieldValues.containsKey(field);
  };

  _proto2.get = function get(field) {
    var val = this.fieldValues.get(field);
    assert(val != null);
    return val;
  };

  _proto2.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    }

    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto2.toBuilder = function toBuilder() {
    var builder = new DateTimeBuilder();
    builder.fieldValues.putAll(this.fieldValues);
    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();

    if (this.zone != null) {
      builder.zone = this.zone;
    } else {
      builder.zone = this.overrideZone;
    }

    builder.leapSecond = this.leapSecond;
    builder.excessDays = this.excessDays;
    return builder;
  };

  return Parsed;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimePrintContext = function () {
  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {
    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);
      this._locale = localeOrFormatter.locale();
      this._symbols = localeOrFormatter.decimalStyle();
    } else {
      this._temporal = temporal;
      this._locale = localeOrFormatter;
      this._symbols = symbols;
    }

    this._optional = 0;
  }

  DateTimePrintContext.adjust = function adjust(temporal, formatter) {
    return temporal;
  };

  var _proto = DateTimePrintContext.prototype;

  _proto.symbols = function symbols() {
    return this._symbols;
  };

  _proto.startOptional = function startOptional() {
    this._optional++;
  };

  _proto.endOptional = function endOptional() {
    this._optional--;
  };

  _proto.getValueQuery = function getValueQuery(query) {
    var result = this._temporal.query(query);

    if (result == null && this._optional === 0) {
      throw new DateTimeException("Unable to extract value: " + this._temporal);
    }

    return result;
  };

  _proto.getValue = function getValue(field) {
    try {
      return this._temporal.getLong(field);
    } catch (ex) {
      if (ex instanceof DateTimeException && this._optional > 0) {
        return null;
      }

      throw ex;
    }
  };

  _proto.temporal = function temporal() {
    return this._temporal;
  };

  _proto.locale = function locale() {
    return this._locale;
  };

  _proto.setDateTime = function setDateTime(temporal) {
    this._temporal = temporal;
  };

  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };

  return DateTimePrintContext;
}();

var IsoFields = {};
var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];

var Field = function (_TemporalField) {
  _inheritsLoose(Field, _TemporalField);

  function Field() {
    return _TemporalField.apply(this, arguments) || this;
  }

  var _proto = Field.prototype;

  _proto.isDateBased = function isDateBased() {
    return true;
  };

  _proto.isTimeBased = function isTimeBased() {
    return false;
  };

  _proto._isIso = function _isIso() {
    return true;
  };

  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
    var wby = Field._getWeekBasedYear(date);

    return ValueRange.of(1, Field._getWeekRangeByYear(wby));
  };

  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
    var date = LocalDate.of(wby, 1, 1);

    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
      return 53;
    }

    return 52;
  };

  Field._getWeek = function _getWeek(date) {
    var dow0 = date.dayOfWeek().ordinal();
    var doy0 = date.dayOfYear() - 1;
    var doyThu0 = doy0 + (3 - dow0);
    var alignedWeek = MathUtil.intDiv(doyThu0, 7);
    var firstThuDoy0 = doyThu0 - alignedWeek * 7;
    var firstMonDoy0 = firstThuDoy0 - 3;

    if (firstMonDoy0 < -3) {
      firstMonDoy0 += 7;
    }

    if (doy0 < firstMonDoy0) {
      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
    }

    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;

    if (week === 53) {
      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
        week = 1;
      }
    }

    return week;
  };

  Field._getWeekBasedYear = function _getWeekBasedYear(date) {
    var year = date.year();
    var doy = date.dayOfYear();

    if (doy <= 3) {
      var dow = date.dayOfWeek().ordinal();

      if (doy - dow < -2) {
        year--;
      }
    } else if (doy >= 363) {
      var _dow = date.dayOfWeek().ordinal();

      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);

      if (doy - _dow >= 0) {
        year++;
      }
    }

    return year;
  };

  _proto.displayName = function displayName() {
    return this.toString();
  };

  _proto.resolve = function resolve() {
    return null;
  };

  _proto.name = function name() {
    return this.toString();
  };

  return Field;
}(TemporalField);

var DAY_OF_QUARTER_FIELD = function (_Field) {
  _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);

  function DAY_OF_QUARTER_FIELD() {
    return _Field.apply(this, arguments) || this;
  }

  var _proto2 = DAY_OF_QUARTER_FIELD.prototype;

  _proto2.toString = function toString() {
    return 'DayOfQuarter';
  };

  _proto2.baseUnit = function baseUnit() {
    return ChronoUnit.DAYS;
  };

  _proto2.rangeUnit = function rangeUnit() {
    return QUARTER_YEARS;
  };

  _proto2.range = function range() {
    return ValueRange.of(1, 90, 92);
  };

  _proto2.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
  };

  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }

    var qoy = temporal.getLong(QUARTER_OF_YEAR);

    if (qoy === 1) {
      var year = temporal.getLong(ChronoField.YEAR);
      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
    } else if (qoy === 2) {
      return ValueRange.of(1, 91);
    } else if (qoy === 3 || qoy === 4) {
      return ValueRange.of(1, 92);
    }

    return this.range();
  };

  _proto2.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }

    var doy = temporal.get(ChronoField.DAY_OF_YEAR);
    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
    var year = temporal.getLong(ChronoField.YEAR);
    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
  };

  _proto2.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
  };

  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var yearLong = fieldValues.get(ChronoField.YEAR);
    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);

    if (yearLong == null || qoyLong == null) {
      return null;
    }

    var y = ChronoField.YEAR.checkValidIntValue(yearLong);
    var doq = fieldValues.get(DAY_OF_QUARTER);
    var date;

    if (resolverStyle === ResolverStyle.LENIENT) {
      var qoy = qoyLong;
      date = LocalDate.of(y, 1, 1);
      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
      date = date.plusDays(MathUtil.safeSubtract(doq, 1));
    } else {
      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);

      if (resolverStyle === ResolverStyle.STRICT) {
        var max = 92;

        if (_qoy === 1) {
          max = IsoChronology.isLeapYear(y) ? 91 : 90;
        } else if (_qoy === 2) {
          max = 91;
        }

        ValueRange.of(1, max).checkValidValue(doq, this);
      } else {
        this.range().checkValidValue(doq, this);
      }

      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
    }

    fieldValues.remove(this);
    fieldValues.remove(ChronoField.YEAR);
    fieldValues.remove(QUARTER_OF_YEAR);
    return date;
  };

  return DAY_OF_QUARTER_FIELD;
}(Field);

var QUARTER_OF_YEAR_FIELD = function (_Field2) {
  _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);

  function QUARTER_OF_YEAR_FIELD() {
    return _Field2.apply(this, arguments) || this;
  }

  var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;

  _proto3.toString = function toString() {
    return 'QuarterOfYear';
  };

  _proto3.baseUnit = function baseUnit() {
    return QUARTER_YEARS;
  };

  _proto3.rangeUnit = function rangeUnit() {
    return ChronoUnit.YEARS;
  };

  _proto3.range = function range() {
    return ValueRange.of(1, 4);
  };

  _proto3.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
  };

  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return this.range();
  };

  _proto3.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');
    }

    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
    return MathUtil.intDiv(moy + 2, 3);
  };

  _proto3.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
  };

  return QUARTER_OF_YEAR_FIELD;
}(Field);

var WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {
  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);

  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {
    return _Field3.apply(this, arguments) || this;
  }

  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;

  _proto4.toString = function toString() {
    return 'WeekOfWeekBasedYear';
  };

  _proto4.baseUnit = function baseUnit() {
    return ChronoUnit.WEEKS;
  };

  _proto4.rangeUnit = function rangeUnit() {
    return WEEK_BASED_YEARS;
  };

  _proto4.range = function range() {
    return ValueRange.of(1, 52, 53);
  };

  _proto4.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };

  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }

    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
  };

  _proto4.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }

    return Field._getWeek(LocalDate.from(temporal));
  };

  _proto4.adjustInto = function adjustInto(temporal, newValue) {
    this.range().checkValidValue(newValue, this);
    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
  };

  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);

    if (wbyLong == null || dowLong == null) {
      return null;
    }

    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
    var date;

    if (resolverStyle === ResolverStyle.LENIENT) {
      var dow = dowLong;
      var weeks = 0;

      if (dow > 7) {
        weeks = MathUtil.intDiv(dow - 1, 7);
        dow = MathUtil.intMod(dow - 1, 7) + 1;
      } else if (dow < 1) {
        weeks = MathUtil.intDiv(dow, 7) - 1;
        dow = MathUtil.intMod(dow, 7) + 7;
      }

      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
    } else {
      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);

      if (resolverStyle === ResolverStyle.STRICT) {
        var temp = LocalDate.of(wby, 1, 4);

        var range = Field._getWeekRangeByLocalDate(temp);

        range.checkValidValue(wowby, this);
      } else {
        this.range().checkValidValue(wowby, this);
      }

      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
    }

    fieldValues.remove(this);
    fieldValues.remove(WEEK_BASED_YEAR);
    fieldValues.remove(ChronoField.DAY_OF_WEEK);
    return date;
  };

  _proto4.displayName = function displayName() {
    return 'Week';
  };

  return WEEK_OF_WEEK_BASED_YEAR_FIELD;
}(Field);

var WEEK_BASED_YEAR_FIELD = function (_Field4) {
  _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);

  function WEEK_BASED_YEAR_FIELD() {
    return _Field4.apply(this, arguments) || this;
  }

  var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;

  _proto5.toString = function toString() {
    return 'WeekBasedYear';
  };

  _proto5.baseUnit = function baseUnit() {
    return WEEK_BASED_YEARS;
  };

  _proto5.rangeUnit = function rangeUnit() {
    return ChronoUnit.FOREVER;
  };

  _proto5.range = function range() {
    return ChronoField.YEAR.range();
  };

  _proto5.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };

  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return ChronoField.YEAR.range();
  };

  _proto5.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }

    return Field._getWeekBasedYear(LocalDate.from(temporal));
  };

  _proto5.adjustInto = function adjustInto(temporal, newValue) {
    if (this.isSupportedBy(temporal) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }

    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
    var date = LocalDate.from(temporal);
    var dow = date.get(ChronoField.DAY_OF_WEEK);

    var week = Field._getWeek(date);

    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
      week = 52;
    }

    var resolved = LocalDate.of(newWby, 1, 4);
    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
    resolved = resolved.plusDays(days);
    return temporal.with(resolved);
  };

  return WEEK_BASED_YEAR_FIELD;
}(Field);

var Unit = function (_TemporalUnit) {
  _inheritsLoose(Unit, _TemporalUnit);

  function Unit(name, estimatedDuration) {
    var _this;

    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }

  var _proto6 = Unit.prototype;

  _proto6.duration = function duration() {
    return this._duration;
  };

  _proto6.isDurationEstimated = function isDurationEstimated() {
    return true;
  };

  _proto6.isDateBased = function isDateBased() {
    return true;
  };

  _proto6.isTimeBased = function isTimeBased() {
    return false;
  };

  _proto6.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY);
  };

  _proto6.addTo = function addTo(temporal, periodToAdd) {
    switch (this) {
      case WEEK_BASED_YEARS:
        {
          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
          return temporal.with(WEEK_BASED_YEAR, added);
        }

      case QUARTER_YEARS:
        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);

      default:
        throw new IllegalStateException('Unreachable');
    }
  };

  _proto6.between = function between(temporal1, temporal2) {
    switch (this) {
      case WEEK_BASED_YEARS:
        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));

      case QUARTER_YEARS:
        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);

      default:
        throw new IllegalStateException('Unreachable');
    }
  };

  _proto6.toString = function toString() {
    return name;
  };

  return Unit;
}(TemporalUnit);

var DAY_OF_QUARTER = null;
var QUARTER_OF_YEAR = null;
var WEEK_OF_WEEK_BASED_YEAR = null;
var WEEK_BASED_YEAR = null;
var WEEK_BASED_YEARS = null;
var QUARTER_YEARS = null;
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;

  LocalDate.prototype.isoWeekOfWeekyear = function () {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };

  LocalDate.prototype.isoWeekyear = function () {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DecimalStyle = function () {
  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
    this._zeroDigit = zeroChar;
    this._zeroDigitCharCode = zeroChar.charCodeAt(0);
    this._positiveSign = positiveSignChar;
    this._negativeSign = negativeSignChar;
    this._decimalSeparator = decimalPointChar;
  }

  var _proto = DecimalStyle.prototype;

  _proto.positiveSign = function positiveSign() {
    return this._positiveSign;
  };

  _proto.withPositiveSign = function withPositiveSign(positiveSign) {
    if (positiveSign === this._positiveSign) {
      return this;
    }

    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
  };

  _proto.negativeSign = function negativeSign() {
    return this._negativeSign;
  };

  _proto.withNegativeSign = function withNegativeSign(negativeSign) {
    if (negativeSign === this._negativeSign) {
      return this;
    }

    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
  };

  _proto.zeroDigit = function zeroDigit() {
    return this._zeroDigit;
  };

  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
    if (zeroDigit === this._zeroDigit) {
      return this;
    }

    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
  };

  _proto.decimalSeparator = function decimalSeparator() {
    return this._decimalSeparator;
  };

  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
    if (decimalSeparator === this._decimalSeparator) {
      return this;
    }

    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
  };

  _proto.convertToDigit = function convertToDigit(char) {
    var val = char.charCodeAt(0) - this._zeroDigitCharCode;

    return val >= 0 && val <= 9 ? val : -1;
  };

  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
    if (this._zeroDigit === '0') {
      return numericText;
    }

    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);
    var convertedText = '';

    for (var i = 0; i < numericText.length; i++) {
      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
    }

    return convertedText;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof DecimalStyle) {
      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
  };

  _proto.toString = function toString() {
    return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
  };

  DecimalStyle.of = function of() {
    throw new Error('not yet supported');
  };

  DecimalStyle.availableLocales = function availableLocales() {
    throw new Error('not yet supported');
  };

  return DecimalStyle;
}();
DecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');

var SignStyle = function (_Enum) {
  _inheritsLoose(SignStyle, _Enum);

  function SignStyle() {
    return _Enum.apply(this, arguments) || this;
  }

  var _proto = SignStyle.prototype;

  _proto.parse = function parse(positive, strict, fixedWidth) {
    switch (this) {
      case SignStyle.NORMAL:
        return !positive || !strict;

      case SignStyle.ALWAYS:
      case SignStyle.EXCEEDS_PAD:
        return true;

      default:
        return !strict && !fixedWidth;
    }
  };

  return SignStyle;
}(Enum);
SignStyle.NORMAL = new SignStyle('NORMAL');
SignStyle.NEVER = new SignStyle('NEVER');
SignStyle.ALWAYS = new SignStyle('ALWAYS');
SignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');
SignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');

var TextStyle = function (_Enum) {
  _inheritsLoose(TextStyle, _Enum);

  function TextStyle() {
    return _Enum.apply(this, arguments) || this;
  }

  var _proto = TextStyle.prototype;

  _proto.isStandalone = function isStandalone() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
      case TextStyle.SHORT_STANDALONE:
      case TextStyle.NARROW_STANDALONE:
        return true;

      default:
        return false;
    }
  };

  _proto.asStandalone = function asStandalone() {
    switch (this) {
      case TextStyle.FULL:
        return TextStyle.FULL_STANDALONE;

      case TextStyle.SHORT:
        return TextStyle.SHORT_STANDALONE;

      case TextStyle.NARROW:
        return TextStyle.NARROW_STANDALONE;

      default:
        return this;
    }
  };

  _proto.asNormal = function asNormal() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
        return TextStyle.FULL;

      case TextStyle.SHORT_STANDALONE:
        return TextStyle.SHORT;

      case TextStyle.NARROW_STANDALONE:
        return TextStyle.NARROW;

      default:
        return this;
    }
  };

  return TextStyle;
}(Enum);
TextStyle.FULL = new TextStyle('FULL');
TextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');
TextStyle.SHORT = new TextStyle('SHORT');
TextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');
TextStyle.NARROW = new TextStyle('NARROW');
TextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var CharLiteralPrinterParser = function () {
  function CharLiteralPrinterParser(literal) {
    if (literal.length > 1) {
      throw new IllegalArgumentException("invalid literal, too long: \"" + literal + "\"");
    }

    this._literal = literal;
  }

  var _proto = CharLiteralPrinterParser.prototype;

  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var length = text.length;

    if (position === length) {
      return ~position;
    }

    var ch = text.charAt(position);

    if (context.charEquals(this._literal, ch) === false) {
      return ~position;
    }

    return position + this._literal.length;
  };

  _proto.toString = function toString() {
    if (this._literal === '\'') {
      return "''";
    }

    return "'" + this._literal + "'";
  };

  return CharLiteralPrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var CompositePrinterParser = function () {
  function CompositePrinterParser(printerParsers, optional) {
    this._printerParsers = printerParsers;
    this._optional = optional;
  }

  var _proto = CompositePrinterParser.prototype;

  _proto.withOptional = function withOptional(optional) {
    if (optional === this._optional) {
      return this;
    }

    return new CompositePrinterParser(this._printerParsers, optional);
  };

  _proto.print = function print(context, buf) {
    var length = buf.length();

    if (this._optional) {
      context.startOptional();
    }

    try {
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];

        if (pp.print(context, buf) === false) {
          buf.setLength(length);
          return true;
        }
      }
    } finally {
      if (this._optional) {
        context.endOptional();
      }
    }

    return true;
  };

  _proto.parse = function parse(context, text, position) {
    if (this._optional) {
      context.startOptional();
      var pos = position;

      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        pos = pp.parse(context, text, pos);

        if (pos < 0) {
          context.endOptional(false);
          return position;
        }
      }

      context.endOptional(true);
      return pos;
    } else {
      for (var _i = 0; _i < this._printerParsers.length; _i++) {
        var _pp = this._printerParsers[_i];
        position = _pp.parse(context, text, position);

        if (position < 0) {
          break;
        }
      }

      return position;
    }
  };

  _proto.toString = function toString() {
    var buf = '';

    if (this._printerParsers != null) {
      buf += this._optional ? '[' : '(';

      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        buf += pp.toString();
      }

      buf += this._optional ? ']' : ')';
    }

    return buf;
  };

  return CompositePrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var FractionPrinterParser = function () {
  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {
    requireNonNull(field, 'field');

    if (field.range().isFixed() === false) {
      throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
    }

    if (minWidth < 0 || minWidth > 9) {
      throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
    }

    if (maxWidth < 1 || maxWidth > 9) {
      throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
    }

    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }

    this.field = field;
    this.minWidth = minWidth;
    this.maxWidth = maxWidth;
    this.decimalPoint = decimalPoint;
  }

  var _proto = FractionPrinterParser.prototype;

  _proto.print = function print(context, buf) {
    var value = context.getValue(this.field);

    if (value === null) {
      return false;
    }

    var symbols = context.symbols();

    if (value === 0) {
      if (this.minWidth > 0) {
        if (this.decimalPoint) {
          buf.append(symbols.decimalSeparator());
        }

        for (var i = 0; i < this.minWidth; i++) {
          buf.append(symbols.zeroDigit());
        }
      }
    } else {
      var fraction = this.convertToFraction(value, symbols.zeroDigit());
      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
      fraction = fraction.substr(0, outputScale);

      if (fraction * 1 > 0) {
        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {
          fraction = fraction.substr(0, fraction.length - 1);
        }
      }

      var str = fraction;
      str = symbols.convertNumberToI18N(str);

      if (this.decimalPoint) {
        buf.append(symbols.decimalSeparator());
      }

      buf.append(str);
    }

    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var effectiveMin = context.isStrict() ? this.minWidth : 0;
    var effectiveMax = context.isStrict() ? this.maxWidth : 9;
    var length = text.length;

    if (position === length) {
      return effectiveMin > 0 ? ~position : position;
    }

    if (this.decimalPoint) {
      if (text[position] !== context.symbols().decimalSeparator()) {
        return effectiveMin > 0 ? ~position : position;
      }

      position++;
    }

    var minEndPos = position + effectiveMin;

    if (minEndPos > length) {
      return ~position;
    }

    var maxEndPos = Math.min(position + effectiveMax, length);
    var total = 0;
    var pos = position;

    while (pos < maxEndPos) {
      var ch = text.charAt(pos++);
      var digit = context.symbols().convertToDigit(ch);

      if (digit < 0) {
        if (pos < minEndPos) {
          return ~position;
        }

        pos--;
        break;
      }

      total = total * 10 + digit;
    }

    var moveLeft = pos - position;
    var scale = Math.pow(10, moveLeft);
    var value = this.convertFromFraction(total, scale);
    return context.setParsedField(this.field, value, position, pos);
  };

  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
    var range = this.field.range();
    range.checkValidValue(value, this.field);

    var _min = range.minimum();

    var _range = range.maximum() - _min + 1;

    var _value = value - _min;

    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);

    var fraction = "" + _scaled;

    while (fraction.length < 9) {
      fraction = zeroDigit + fraction;
    }

    return fraction;
  };

  _proto.convertFromFraction = function convertFromFraction(total, scale) {
    var range = this.field.range();

    var _min = range.minimum();

    var _range = range.maximum() - _min + 1;

    var _value = MathUtil.intDiv(total * _range, scale);

    return _value;
  };

  _proto.toString = function toString() {
    var decimal = this.decimalPoint ? ',DecimalPoint' : '';
    return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
  };

  return FractionPrinterParser;
}();

var MAX_WIDTH$1 = 15;
var EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
var NumberPrinterParser = function () {
  function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {
    if (subsequentWidth === void 0) {
      subsequentWidth = 0;
    }

    this._field = field;
    this._minWidth = minWidth;
    this._maxWidth = maxWidth;
    this._signStyle = signStyle;
    this._subsequentWidth = subsequentWidth;
  }

  var _proto = NumberPrinterParser.prototype;

  _proto.field = function field() {
    return this._field;
  };

  _proto.minWidth = function minWidth() {
    return this._minWidth;
  };

  _proto.maxWidth = function maxWidth() {
    return this._maxWidth;
  };

  _proto.signStyle = function signStyle() {
    return this._signStyle;
  };

  _proto.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }

    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
  };

  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
  };

  _proto._isFixedWidth = function _isFixedWidth() {
    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
  };

  _proto.print = function print(context, buf) {
    var contextValue = context.getValue(this._field);

    if (contextValue == null) {
      return false;
    }

    var value = this._getValue(context, contextValue);

    var symbols = context.symbols();
    var str = "" + Math.abs(value);

    if (str.length > this._maxWidth) {
      throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
    }

    str = symbols.convertNumberToI18N(str);

    if (value >= 0) {
      switch (this._signStyle) {
        case SignStyle.EXCEEDS_PAD:
          if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
            buf.append(symbols.positiveSign());
          }

          break;

        case SignStyle.ALWAYS:
          buf.append(symbols.positiveSign());
          break;
      }
    } else {
      switch (this._signStyle) {
        case SignStyle.NORMAL:
        case SignStyle.EXCEEDS_PAD:
        case SignStyle.ALWAYS:
          buf.append(symbols.negativeSign());
          break;

        case SignStyle.NOT_NEGATIVE:
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
      }
    }

    for (var i = 0; i < this._minWidth - str.length; i++) {
      buf.append(symbols.zeroDigit());
    }

    buf.append(str);
    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var length = text.length;

    if (position === length) {
      return ~position;
    }

    assert(position >= 0 && position < length);
    var sign = text.charAt(position);
    var negative = false;
    var positive = false;

    if (sign === context.symbols().positiveSign()) {
      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }

      positive = true;
      position++;
    } else if (sign === context.symbols().negativeSign()) {
      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }

      negative = true;
      position++;
    } else {
      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
        return ~position;
      }
    }

    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
    var minEndPos = position + effMinWidth;

    if (minEndPos > length) {
      return ~position;
    }

    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
    var total = 0;
    var pos = position;

    for (var pass = 0; pass < 2; pass++) {
      var maxEndPos = Math.min(pos + effMaxWidth, length);

      while (pos < maxEndPos) {
        var ch = text.charAt(pos++);
        var digit = context.symbols().convertToDigit(ch);

        if (digit < 0) {
          pos--;

          if (pos < minEndPos) {
            return ~position;
          }

          break;
        }

        if (pos - position > MAX_WIDTH$1) {
          throw new ArithmeticException('number text exceeds length');
        } else {
          total = total * 10 + digit;
        }
      }

      if (this._subsequentWidth > 0 && pass === 0) {
        var parseLen = pos - position;
        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
        pos = position;
        total = 0;
      } else {
        break;
      }
    }

    if (negative) {
      if (total === 0 && context.isStrict()) {
        return ~(position - 1);
      }

      if (total !== 0) {
        total = -total;
      }
    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
      var _parseLen = pos - position;

      if (positive) {
        if (_parseLen <= this._minWidth) {
          return ~(position - 1);
        }
      } else {
        if (_parseLen > this._minWidth) {
          return ~position;
        }
      }
    }

    return this._setValue(context, total, position, pos);
  };

  _proto._getValue = function _getValue(context, value) {
    return value;
  };

  _proto._setValue = function _setValue(context, value, errorPos, successPos) {
    return context.setParsedField(this._field, value, errorPos, successPos);
  };

  _proto.toString = function toString() {
    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
      return "Value(" + this._field + ")";
    }

    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
      return "Value(" + this._field + "," + this._minWidth + ")";
    }

    return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
  };

  return NumberPrinterParser;
}();
var ReducedPrinterParser = function (_NumberPrinterParser) {
  _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);

  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {
    var _this;

    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;

    if (width < 1 || width > 10) {
      throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
    }

    if (maxWidth < 1 || maxWidth > 10) {
      throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
    }

    if (maxWidth < width) {
      throw new IllegalArgumentException('The maxWidth must be greater than the width');
    }

    if (baseDate === null) {
      if (field.range().isValidValue(baseValue) === false) {
        throw new IllegalArgumentException('The base value must be within the range of the field');
      }

      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');
      }
    }

    _this._baseValue = baseValue;
    _this._baseDate = baseDate;
    return _this;
  }

  var _proto2 = ReducedPrinterParser.prototype;

  _proto2._getValue = function _getValue(context, value) {
    var absValue = Math.abs(value);
    var baseValue = this._baseValue;

    if (this._baseDate !== null) {
      context.temporal();
      var chrono = IsoChronology.INSTANCE;
      baseValue = chrono.date(this._baseDate).get(this._field);
    }

    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
      return absValue % EXCEED_POINTS[this._minWidth];
    }

    return absValue % EXCEED_POINTS[this._maxWidth];
  };

  _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
    var baseValue = this._baseValue;

    if (this._baseDate != null) {
      var chrono = context.getEffectiveChronology();
      baseValue = chrono.date(this._baseDate).get(this._field);
    }

    var parseLen = successPos - errorPos;

    if (parseLen === this._minWidth && value >= 0) {
      var range = EXCEED_POINTS[this._minWidth];
      var lastPart = baseValue % range;
      var basePart = baseValue - lastPart;

      if (baseValue > 0) {
        value = basePart + value;
      } else {
        value = basePart - value;
      }

      if (value < baseValue) {
        value += range;
      }
    }

    return context.setParsedField(this._field, value, errorPos, successPos);
  };

  _proto2.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }

    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, -1);
  };

  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
  };

  _proto2.isFixedWidth = function isFixedWidth(context) {
    if (context.isStrict() === false) {
      return false;
    }

    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
  };

  _proto2.toString = function toString() {
    return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
  };

  return ReducedPrinterParser;
}(NumberPrinterParser);

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];
var OffsetIdPrinterParser = function () {
  function OffsetIdPrinterParser(noOffsetText, pattern) {
    requireNonNull(noOffsetText, 'noOffsetText');
    requireNonNull(pattern, 'pattern');
    this.noOffsetText = noOffsetText;
    this.type = this._checkPattern(pattern);
  }

  var _proto = OffsetIdPrinterParser.prototype;

  _proto._checkPattern = function _checkPattern(pattern) {
    for (var i = 0; i < PATTERNS.length; i++) {
      if (PATTERNS[i] === pattern) {
        return i;
      }
    }

    throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
  };

  _proto.print = function print(context, buf) {
    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);

    if (offsetSecs == null) {
      return false;
    }

    var totalSecs = MathUtil.safeToInt(offsetSecs);

    if (totalSecs === 0) {
      buf.append(this.noOffsetText);
    } else {
      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
      var bufPos = buf.length();
      var output = absHours;
      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");

      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
        output += absMinutes;

        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
          output += absSeconds;
        }
      }

      if (output === 0) {
        buf.setLength(bufPos);
        buf.append(this.noOffsetText);
      }
    }

    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    var noOffsetLen = this.noOffsetText.length;

    if (noOffsetLen === 0) {
      if (position === length) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
      }
    } else {
      if (position === length) {
        return ~position;
      }

      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
      }
    }

    var sign = text[position];

    if (sign === '+' || sign === '-') {
      var negative = sign === '-' ? -1 : 1;
      var array = [0, 0, 0, 0];
      array[0] = position + 1;

      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
      }
    }

    if (noOffsetLen === 0) {
      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
    }

    return ~position;
  };

  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
    if ((this.type + 3) / 2 < arrayIndex) {
      return false;
    }

    var pos = array[0];

    if (this.type % 2 === 0 && arrayIndex > 1) {
      if (pos + 1 > parseText.length || parseText[pos] !== ':') {
        return required;
      }

      pos++;
    }

    if (pos + 2 > parseText.length) {
      return required;
    }

    var ch1 = parseText[pos++];
    var ch2 = parseText[pos++];

    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      return required;
    }

    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);

    if (value < 0 || value > 59) {
      return required;
    }

    array[arrayIndex] = value;
    array[0] = pos;
    return false;
  };

  _proto.toString = function toString() {
    var converted = this.noOffsetText.replace('\'', '\'\'');
    return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
  };

  return OffsetIdPrinterParser;
}();
OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');
OffsetIdPrinterParser.PATTERNS = PATTERNS;

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var PadPrinterParserDecorator = function () {
  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {
    this._printerParser = printerParser;
    this._padWidth = padWidth;
    this._padChar = padChar;
  }

  var _proto = PadPrinterParserDecorator.prototype;

  _proto.print = function print(context, buf) {
    var preLen = buf.length();

    if (this._printerParser.print(context, buf) === false) {
      return false;
    }

    var len = buf.length() - preLen;

    if (len > this._padWidth) {
      throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
    }

    for (var i = 0; i < this._padWidth - len; i++) {
      buf.insert(preLen, this._padChar);
    }

    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var strict = context.isStrict();
    var caseSensitive = context.isCaseSensitive();
    assert(!(position > text.length));
    assert(position >= 0);

    if (position === text.length) {
      return ~position;
    }

    var endPos = position + this._padWidth;

    if (endPos > text.length) {
      if (strict) {
        return ~position;
      }

      endPos = text.length;
    }

    var pos = position;

    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
      pos++;
    }

    text = text.substring(0, endPos);

    var resultPos = this._printerParser.parse(context, text, pos);

    if (resultPos !== endPos && strict) {
      return ~(position + pos);
    }

    return resultPos;
  };

  _proto.toString = function toString() {
    return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === ' ' ? ')' : ",'" + this._padChar + "')");
  };

  return PadPrinterParserDecorator;
}();

var SettingsParser = function (_Enum) {
  _inheritsLoose(SettingsParser, _Enum);

  function SettingsParser() {
    return _Enum.apply(this, arguments) || this;
  }

  var _proto = SettingsParser.prototype;

  _proto.print = function print() {
    return true;
  };

  _proto.parse = function parse(context, text, position) {
    switch (this) {
      case SettingsParser.SENSITIVE:
        context.setCaseSensitive(true);
        break;

      case SettingsParser.INSENSITIVE:
        context.setCaseSensitive(false);
        break;

      case SettingsParser.STRICT:
        context.setStrict(true);
        break;

      case SettingsParser.LENIENT:
        context.setStrict(false);
        break;
    }

    return position;
  };

  _proto.toString = function toString() {
    switch (this) {
      case SettingsParser.SENSITIVE:
        return 'ParseCaseSensitive(true)';

      case SettingsParser.INSENSITIVE:
        return 'ParseCaseSensitive(false)';

      case SettingsParser.STRICT:
        return 'ParseStrict(true)';

      case SettingsParser.LENIENT:
        return 'ParseStrict(false)';
    }
  };

  return SettingsParser;
}(Enum);
SettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');
SettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');
SettingsParser.STRICT = new SettingsParser('STRICT');
SettingsParser.LENIENT = new SettingsParser('LENIENT');

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringLiteralPrinterParser = function () {
  function StringLiteralPrinterParser(literal) {
    this._literal = literal;
  }

  var _proto = StringLiteralPrinterParser.prototype;

  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    assert(!(position > length || position < 0));

    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
      return ~position;
    }

    return position + this._literal.length;
  };

  _proto.toString = function toString() {
    var converted = this._literal.replace("'", "''");

    return "'" + converted + "'";
  };

  return StringLiteralPrinterParser;
}();

/*
 * @copyright (c) 2016, Philipp Thürwächter, Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneRulesProvider = function () {
  function ZoneRulesProvider() {}

  ZoneRulesProvider.getRules = function getRules(zoneId) {
    throw new DateTimeException("unsupported ZoneId:" + zoneId);
  };

  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {
    return [];
  };

  return ZoneRulesProvider;
}();

var ZoneRegion = function (_ZoneId) {
  _inheritsLoose(ZoneRegion, _ZoneId);

  ZoneRegion.ofId = function ofId(zoneId) {
    var rules = ZoneRulesProvider.getRules(zoneId);
    return new ZoneRegion(zoneId, rules);
  };

  function ZoneRegion(id, rules) {
    var _this;

    _this = _ZoneId.call(this) || this;
    _this._id = id;
    _this._rules = rules;
    return _this;
  }

  var _proto = ZoneRegion.prototype;

  _proto.id = function id() {
    return this._id;
  };

  _proto.rules = function rules() {
    return this._rules;
  };

  return ZoneRegion;
}(ZoneId);

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdPrinterParser = function () {
  function ZoneIdPrinterParser(query, description) {
    this.query = query;
    this.description = description;
  }

  var _proto = ZoneIdPrinterParser.prototype;

  _proto.print = function print(context, buf) {
    var zone = context.getValueQuery(this.query);

    if (zone == null) {
      return false;
    }

    buf.append(zone.id());
    return true;
  };

  _proto.parse = function parse(context, text, position) {
    var length = text.length;

    if (position > length) {
      return ~position;
    }

    if (position === length) {
      return ~position;
    }

    var nextChar = text.charAt(position);

    if (nextChar === '+' || nextChar === '-') {
      var newContext = context.copy();
      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);

      if (endPos < 0) {
        return endPos;
      }

      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
      var zone = ZoneOffset.ofTotalSeconds(offset);
      context.setParsedZone(zone);
      return endPos;
    } else if (length >= position + 2) {
      var nextNextChar = text.charAt(position + 1);

      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {
        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {
          return this._parsePrefixedOffset(context, text, position, position + 3);
        }

        return this._parsePrefixedOffset(context, text, position, position + 2);
      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {
        return this._parsePrefixedOffset(context, text, position, position + 3);
      }
    }

    if (text.substr(position, 6) === 'SYSTEM') {
      context.setParsedZone(ZoneId.systemDefault());
      return position + 6;
    }

    if (context.charEquals(nextChar, 'Z')) {
      context.setParsedZone(ZoneOffset.UTC);
      return position + 1;
    }

    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();

    if (zoneIdTree.size !== availableZoneIds.length) {
      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
    }

    var maxParseLength = length - position;
    var treeMap = zoneIdTree.treeMap;
    var parsedZoneId = null;
    var parseLength = 0;

    while (treeMap != null) {
      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
      treeMap = treeMap.get(parsedSubZoneId);

      if (treeMap != null && treeMap.isLeaf) {
        parsedZoneId = parsedSubZoneId;
        parseLength = treeMap.length;
      }
    }

    if (parsedZoneId != null) {
      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
      return position + parseLength;
    }

    return ~position;
  };

  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
    var prefix = text.substring(prefixPos, position).toUpperCase();
    var newContext = context.copy();

    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }

    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);

    if (endPos < 0) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }

    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
    context.setParsedZone(ZoneId.ofOffset(prefix, offset));
    return endPos;
  };

  _proto.toString = function toString() {
    return this.description;
  };

  return ZoneIdPrinterParser;
}();

var ZoneIdTree = function () {
  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {
    var sortedZoneIds = availableZoneIds.sort(function (a, b) {
      return a.length - b.length;
    });
    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);

    for (var i = 0; i < sortedZoneIds.length; i++) {
      treeMap.add(sortedZoneIds[i]);
    }

    return new ZoneIdTree(sortedZoneIds.length, treeMap);
  };

  function ZoneIdTree(size, treeMap) {
    this.size = size;
    this.treeMap = treeMap;
  }

  return ZoneIdTree;
}();

var ZoneIdTreeMap = function () {
  function ZoneIdTreeMap(length, isLeaf) {
    if (length === void 0) {
      length = 0;
    }

    if (isLeaf === void 0) {
      isLeaf = false;
    }

    this.length = length;
    this.isLeaf = isLeaf;
    this._treeMap = {};
  }

  var _proto2 = ZoneIdTreeMap.prototype;

  _proto2.add = function add(zoneId) {
    var idLength = zoneId.length;

    if (idLength === this.length) {
      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);
    } else if (idLength > this.length) {
      var subZoneId = zoneId.substr(0, this.length);
      var subTreeMap = this._treeMap[subZoneId];

      if (subTreeMap == null) {
        subTreeMap = new ZoneIdTreeMap(idLength, false);
        this._treeMap[subZoneId] = subTreeMap;
      }

      subTreeMap.add(zoneId);
    }
  };

  _proto2.get = function get(zoneId) {
    return this._treeMap[zoneId];
  };

  return ZoneIdTreeMap;
}();

var zoneIdTree = new ZoneIdTree([]);

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_WIDTH = 15;
var DateTimeFormatterBuilder = function () {
  function DateTimeFormatterBuilder() {
    this._active = this;
    this._parent = null;
    this._printerParsers = [];
    this._optional = false;
    this._padNextWidth = 0;
    this._padNextChar = null;
    this._valueParserIndex = -1;
  }

  DateTimeFormatterBuilder._of = function _of(parent, optional) {
    requireNonNull(parent, 'parent');
    requireNonNull(optional, 'optional');
    var dtFormatterBuilder = new DateTimeFormatterBuilder();
    dtFormatterBuilder._parent = parent;
    dtFormatterBuilder._optional = optional;
    return dtFormatterBuilder;
  };

  var _proto = DateTimeFormatterBuilder.prototype;

  _proto.parseCaseSensitive = function parseCaseSensitive() {
    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);

    return this;
  };

  _proto.parseCaseInsensitive = function parseCaseInsensitive() {
    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);

    return this;
  };

  _proto.parseStrict = function parseStrict() {
    this._appendInternalPrinterParser(SettingsParser.STRICT);

    return this;
  };

  _proto.parseLenient = function parseLenient() {
    this._appendInternalPrinterParser(SettingsParser.LENIENT);

    return this;
  };

  _proto.appendValue = function appendValue() {
    if (arguments.length === 1) {
      return this._appendValue1.apply(this, arguments);
    } else if (arguments.length === 2) {
      return this._appendValue2.apply(this, arguments);
    } else {
      return this._appendValue4.apply(this, arguments);
    }
  };

  _proto._appendValue1 = function _appendValue1(field) {
    requireNonNull(field);

    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));

    return this;
  };

  _proto._appendValue2 = function _appendValue2(field, width) {
    requireNonNull(field);

    if (width < 1 || width > MAX_WIDTH) {
      throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
    }

    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);

    this._appendValuePrinterParser(pp);

    return this;
  };

  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
    requireNonNull(field);
    requireNonNull(signStyle);

    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
      return this._appendValue2(field, maxWidth);
    }

    if (minWidth < 1 || minWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
    }

    if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
    }

    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }

    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);

    this._appendValuePrinterParser(pp);

    return this;
  };

  _proto.appendValueReduced = function appendValueReduced() {
    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
    } else {
      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
    }
  };

  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
    requireNonNull(field, 'field');
    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);

    this._appendValuePrinterParser(pp);

    return this;
  };

  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
    requireNonNull(field, 'field');
    requireNonNull(baseDate, 'baseDate');
    requireInstance(baseDate, ChronoLocalDate, 'baseDate');
    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);

    this._appendValuePrinterParser(pp);

    return this;
  };

  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
    assert(pp != null);

    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
      var activeValueParser = this._active._valueParserIndex;
      var basePP = this._active._printerParsers[activeValueParser];

      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
        basePP = basePP.withSubsequentWidth(pp.maxWidth());

        this._appendInternal(pp.withFixedWidth());

        this._active._valueParserIndex = activeValueParser;
      } else {
        basePP = basePP.withFixedWidth();
        this._active._valueParserIndex = this._appendInternal(pp);
      }

      this._active._printerParsers[activeValueParser] = basePP;
    } else {
      this._active._valueParserIndex = this._appendInternal(pp);
    }

    return this;
  };

  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));

    return this;
  };

  _proto.appendInstant = function appendInstant(fractionalDigits) {
    if (fractionalDigits === void 0) {
      fractionalDigits = -2;
    }

    if (fractionalDigits < -2 || fractionalDigits > 9) {
      throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
    }

    this._appendInternal(new InstantPrinterParser(fractionalDigits));

    return this;
  };

  _proto.appendOffsetId = function appendOffsetId() {
    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);

    return this;
  };

  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));

    return this;
  };

  _proto.appendZoneId = function appendZoneId() {
    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));

    return this;
  };

  _proto.appendPattern = function appendPattern(pattern) {
    requireNonNull(pattern, 'pattern');

    this._parsePattern(pattern);

    return this;
  };

  _proto.appendZoneText = function appendZoneText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };

  _proto.appendText = function appendText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };

  _proto.appendLocalizedOffset = function appendLocalizedOffset() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };

  _proto.appendWeekField = function appendWeekField() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };

  _proto._parsePattern = function _parsePattern(pattern) {
    var FIELD_MAP = {
      'G': ChronoField.ERA,
      'y': ChronoField.YEAR_OF_ERA,
      'u': ChronoField.YEAR,
      'Q': IsoFields.QUARTER_OF_YEAR,
      'q': IsoFields.QUARTER_OF_YEAR,
      'M': ChronoField.MONTH_OF_YEAR,
      'L': ChronoField.MONTH_OF_YEAR,
      'D': ChronoField.DAY_OF_YEAR,
      'd': ChronoField.DAY_OF_MONTH,
      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
      'E': ChronoField.DAY_OF_WEEK,
      'c': ChronoField.DAY_OF_WEEK,
      'e': ChronoField.DAY_OF_WEEK,
      'a': ChronoField.AMPM_OF_DAY,
      'H': ChronoField.HOUR_OF_DAY,
      'k': ChronoField.CLOCK_HOUR_OF_DAY,
      'K': ChronoField.HOUR_OF_AMPM,
      'h': ChronoField.CLOCK_HOUR_OF_AMPM,
      'm': ChronoField.MINUTE_OF_HOUR,
      's': ChronoField.SECOND_OF_MINUTE,
      'S': ChronoField.NANO_OF_SECOND,
      'A': ChronoField.MILLI_OF_DAY,
      'n': ChronoField.NANO_OF_SECOND,
      'N': ChronoField.NANO_OF_DAY
    };

    for (var pos = 0; pos < pattern.length; pos++) {
      var cur = pattern.charAt(pos);

      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
        var start = pos++;

        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {
        }

        var count = pos - start;

        if (cur === 'p') {
          var pad = 0;

          if (pos < pattern.length) {
            cur = pattern.charAt(pos);

            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
              pad = count;
              start = pos++;

              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++) {
              }

              count = pos - start;
            }
          }

          if (pad === 0) {
            throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
          }

          this.padNext(pad);
        }

        var field = FIELD_MAP[cur];

        if (field != null) {
          this._parseField(cur, count, field);
        } else if (cur === 'z') {
          if (count > 4) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          } else if (count === 4) {
            this.appendZoneText(TextStyle.FULL);
          } else {
            this.appendZoneText(TextStyle.SHORT);
          }
        } else if (cur === 'V') {
          if (count !== 2) {
            throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
          }

          this.appendZoneId();
        } else if (cur === 'Z') {
          if (count < 4) {
            this.appendOffset('+HHMM', '+0000');
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else if (count === 5) {
            this.appendOffset('+HH:MM:ss', 'Z');
          } else {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
        } else if (cur === 'O') {
          if (count === 1) {
            this.appendLocalizedOffset(TextStyle.SHORT);
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else {
            throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
          }
        } else if (cur === 'X') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }

          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');
        } else if (cur === 'x') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }

          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
        } else if (cur === 'W') {
          if (count > 1) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }

          this.appendWeekField('W', count);
        } else if (cur === 'w') {
          if (count > 2) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }

          this.appendWeekField('w', count);
        } else if (cur === 'Y') {
          this.appendWeekField('Y', count);
        } else {
          throw new IllegalArgumentException("Unknown pattern letter: " + cur);
        }

        pos--;
      } else if (cur === '\'') {
        var _start = pos++;

        for (; pos < pattern.length; pos++) {
          if (pattern.charAt(pos) === '\'') {
            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\'') {
              pos++;
            } else {
              break;
            }
          }
        }

        if (pos >= pattern.length) {
          throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
        }

        var str = pattern.substring(_start + 1, pos);

        if (str.length === 0) {
          this.appendLiteral('\'');
        } else {
          this.appendLiteral(str.replace('\'\'', '\''));
        }
      } else if (cur === '[') {
        this.optionalStart();
      } else if (cur === ']') {
        if (this._active._parent === null) {
          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');
        }

        this.optionalEnd();
      } else if (cur === '{' || cur === '}' || cur === '#') {
        throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
      } else {
        this.appendLiteral(cur);
      }
    }
  };

  _proto._parseField = function _parseField(cur, count, field) {
    switch (cur) {
      case 'u':
      case 'y':
        if (count === 2) {
          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
        } else if (count < 4) {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
        } else {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
        }

        break;

      case 'M':
      case 'Q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;

          case 2:
            this.appendValue(field, 2);
            break;

          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;

          case 4:
            this.appendText(field, TextStyle.FULL);
            break;

          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;

          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'L':
      case 'q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;

          case 2:
            this.appendValue(field, 2);
            break;

          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;

          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;

          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;

          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'e':
        switch (count) {
          case 1:
          case 2:
            this.appendWeekField('e', count);
            break;

          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;

          case 4:
            this.appendText(field, TextStyle.FULL);
            break;

          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;

          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'c':
        switch (count) {
          case 1:
            this.appendWeekField('c', count);
            break;

          case 2:
            throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);

          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;

          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;

          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;

          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'a':
        if (count === 1) {
          this.appendText(field, TextStyle.SHORT);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'E':
      case 'G':
        switch (count) {
          case 1:
          case 2:
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;

          case 4:
            this.appendText(field, TextStyle.FULL);
            break;

          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;

          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'S':
        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
        break;

      case 'F':
        if (count === 1) {
          this.appendValue(field);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'd':
      case 'h':
      case 'H':
      case 'k':
      case 'K':
      case 'm':
      case 's':
        if (count === 1) {
          this.appendValue(field);
        } else if (count === 2) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      case 'D':
        if (count === 1) {
          this.appendValue(field);
        } else if (count <= 3) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }

        break;

      default:
        if (count === 1) {
          this.appendValue(field);
        } else {
          this.appendValue(field, count);
        }

        break;
    }
  };

  _proto.padNext = function padNext() {
    if (arguments.length === 1) {
      return this._padNext1.apply(this, arguments);
    } else {
      return this._padNext2.apply(this, arguments);
    }
  };

  _proto._padNext1 = function _padNext1(padWidth) {
    return this._padNext2(padWidth, ' ');
  };

  _proto._padNext2 = function _padNext2(padWidth, padChar) {
    if (padWidth < 1) {
      throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
    }

    this._active._padNextWidth = padWidth;
    this._active._padNextChar = padChar;
    this._active._valueParserIndex = -1;
    return this;
  };

  _proto.optionalStart = function optionalStart() {
    this._active._valueParserIndex = -1;
    this._active = DateTimeFormatterBuilder._of(this._active, true);
    return this;
  };

  _proto.optionalEnd = function optionalEnd() {
    if (this._active._parent == null) {
      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');
    }

    if (this._active._printerParsers.length > 0) {
      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
      this._active = this._active._parent;

      this._appendInternal(cpp);
    } else {
      this._active = this._active._parent;
    }

    return this;
  };

  _proto._appendInternal = function _appendInternal(pp) {
    assert(pp != null);

    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }

      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }

    this._active._printerParsers.push(pp);

    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };

  _proto.appendLiteral = function appendLiteral(literal) {
    assert(literal != null);

    if (literal.length > 0) {
      if (literal.length === 1) {
        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
      } else {
        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
      }
    }

    return this;
  };

  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
    assert(pp != null);

    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }

      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }

    this._active._printerParsers.push(pp);

    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };

  _proto.append = function append(formatter) {
    requireNonNull(formatter, 'formatter');

    this._appendInternal(formatter._toPrinterParser(false));

    return this;
  };

  _proto.toFormatter = function toFormatter(resolverStyle) {
    if (resolverStyle === void 0) {
      resolverStyle = ResolverStyle.SMART;
    }

    while (this._active._parent != null) {
      this.optionalEnd();
    }

    var pp = new CompositePrinterParser(this._printerParsers, false);
    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
  };

  return DateTimeFormatterBuilder;
}();
var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;

var InstantPrinterParser = function () {
  function InstantPrinterParser(fractionalDigits) {
    this.fractionalDigits = fractionalDigits;
  }

  var _proto2 = InstantPrinterParser.prototype;

  _proto2.print = function print(context, buf) {
    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
    var inNanos = 0;

    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
    }

    if (inSecs == null) {
      return false;
    }

    var inSec = inSecs;
    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);

    if (inSec >= -SECONDS_0000_TO_1970) {
      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);

      if (hi > 0) {
        buf.append('+').append(hi);
      }

      buf.append(ldt.toString());

      if (ldt.second() === 0) {
        buf.append(':00');
      }
    } else {
      var _zeroSecs = inSec + SECONDS_0000_TO_1970;

      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);

      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);

      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);

      var pos = buf.length();
      buf.append(_ldt.toString());

      if (_ldt.second() === 0) {
        buf.append(':00');
      }

      if (_hi < 0) {
        if (_ldt.year() === -10000) {
          buf.replace(pos, pos + 2, "" + (_hi - 1));
        } else if (_lo === 0) {
          buf.insert(pos, _hi);
        } else {
          buf.insert(pos + 1, Math.abs(_hi));
        }
      }
    }

    if (this.fractionalDigits === -2) {
      if (inNano !== 0) {
        buf.append('.');

        if (MathUtil.intMod(inNano, 1000000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));
        } else if (MathUtil.intMod(inNano, 1000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));
        } else {
          buf.append(("" + (inNano + 1000000000)).substring(1));
        }
      }
    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
      buf.append('.');
      var div = 100000000;

      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
        var digit = MathUtil.intDiv(inNano, div);
        buf.append(digit);
        inNano = inNano - digit * div;
        div = MathUtil.intDiv(div, 10);
      }
    }

    buf.append('Z');
    return true;
  };

  _proto2.parse = function parse(context, text, position) {
    var newContext = context.copy();
    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;

    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);

    var pos = parser.parse(newContext, text, position);

    if (pos < 0) {
      return pos;
    }

    var yearParsed = newContext.getParsed(ChronoField.YEAR);
    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
    var sec = secVal != null ? secVal : 0;
    var nano = nanoVal != null ? nanoVal : 0;
    var year = MathUtil.intMod(yearParsed, 10000);
    var days = 0;

    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
      hour = 0;
      days = 1;
    } else if (hour === 23 && min === 59 && sec === 60) {
      context.setParsedLeapSecond();
      sec = 59;
    }

    var instantSecs;

    try {
      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);
    } catch (ex) {
      return ~position;
    }

    var successPos = pos;
    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
  };

  _proto2.toString = function toString() {
    return 'Instant()';
  };

  return InstantPrinterParser;
}();

function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var StringBuilder = function () {
  function StringBuilder() {
    this._str = '';
  }

  var _proto = StringBuilder.prototype;

  _proto.append = function append(str) {
    this._str += str;
    return this;
  };

  _proto.appendChar = function appendChar(str) {
    this._str += str[0];
    return this;
  };

  _proto.insert = function insert(offset, str) {
    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
    return this;
  };

  _proto.replace = function replace(start, end, str) {
    this._str = this._str.slice(0, start) + str + this._str.slice(end);
    return this;
  };

  _proto.length = function length() {
    return this._str.length;
  };

  _proto.setLength = function setLength(length) {
    this._str = this._str.slice(0, length);
    return this;
  };

  _proto.toString = function toString() {
    return this._str;
  };

  return StringBuilder;
}();

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var DateTimeFormatter = function () {
  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {
    return DateTimeFormatter.PARSED_EXCESS_DAYS;
  };

  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {
    return DateTimeFormatter.PARSED_LEAP_SECOND;
  };

  DateTimeFormatter.ofPattern = function ofPattern(pattern) {
    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
  };

  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
    if (chrono === void 0) {
      chrono = IsoChronology.INSTANCE;
    }

    assert(printerParser != null);
    assert(decimalStyle != null);
    assert(resolverStyle != null);
    this._printerParser = printerParser;
    this._locale = locale;
    this._decimalStyle = decimalStyle;
    this._resolverStyle = resolverStyle;
    this._resolverFields = resolverFields;
    this._chrono = chrono;
    this._zone = zone;
  }

  var _proto = DateTimeFormatter.prototype;

  _proto.locale = function locale() {
    return this._locale;
  };

  _proto.decimalStyle = function decimalStyle() {
    return this._decimalStyle;
  };

  _proto.chronology = function chronology() {
    return this._chrono;
  };

  _proto.withChronology = function withChronology(chrono) {
    if (this._chrono != null && this._chrono.equals(chrono)) {
      return this;
    }

    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
  };

  _proto.withLocale = function withLocale() {
    return this;
  };

  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
    requireNonNull(resolverStyle, 'resolverStyle');

    if (resolverStyle.equals(this._resolverStyle)) {
      return this;
    }

    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
  };

  _proto.format = function format(temporal) {
    var buf = new StringBuilder(32);

    this._formatTo(temporal, buf);

    return buf.toString();
  };

  _proto._formatTo = function _formatTo(temporal, appendable) {
    requireNonNull(temporal, 'temporal');
    requireNonNull(appendable, 'appendable');
    var context = new DateTimePrintContext(temporal, this);

    this._printerParser.print(context, appendable);
  };

  _proto.parse = function parse(text, type) {
    if (arguments.length === 1) {
      return this.parse1(text);
    } else {
      return this.parse2(text, type);
    }
  };

  _proto.parse1 = function parse1(text) {
    requireNonNull(text, 'text');

    try {
      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };

  _proto.parse2 = function parse2(text, type) {
    requireNonNull(text, 'text');
    requireNonNull(type, 'type');

    try {
      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);

      return builder.build(type);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };

  _proto._createError = function _createError(text, ex) {
    var abbr = '';

    if (text.length > 64) {
      abbr = text.substring(0, 64) + "...";
    } else {
      abbr = text;
    }

    return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
  };

  _proto._parseToBuilder = function _parseToBuilder(text, position) {
    var pos = position != null ? position : new ParsePosition(0);

    var result = this._parseUnresolved0(text, pos);

    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
      var abbr = '';

      if (text.length > 64) {
        abbr = text.substr(0, 64).toString() + "...";
      } else {
        abbr = text;
      }

      if (pos.getErrorIndex() >= 0) {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
      } else {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
      }
    }

    return result.toBuilder();
  };

  _proto.parseUnresolved = function parseUnresolved(text, position) {
    return this._parseUnresolved0(text, position);
  };

  _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
    assert(text != null, 'text', NullPointerException);
    assert(position != null, 'position', NullPointerException);
    var context = new DateTimeParseContext(this);
    var pos = position.getIndex();
    pos = this._printerParser.parse(context, text, pos);

    if (pos < 0) {
      position.setErrorIndex(~pos);
      return null;
    }

    position.setIndex(pos);
    return context.toParsed();
  };

  _proto._toPrinterParser = function _toPrinterParser(optional) {
    return this._printerParser.withOptional(optional);
  };

  _proto.toString = function toString() {
    var pattern = this._printerParser.toString();

    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);
  };

  return DateTimeFormatter;
}();
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-W').appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral('-').appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}

var MonthDay = function (_TemporalAccessor) {
  _inheritsLoose(MonthDay, _TemporalAccessor);

  MonthDay.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return MonthDay.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return MonthDay.nowZoneId(zoneIdOrClock);
    } else {
      return MonthDay.nowClock(zoneIdOrClock);
    }
  };

  MonthDay.now0 = function now0() {
    return this.nowClock(Clock.systemDefaultZone());
  };

  MonthDay.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    return this.nowClock(Clock.system(zone));
  };

  MonthDay.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    var now = LocalDate.now(clock);
    return MonthDay.of(now.month(), now.dayOfMonth());
  };

  MonthDay.of = function of(monthOrNumber, number) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return MonthDay.ofMonthNumber(monthOrNumber, number);
    } else {
      return MonthDay.ofNumberNumber(monthOrNumber, number);
    }
  };

  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);

    if (dayOfMonth > month.maxLength()) {
      throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
    }

    return new MonthDay(month.value(), dayOfMonth);
  };

  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');
    return MonthDay.of(Month.of(month), dayOfMonth);
  };

  MonthDay.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');

    if (temporal instanceof MonthDay) {
      return temporal;
    }

    try {
      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  MonthDay.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return MonthDay.parseString(text);
    } else {
      return MonthDay.parseStringFormatter(text, formatter);
    }
  };

  MonthDay.parseString = function parseString(text) {
    return MonthDay.parseStringFormatter(text, PARSER$2);
  };

  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, MonthDay.FROM);
  };

  function MonthDay(month, dayOfMonth) {
    var _this;

    _this = _TemporalAccessor.call(this) || this;
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    return _this;
  }

  var _proto = MonthDay.prototype;

  _proto.monthValue = function monthValue() {
    return this._month;
  };

  _proto.month = function month() {
    return Month.of(this._month);
  };

  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };

  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
    }

    return field != null && field.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return field.range();
    } else if (field === ChronoField.DAY_OF_MONTH) {
      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
    }

    return _TemporalAccessor.prototype.range.call(this, field);
  };

  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.DAY_OF_MONTH:
          return this._day;

        case ChronoField.MONTH_OF_YEAR:
          return this._month;
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.isValidYear = function isValidYear(year) {
    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
  };

  _proto.withMonth = function withMonth(month) {
    return this.with(Month.of(month));
  };

  _proto.with = function _with(month) {
    requireNonNull(month, 'month');

    if (month.value() === this._month) {
      return this;
    }

    var day = Math.min(this._day, month.maxLength());
    return new MonthDay(month.value(), day);
  };

  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (dayOfMonth === this._day) {
      return this;
    }

    return MonthDay.of(this._month, dayOfMonth);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');

    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    }

    return _TemporalAccessor.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
  };

  _proto.atYear = function atYear(year) {
    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    var cmp = this._month - other.monthValue();

    if (cmp === 0) {
      cmp = this._day - other.dayOfMonth();
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) > 0;
  };

  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) < 0;
  };

  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }

    if (obj instanceof MonthDay) {
      var other = obj;
      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
    }

    return false;
  };

  _proto.toString = function toString() {
    return "--" + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };

  return MonthDay;
}(TemporalAccessor);
var PARSER$2;
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {
    return MonthDay.from(temporal);
  });
}

var YearMonth = function (_Temporal) {
  _inheritsLoose(YearMonth, _Temporal);

  YearMonth.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return YearMonth.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return YearMonth.nowZoneId(zoneIdOrClock);
    } else {
      return YearMonth.nowClock(zoneIdOrClock);
    }
  };

  YearMonth.now0 = function now0() {
    return YearMonth.nowClock(Clock.systemDefaultZone());
  };

  YearMonth.nowZoneId = function nowZoneId(zone) {
    return YearMonth.nowClock(Clock.system(zone));
  };

  YearMonth.nowClock = function nowClock(clock) {
    var now = LocalDate.now(clock);
    return YearMonth.of(now.year(), now.month());
  };

  YearMonth.of = function of(year, monthOrNumber) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return YearMonth.ofNumberMonth(year, monthOrNumber);
    } else {
      return YearMonth.ofNumberNumber(year, monthOrNumber);
    }
  };

  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.ofNumberNumber(year, month.value());
  };

  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(year, month);
  };

  YearMonth.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');

    if (temporal instanceof YearMonth) {
      return temporal;
    }

    try {
      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  YearMonth.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return YearMonth.parseString(text);
    } else {
      return YearMonth.parseStringFormatter(text, formatter);
    }
  };

  YearMonth.parseString = function parseString(text) {
    return YearMonth.parseStringFormatter(text, PARSER$1);
  };

  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, YearMonth.FROM);
  };

  function YearMonth(year, month) {
    var _this;

    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    return _this;
  }

  var _proto = YearMonth.prototype;

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };

  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }

    return field != null && field.isSupportedBy(this);
  };

  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }

    return unit != null && unit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field === ChronoField.YEAR_OF_ERA) {
      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
    }

    return _Temporal.prototype.range.call(this, field);
  };

  _proto.get = function get(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');

    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.MONTH_OF_YEAR:
          return this._month;

        case ChronoField.PROLEPTIC_MONTH:
          return this._getProlepticMonth();

        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;

        case ChronoField.YEAR:
          return this._year;

        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto._getProlepticMonth = function _getProlepticMonth() {
    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
  };

  _proto.year = function year() {
    return this._year;
  };

  _proto.monthValue = function monthValue() {
    return this._month;
  };

  _proto.month = function month() {
    return Month.of(this._month);
  };

  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };

  _proto.isValidDay = function isValidDay(dayOfMonth) {
    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
  };

  _proto.lengthOfMonth = function lengthOfMonth() {
    return this.month().length(this.isLeapYear());
  };

  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };

  _proto.with = function _with(adjusterOrField, value) {
    if (arguments.length === 1) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, value);
    }
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');

    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);

      switch (f) {
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);

        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));

        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year < 1 ? 1 - newValue : newValue);

        case ChronoField.YEAR:
          return this.withYear(newValue);

        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.adjustInto(this, newValue);
  };

  _proto.withYear = function withYear(year) {
    ChronoField.YEAR.checkValidValue(year);
    return new YearMonth(year, this._month);
  };

  _proto.withMonth = function withMonth(month) {
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(this._year, month);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);

        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);

        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));

        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));

        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));

        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }

    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return this.withYear(newYear);
  };

  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }

    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return new YearMonth(newYear, newMonth);
  };

  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };

  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');

    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, Temporal, 'temporal');
    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
  };

  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    requireInstance(endExclusive, Temporal, 'endExclusive');
    requireInstance(unit, TemporalUnit, 'unit');
    var end = YearMonth.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();

      switch (unit) {
        case ChronoUnit.MONTHS:
          return monthsUntil;

        case ChronoUnit.YEARS:
          return monthsUntil / 12;

        case ChronoUnit.DECADES:
          return monthsUntil / 120;

        case ChronoUnit.CENTURIES:
          return monthsUntil / 1200;

        case ChronoUnit.MILLENNIA:
          return monthsUntil / 12000;

        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  _proto.atDay = function atDay(dayOfMonth) {
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };

  _proto.atEndOfMonth = function atEndOfMonth() {
    return LocalDate.of(this._year, this._month, this.lengthOfMonth());
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, YearMonth, 'other');
    var cmp = this._year - other.year();

    if (cmp === 0) {
      cmp = this._month - other.monthValue();
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };

  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };

  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }

    if (obj instanceof YearMonth) {
      var other = obj;
      return this.year() === other.year() && this.monthValue() === other.monthValue();
    }

    return false;
  };

  _proto.toString = function toString() {
    return PARSER$1.format(this);
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };

  return YearMonth;
}(Temporal);
var PARSER$1;
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {
    return YearMonth.from(temporal);
  });
}

var Year = function (_Temporal) {
  _inheritsLoose(Year, _Temporal);

  function Year(value) {
    var _this;

    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(value);
    return _this;
  }

  var _proto = Year.prototype;

  _proto.value = function value() {
    return this._year;
  };

  Year.now = function now(zoneIdOrClock) {
    if (zoneIdOrClock === void 0) {
      zoneIdOrClock = undefined;
    }

    if (zoneIdOrClock === undefined) {
      return Year.now0();
    } else if (zoneIdOrClock instanceof ZoneId) {
      return Year.nowZoneId(zoneIdOrClock);
    } else {
      return Year.nowClock(zoneIdOrClock);
    }
  };

  Year.now0 = function now0() {
    return Year.nowClock(Clock.systemDefaultZone());
  };

  Year.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    return Year.nowClock(Clock.system(zone));
  };

  Year.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    requireInstance(clock, Clock, 'clock');
    var now = LocalDate.now(clock);
    return Year.of(now.year());
  };

  Year.of = function of(isoYear) {
    requireNonNull(isoYear, 'isoYear');
    ChronoField.YEAR.checkValidValue(isoYear);
    return new Year(isoYear);
  };

  Year.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');

    if (temporal instanceof Year) {
      return temporal;
    }

    try {
      return Year.of(temporal.get(ChronoField.YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  Year.parse = function parse(text, formatter) {
    if (arguments.length <= 1) {
      return Year.parseText(text);
    } else {
      return Year.parseTextFormatter(text, formatter);
    }
  };

  Year.parseText = function parseText(text) {
    requireNonNull(text, 'text');
    return Year.parse(text, PARSER);
  };

  Year.parseTextFormatter = function parseTextFormatter(text, formatter) {
    if (formatter === void 0) {
      formatter = PARSER;
    }

    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, Year.FROM);
  };

  Year.isLeap = function isLeap(year) {
    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
  };

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };

  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }

    return field != null && field.isSupportedBy(this);
  };

  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }

    return unit != null && unit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (this.isSupported(field)) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return _Temporal.prototype.range.call(this, field);
  };

  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;

        case ChronoField.YEAR:
          return this._year;

        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.isLeap = function isLeap() {
    return Year.isLeap(this._year);
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');

    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);

      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return Year.of(this._year < 1 ? 1 - newValue : newValue);

        case ChronoField.YEAR:
          return Year.of(newValue);

        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.adjustInto(this, newValue);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);

        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));

        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));

        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));

        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }

    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
  };

  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.YEAR, this._year);
  };

  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
    return monthDay != null && monthDay.isValidYear(this._year);
  };

  _proto.length = function length() {
    return this.isLeap() ? 366 : 365;
  };

  _proto.atDay = function atDay(dayOfYear) {
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };

  _proto.atMonth = function atMonth(monthOrNumber) {
    if (arguments.length === 1 && monthOrNumber instanceof Month) {
      return this.atMonthMonth(monthOrNumber);
    } else {
      return this.atMonthNumber(monthOrNumber);
    }
  };

  _proto.atMonthMonth = function atMonthMonth(month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.of(this._year, month);
  };

  _proto.atMonthNumber = function atMonthNumber(month) {
    requireNonNull(month, 'month');
    return YearMonth.of(this._year, month);
  };

  _proto.atMonthDay = function atMonthDay(monthDay) {
    requireNonNull(monthDay, 'monthDay');
    requireInstance(monthDay, MonthDay, 'monthDay');
    return monthDay.atYear(this._year);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query()');
    requireInstance(_query, TemporalQuery, 'query()');

    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.YEARS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year - other._year;
  };

  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year > other._year;
  };

  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year < other._year;
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof Year) {
      return this.value() === other.value();
    }

    return false;
  };

  _proto.toString = function toString() {
    return "" + this._year;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.until = function until(endExclusive, unit) {
    var end = Year.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      var yearsUntil = end.value() - this.value();

      switch (unit) {
        case ChronoUnit.YEARS:
          return yearsUntil;

        case ChronoUnit.DECADES:
          return MathUtil.intDiv(yearsUntil, 10);

        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(yearsUntil, 100);

        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(yearsUntil, 1000);

        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  return Year;
}(Temporal);
var PARSER;
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {
    return Year.from(temporal);
  });
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalAdjuster = function () {
  function TemporalAdjuster() {}

  var _proto = TemporalAdjuster.prototype;

  _proto.adjustInto = function adjustInto(temporal) {
    abstractMethodFail('adjustInto');
  };

  return TemporalAdjuster;
}();

var TemporalAdjusters = function () {
  function TemporalAdjusters() {}

  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {
    return Impl.FIRST_DAY_OF_MONTH;
  };

  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {
    return Impl.LAST_DAY_OF_MONTH;
  };

  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {
    return Impl.FIRST_DAY_OF_NEXT_MONTH;
  };

  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {
    return Impl.FIRST_DAY_OF_YEAR;
  };

  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {
    return Impl.LAST_DAY_OF_YEAR;
  };

  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {
    return Impl.FIRST_DAY_OF_NEXT_YEAR;
  };

  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(1, dayOfWeek);
  };

  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(-1, dayOfWeek);
  };

  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(ordinal, dayOfWeek);
  };

  TemporalAdjusters.next = function next(dayOfWeek) {
    return new RelativeDayOfWeek(2, dayOfWeek);
  };

  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(0, dayOfWeek);
  };

  TemporalAdjusters.previous = function previous(dayOfWeek) {
    return new RelativeDayOfWeek(3, dayOfWeek);
  };

  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(1, dayOfWeek);
  };

  return TemporalAdjusters;
}();

var Impl = function (_TemporalAdjuster) {
  _inheritsLoose(Impl, _TemporalAdjuster);

  function Impl(ordinal) {
    var _this;

    _this = _TemporalAdjuster.call(this) || this;
    _this._ordinal = ordinal;
    return _this;
  }

  var _proto = Impl.prototype;

  _proto.adjustInto = function adjustInto(temporal) {
    switch (this._ordinal) {
      case 0:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1);

      case 1:
        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());

      case 2:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);

      case 3:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1);

      case 4:
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());

      case 5:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
    }

    throw new IllegalStateException('Unreachable');
  };

  return Impl;
}(TemporalAdjuster);

Impl.FIRST_DAY_OF_MONTH = new Impl(0);
Impl.LAST_DAY_OF_MONTH = new Impl(1);
Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
Impl.FIRST_DAY_OF_YEAR = new Impl(3);
Impl.LAST_DAY_OF_YEAR = new Impl(4);
Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);

var DayOfWeekInMonth = function (_TemporalAdjuster2) {
  _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);

  function DayOfWeekInMonth(ordinal, dow) {
    var _this2;

    _this2 = _TemporalAdjuster2.call(this) || this;
    _this2._ordinal = ordinal;
    _this2._dowValue = dow.value();
    return _this2;
  }

  var _proto2 = DayOfWeekInMonth.prototype;

  _proto2.adjustInto = function adjustInto(temporal) {
    if (this._ordinal >= 0) {
      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
      var curDow = temp.get(ChronoField.DAY_OF_WEEK);
      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
      dowDiff += (this._ordinal - 1) * 7;
      return temp.plus(dowDiff, ChronoUnit.DAYS);
    } else {
      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());

      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);

      var daysDiff = this._dowValue - _curDow;
      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
      daysDiff -= (-this._ordinal - 1) * 7;
      return _temp.plus(daysDiff, ChronoUnit.DAYS);
    }
  };

  return DayOfWeekInMonth;
}(TemporalAdjuster);

var RelativeDayOfWeek = function (_TemporalAdjuster3) {
  _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);

  function RelativeDayOfWeek(relative, dayOfWeek) {
    var _this3;

    _this3 = _TemporalAdjuster3.call(this) || this;
    requireNonNull(dayOfWeek, 'dayOfWeek');
    _this3._relative = relative;
    _this3._dowValue = dayOfWeek.value();
    return _this3;
  }

  var _proto3 = RelativeDayOfWeek.prototype;

  _proto3.adjustInto = function adjustInto(temporal) {
    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);

    if (this._relative < 2 && calDow === this._dowValue) {
      return temporal;
    }

    if ((this._relative & 1) === 0) {
      var daysDiff = calDow - this._dowValue;
      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
    } else {
      var _daysDiff = this._dowValue - calDow;

      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
    }
  };

  return RelativeDayOfWeek;
}(TemporalAdjuster);

var IsoChronology = function (_Enum) {
  _inheritsLoose(IsoChronology, _Enum);

  function IsoChronology() {
    return _Enum.apply(this, arguments) || this;
  }

  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {
    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
  };

  var _proto = IsoChronology.prototype;

  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
    requireNonNull(fieldValues, 'fieldValues');
    requireNonNull(field, 'field');
    var current = fieldValues.get(field);

    if (current != null && current !== value) {
      throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
    }

    fieldValues.put(field, value);
  };

  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
    }

    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);

    if (prolepticMonth != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
      }

      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);

      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
    }

    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);

    if (yoeLong != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
      }

      var era = fieldValues.remove(ChronoField.ERA);

      if (era == null) {
        var year = fieldValues.get(ChronoField.YEAR);

        if (resolverStyle === ResolverStyle.STRICT) {
          if (year != null) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
          } else {
            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
          }
        } else {
          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
        }
      } else if (era === 1) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
      } else if (era === 0) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
      } else {
        throw new DateTimeException("Invalid value for era: " + era);
      }
    } else if (fieldValues.containsKey(ChronoField.ERA)) {
      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
    }

    if (fieldValues.containsKey(ChronoField.YEAR)) {
      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);

          if (resolverStyle === ResolverStyle.LENIENT) {
            var months = moy - 1;
            var days = dom - 1;
            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
          } else if (resolverStyle === ResolverStyle.SMART) {
            ChronoField.DAY_OF_MONTH.checkValidValue(dom);

            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
              dom = Math.min(dom, 30);
            } else if (moy === 2) {
              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
            }

            return LocalDate.of(y, moy, dom);
          } else {
            return LocalDate.of(y, moy, dom);
          }
        }
      }

      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));

        if (resolverStyle === ResolverStyle.LENIENT) {
          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);

          return LocalDate.ofYearDay(_y, 1).plusDays(_days);
        }

        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
        return LocalDate.ofYearDay(_y, doy);
      }

      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));

          if (resolverStyle === ResolverStyle.LENIENT) {
            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);

            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);

            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
          }

          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));

          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
            throw new DateTimeException('Strict mode rejected date parsed to a different year');
          }

          return date;
        }

        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));

          if (resolverStyle === ResolverStyle.LENIENT) {
            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);

            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);

            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
          }

          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));

          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));

          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));

          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
            throw new DateTimeException('Strict mode rejected date parsed to a different month');
          }

          return _date;
        }
      }
    }

    return null;
  };

  _proto.date = function date(temporal) {
    return LocalDate.from(temporal);
  };

  return IsoChronology;
}(Enum);
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');
}

var OffsetTime = function (_Temporal) {
  _inheritsLoose(OffsetTime, _Temporal);

  OffsetTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');

    if (temporal instanceof OffsetTime) {
      return temporal;
    } else if (temporal instanceof OffsetDateTime) {
      return temporal.toOffsetTime();
    }

    try {
      var time = LocalTime.from(temporal);
      var offset = ZoneOffset.from(temporal);
      return new OffsetTime(time, offset);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  OffsetTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return OffsetTime._now(clockOrZone);
    } else {
      return OffsetTime._now(Clock.system(clockOrZone));
    }
  };

  OffsetTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    var now = clock.instant();
    return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));
  };

  OffsetTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetTime.ofTimeAndOffset.apply(this, arguments);
    } else {
      return OffsetTime.ofNumbers.apply(this, arguments);
    }
  };

  OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new OffsetTime(time, offset);
  };

  OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
    return new OffsetTime(time, offset);
  };

  OffsetTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;

    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }

    var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
    return new OffsetTime(time, offset);
  };

  OffsetTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_TIME;
    }

    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetTime.FROM);
  };

  function OffsetTime(time, offset) {
    var _this;

    _this = _Temporal.call(this) || this;
    requireNonNull(time, 'time');
    requireInstance(time, LocalTime, 'time');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._time = time;
    _this._offset = offset;
    return _this;
  }

  var _proto = OffsetTime.prototype;

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };

  _proto.atDate = function atDate(date) {
    return OffsetDateTime.of(date, this._time, this._offset);
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this, OffsetTime.FROM);
  };

  _proto.get = function get(field) {
    return _Temporal.prototype.get.call(this, field);
  };

  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._offset.totalSeconds();
      }

      return this._time.getLong(field);
    }

    return field.getFrom(this);
  };

  _proto.hour = function hour() {
    return this._time.hour();
  };

  _proto.minute = function minute() {
    return this._time.minute();
  };

  _proto.second = function second() {
    return this._time.second();
  };

  _proto.nano = function nano() {
    return this._time.nano();
  };

  _proto.offset = function offset() {
    return this._offset;
  };

  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() > other._toEpochNano();
  };

  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() < other._toEpochNano();
  };

  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() === other._toEpochNano();
  };

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.minusHours = function minusHours(hours) {
    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
  };

  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
  };

  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
  };

  _proto.minusNanos = function minusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
  };

  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };

  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount);
    return amount.addTo(this);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusHours = function plusHours(hours) {
    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
  };

  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
  };

  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
  };

  _proto.plusNanos = function plusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localTime()) {
      return this._time;
    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }

      return this._time.range(field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
  };

  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = OffsetTime.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      var nanosUntil = end._toEpochNano() - this._toEpochNano();

      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;

        case ChronoUnit.MICROS:
          return Math.floor(nanosUntil / 1000);

        case ChronoUnit.MILLIS:
          return Math.floor(nanosUntil / 1000000);

        case ChronoUnit.SECONDS:
          return Math.floor(nanosUntil / LocalTime.NANOS_PER_SECOND);

        case ChronoUnit.MINUTES:
          return Math.floor(nanosUntil / LocalTime.NANOS_PER_MINUTE);

        case ChronoUnit.HOURS:
          return Math.floor(nanosUntil / LocalTime.NANOS_PER_HOUR);

        case ChronoUnit.HALF_DAYS:
          return Math.floor(nanosUntil / (12 * LocalTime.NANOS_PER_HOUR));
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  _proto.withHour = function withHour(hour) {
    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
  };

  _proto.withMinute = function withMinute(minute) {
    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
  };

  _proto.withSecond = function withSecond(second) {
    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
  };

  _proto.withNano = function withNano(nano) {
    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
  };

  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');

    if (offset.equals(this._offset)) {
      return this;
    }

    var difference = offset.totalSeconds() - this._offset.totalSeconds();

    var adjusted = this._time.plusSeconds(difference);

    return new OffsetTime(adjusted, offset);
  };

  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);
  };

  _proto._toEpochNano = function _toEpochNano() {
    var nod = this._time.toNanoOfDay();

    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
    return nod - offsetNanos;
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');

    if (adjuster instanceof LocalTime) {
      return this._withLocalTimeOffset(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withLocalTimeOffset(this._time, adjuster);
    } else if (adjuster instanceof OffsetTime) {
      return adjuster;
    }

    return adjuster.adjustInto(this);
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
      }

      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
    }

    return field.adjustInto(this, newValue);
  };

  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
    if (this._time === time && this._offset.equals(offset)) {
      return this;
    }

    return new OffsetTime(time, offset);
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetTime, 'other');

    if (this._offset.equals(other._offset)) {
      return this._time.compareTo(other._time);
    }

    var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());

    if (compare === 0) {
      return this._time.compareTo(other._time);
    }

    return compare;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof OffsetTime) {
      return this._time.equals(other._time) && this._offset.equals(other._offset);
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._time.hashCode() ^ this._offset.hashCode();
  };

  _proto.toString = function toString() {
    return this._time.toString() + this._offset.toString();
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return OffsetTime;
}(Temporal);
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', function (temporal) {
    return OffsetTime.from(temporal);
  });
}

var ChronoZonedDateTime = function (_Temporal) {
  _inheritsLoose(ChronoZonedDateTime, _Temporal);

  function ChronoZonedDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }

  var _proto = ChronoZonedDateTime.prototype;

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone();
    } else if (_query === TemporalQueries.chronology()) {
      return this.toLocalDate().chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };

  _proto.toInstant = function toInstant() {
    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
  };

  _proto.toEpochSecond = function toEpochSecond() {
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= this.offset().totalSeconds();
    return secs;
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());

    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();

      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());

        if (cmp === 0) {
          cmp = strcmp(this.zone().id(), other.zone().id());
        }
      }
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };

  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };

  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof ChronoZonedDateTime) {
      return this.compareTo(other) === 0;
    }

    return false;
  };

  return ChronoZonedDateTime;
}(Temporal);

function strcmp(a, b) {
  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}

var ZonedDateTime = function (_ChronoZonedDateTime) {
  _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);

  ZonedDateTime.now = function now(clockOrZone) {
    var clock;

    if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
    }

    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());
  };

  ZonedDateTime.of = function of() {
    if (arguments.length <= 2) {
      return ZonedDateTime.of2.apply(this, arguments);
    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
      return ZonedDateTime.of3.apply(this, arguments);
    } else {
      return ZonedDateTime.of8.apply(this, arguments);
    }
  };

  ZonedDateTime.of3 = function of3(date, time, zone) {
    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);
  };

  ZonedDateTime.of2 = function of2(localDateTime, zone) {
    return ZonedDateTime.ofLocal(localDateTime, zone, null);
  };

  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return ZonedDateTime.ofLocal(dt, zone, null);
  };

  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(zone, 'zone');

    if (zone instanceof ZoneOffset) {
      return new ZonedDateTime(localDateTime, zone, zone);
    }

    var offset = null;
    var rules = zone.rules();
    var validOffsets = rules.validOffsets(localDateTime);

    if (validOffsets.length === 1) {
      offset = validOffsets[0];
    } else if (validOffsets.length === 0) {
      var trans = rules.transition(localDateTime);
      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
      offset = trans.offsetAfter();
    } else {
      if (preferredOffset != null && validOffsets.some(function (validOffset) {
        return validOffset.equals(preferredOffset);
      })) {
        offset = preferredOffset;
      } else {
        offset = requireNonNull(validOffsets[0], 'offset');
      }
    }

    return new ZonedDateTime(localDateTime, offset, zone);
  };

  ZonedDateTime.ofInstant = function ofInstant() {
    if (arguments.length === 2) {
      return ZonedDateTime.ofInstant2.apply(this, arguments);
    } else {
      return ZonedDateTime.ofInstant3.apply(this, arguments);
    }
  };

  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);
  };

  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
  };

  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {
    var rules = zone.rules();
    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
    return new ZonedDateTime(ldt, offset, zone);
  };

  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();

    if (rules.isValidOffset(localDateTime, offset) === false) {
      var trans = rules.transition(localDateTime);

      if (trans != null && trans.isGap()) {
        throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
      }

      throw new DateTimeException("ZoneOffset \"" + offset + "\" is not valid for LocalDateTime \"" + localDateTime + "\" in zone \"" + zone + "\"");
    }

    return new ZonedDateTime(localDateTime, offset, zone);
  };

  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');

    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
      throw new IllegalArgumentException('ZoneId must match ZoneOffset');
    }

    return new ZonedDateTime(localDateTime, offset, zone);
  };

  ZonedDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');

    if (temporal instanceof ZonedDateTime) {
      return temporal;
    }

    var zone = ZoneId.from(temporal);

    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
      var zdt = ZonedDateTime._from(temporal, zone);

      if (zdt != null) return zdt;
    }

    var ldt = LocalDateTime.from(temporal);
    return ZonedDateTime.of2(ldt, zone);
  };

  ZonedDateTime._from = function _from(temporal, zone) {
    try {
      return ZonedDateTime.__from(temporal, zone);
    } catch (ex) {
      if (!(ex instanceof DateTimeException)) throw ex;
    }
  };

  ZonedDateTime.__from = function __from(temporal, zone) {
    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);
  };

  ZonedDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
    }

    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, ZonedDateTime.FROM);
  };

  function ZonedDateTime(dateTime, offset, zone) {
    var _this;

    requireNonNull(dateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    _this = _ChronoZonedDateTime.call(this) || this;
    _this._dateTime = dateTime;
    _this._offset = offset;
    _this._zone = zone;
    return _this;
  }

  var _proto = ZonedDateTime.prototype;

  _proto._resolveLocal = function _resolveLocal(newDateTime) {
    requireNonNull(newDateTime, 'newDateTime');
    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);
  };

  _proto._resolveInstant = function _resolveInstant(newDateTime) {
    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);
  };

  _proto._resolveOffset = function _resolveOffset(offset) {
    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
      return new ZonedDateTime(this._dateTime, offset, this._zone);
    }

    return this;
  };

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return true;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }

      return this._dateTime.range(field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();

        case ChronoField.OFFSET_SECONDS:
          return this._offset.totalSeconds();
      }

      return this._dateTime.getLong(field);
    }

    requireNonNull(field, 'field');
    return field.getFrom(this);
  };

  _proto.offset = function offset() {
    return this._offset;
  };

  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this._dateTime);

    if (trans != null && trans.isOverlap()) {
      var earlierOffset = trans.offsetBefore();

      if (earlierOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);
      }
    }

    return this;
  };

  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this.toLocalDateTime());

    if (trans != null) {
      var laterOffset = trans.offsetAfter();

      if (laterOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);
      }
    }

    return this;
  };

  _proto.zone = function zone() {
    return this._zone;
  };

  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };

  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
  };

  _proto.withFixedOffsetZone = function withFixedOffsetZone() {
    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);
  };

  _proto.year = function year() {
    return this._dateTime.year();
  };

  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };

  _proto.month = function month() {
    return this._dateTime.month();
  };

  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };

  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };

  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };

  _proto.hour = function hour() {
    return this._dateTime.hour();
  };

  _proto.minute = function minute() {
    return this._dateTime.minute();
  };

  _proto.second = function second() {
    return this._dateTime.second();
  };

  _proto.nano = function nano() {
    return this._dateTime.nano();
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    if (adjuster instanceof LocalDate) {
      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
    } else if (adjuster instanceof LocalTime) {
      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
    } else if (adjuster instanceof LocalDateTime) {
      return this._resolveLocal(adjuster);
    } else if (adjuster instanceof Instant) {
      var instant = adjuster;
      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);
    } else if (adjuster instanceof ZoneOffset) {
      return this._resolveOffset(adjuster);
    }

    return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
  };

  _proto._withField = function _withField(field, newValue) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return ZonedDateTime._create(newValue, this.nano(), this._zone);

        case ChronoField.OFFSET_SECONDS:
          {
            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
            return this._resolveOffset(offset);
          }
      }

      return this._resolveLocal(this._dateTime.with(field, newValue));
    }

    return field.adjustInto(this, newValue);
  };

  _proto.withYear = function withYear(year) {
    return this._resolveLocal(this._dateTime.withYear(year));
  };

  _proto.withMonth = function withMonth(month) {
    return this._resolveLocal(this._dateTime.withMonth(month));
  };

  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
  };

  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
  };

  _proto.withHour = function withHour(hour) {
    return this._resolveLocal(this._dateTime.withHour(hour));
  };

  _proto.withMinute = function withMinute(minute) {
    return this._resolveLocal(this._dateTime.withMinute(minute));
  };

  _proto.withSecond = function withSecond(second) {
    return this._resolveLocal(this._dateTime.withSecond(second));
  };

  _proto.withNano = function withNano(nanoOfSecond) {
    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    return this._resolveLocal(this._dateTime.truncatedTo(unit));
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      if (unit.isDateBased()) {
        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
      } else {
        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
      }
    }

    requireNonNull(unit, 'unit');
    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(years) {
    return this._resolveLocal(this._dateTime.plusYears(years));
  };

  _proto.plusMonths = function plusMonths(months) {
    return this._resolveLocal(this._dateTime.plusMonths(months));
  };

  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._resolveLocal(this._dateTime.plusWeeks(weeks));
  };

  _proto.plusDays = function plusDays(days) {
    return this._resolveLocal(this._dateTime.plusDays(days));
  };

  _proto.plusHours = function plusHours(hours) {
    return this._resolveInstant(this._dateTime.plusHours(hours));
  };

  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._resolveInstant(this._dateTime.plusMinutes(minutes));
  };

  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._resolveInstant(this._dateTime.plusSeconds(seconds));
  };

  _proto.plusNanos = function plusNanos(nanos) {
    return this._resolveInstant(this._dateTime.plusNanos(nanos));
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };

  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };

  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };

  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };

  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };

  _proto.minusHours = function minusHours(hours) {
    return this.plusHours(-1 * hours);
  };

  _proto.minusMinutes = function minusMinutes(minutes) {
    return this.plusMinutes(-1 * minutes);
  };

  _proto.minusSeconds = function minusSeconds(seconds) {
    return this.plusSeconds(-1 * seconds);
  };

  _proto.minusNanos = function minusNanos(nanos) {
    return this.plusNanos(-1 * nanos);
  };

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }

    requireNonNull(_query, 'query');
    return _ChronoZonedDateTime.prototype.query.call(this, _query);
  };

  _proto.until = function until(endExclusive, unit) {
    var end = ZonedDateTime.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      end = end.withZoneSameInstant(this._zone);

      if (unit.isDateBased()) {
        return this._dateTime.until(end._dateTime, unit);
      } else {
        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();

        var adjustedEnd = end._dateTime.plusSeconds(difference);

        return this._dateTime.until(adjustedEnd, unit);
      }
    }

    return unit.between(this, end);
  };

  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };

  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };

  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };

  _proto.toOffsetDateTime = function toOffsetDateTime() {
    return OffsetDateTime.of(this._dateTime, this._offset);
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof ZonedDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
  };

  _proto.toString = function toString() {
    var str = this._dateTime.toString() + this._offset.toString();

    if (this._offset !== this._zone) {
      str += "[" + this._zone.toString() + "]";
    }

    return str;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    return _ChronoZonedDateTime.prototype.format.call(this, formatter);
  };

  return ZonedDateTime;
}(ChronoZonedDateTime);
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {
    return ZonedDateTime.from(temporal);
  });
}

var OffsetDateTime = function (_Temporal) {
  _inheritsLoose(OffsetDateTime, _Temporal);

  OffsetDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');

    if (temporal instanceof OffsetDateTime) {
      return temporal;
    }

    try {
      var offset = ZoneOffset.from(temporal);

      try {
        var ldt = LocalDateTime.from(temporal);
        return OffsetDateTime.of(ldt, offset);
      } catch (_) {
        var instant = Instant.from(temporal);
        return OffsetDateTime.ofInstant(instant, offset);
      }
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  OffsetDateTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetDateTime.now(Clock.systemDefaultZone());
    } else {
      requireNonNull(clockOrZone, 'clockOrZone');

      if (clockOrZone instanceof ZoneId) {
        return OffsetDateTime.now(Clock.system(clockOrZone));
      } else if (clockOrZone instanceof Clock) {
        var now = clockOrZone.instant();
        return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));
      } else {
        throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');
      }
    }
  };

  OffsetDateTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetDateTime.ofDateTime.apply(this, arguments);
    } else if (arguments.length === 3) {
      return OffsetDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return OffsetDateTime.ofNumbers.apply(this, arguments);
    }
  };

  OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {
    return new OffsetDateTime(dateTime, offset);
  };

  OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {
    var dt = LocalDateTime.of(date, time);
    return new OffsetDateTime(dt, offset);
  };

  OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
    if (hour === void 0) {
      hour = 0;
    }

    if (minute === void 0) {
      minute = 0;
    }

    if (second === void 0) {
      second = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return new OffsetDateTime(dt, offset);
  };

  OffsetDateTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
    return new OffsetDateTime(ldt, offset);
  };

  OffsetDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
    }

    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetDateTime.FROM);
  };

  function OffsetDateTime(dateTime, offset) {
    var _this;

    _this = _Temporal.call(this) || this;
    requireNonNull(dateTime, 'dateTime');
    requireInstance(dateTime, LocalDateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._dateTime = dateTime;
    _this._offset = offset;
    return _this;
  }

  var _proto = OffsetDateTime.prototype;

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };

  _proto.until = function until(endExclusive, unit) {
    var end = OffsetDateTime.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      end = end.withOffsetSameInstant(this._offset);
      return this._dateTime.until(end._dateTime, unit);
    }

    return unit.between(this, end);
  };

  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
  };

  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zoneId()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          throw new DateTimeException("Field too large for an int: " + field);

        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }

      return this._dateTime.get(field);
    }

    return _Temporal.prototype.get.call(this, field);
  };

  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();

        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }

      return this._dateTime.getLong(field);
    }

    return field.getFrom(this);
  };

  _proto.offset = function offset() {
    return this._offset;
  };

  _proto.year = function year() {
    return this._dateTime.year();
  };

  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };

  _proto.month = function month() {
    return this._dateTime.month();
  };

  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };

  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };

  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };

  _proto.hour = function hour() {
    return this._dateTime.hour();
  };

  _proto.minute = function minute() {
    return this._dateTime.minute();
  };

  _proto.second = function second() {
    return this._dateTime.second();
  };

  _proto.nano = function nano() {
    return this._dateTime.nano();
  };

  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };

  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };

  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };

  _proto.toOffsetTime = function toOffsetTime() {
    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
  };

  _proto.toZonedDateTime = function toZonedDateTime() {
    return ZonedDateTime.of(this._dateTime, this._offset);
  };

  _proto.toInstant = function toInstant() {
    return this._dateTime.toInstant(this._offset);
  };

  _proto.toEpochSecond = function toEpochSecond() {
    return this._dateTime.toEpochSecond(this._offset);
  };

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }

    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }

      return this._dateTime.range(field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster);

    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
    } else if (adjuster instanceof Instant) {
      return OffsetDateTime.ofInstant(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withDateTimeOffset(this._dateTime, adjuster);
    } else if (adjuster instanceof OffsetDateTime) {
      return adjuster;
    }

    return adjuster.adjustInto(this);
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field);

    if (field instanceof ChronoField) {
      var f = field;

      switch (f) {
        case ChronoField.INSTANT_SECONDS:
          return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);

        case ChronoField.OFFSET_SECONDS:
          {
            return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
          }
      }

      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
    }

    return field.adjustInto(this, newValue);
  };

  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
    if (this._dateTime === dateTime && this._offset.equals(offset)) {
      return this;
    }

    return new OffsetDateTime(dateTime, offset);
  };

  _proto.withYear = function withYear(year) {
    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
  };

  _proto.withMonth = function withMonth(month) {
    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
  };

  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
  };

  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
  };

  _proto.withHour = function withHour(hour) {
    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
  };

  _proto.withMinute = function withMinute(minute) {
    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
  };

  _proto.withSecond = function withSecond(second) {
    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
  };

  _proto.withNano = function withNano(nanoOfSecond) {
    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
  };

  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    requireNonNull(offset, 'offset');
    return this._withDateTimeOffset(this._dateTime, offset);
  };

  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');

    if (offset.equals(this._offset)) {
      return this;
    }

    var difference = offset.totalSeconds() - this._offset.totalSeconds();

    var adjusted = this._dateTime.plusSeconds(difference);

    return new OffsetDateTime(adjusted, offset);
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
  };

  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    return amount.addTo(this);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(years) {
    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
  };

  _proto.plusMonths = function plusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
  };

  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
  };

  _proto.plusDays = function plusDays(days) {
    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
  };

  _proto.plusHours = function plusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
  };

  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
  };

  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
  };

  _proto.plusNanos = function plusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
  };

  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };

  _proto.minusYears = function minusYears(years) {
    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
  };

  _proto.minusMonths = function minusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
  };

  _proto.minusWeeks = function minusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
  };

  _proto.minusDays = function minusDays(days) {
    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
  };

  _proto.minusHours = function minusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
  };

  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
  };

  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
  };

  _proto.minusNanos = function minusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetDateTime, 'other');

    if (this.offset().equals(other.offset())) {
      return this.toLocalDateTime().compareTo(other.toLocalDateTime());
    }

    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());

    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();

      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
      }
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };

  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };

  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof OffsetDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._dateTime.hashCode() ^ this._offset.hashCode();
  };

  _proto.toString = function toString() {
    return this._dateTime.toString() + this._offset.toString();
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };

  return OffsetDateTime;
}(Temporal);
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', function (temporal) {
    return OffsetDateTime.from(temporal);
  });
}

var DAYS_PER_CYCLE = 146097;
var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
var LocalDate = function (_ChronoLocalDate) {
  _inheritsLoose(LocalDate, _ChronoLocalDate);

  LocalDate.now = function now(clockOrZone) {
    var clock;

    if (clockOrZone == null) {
      clock = Clock.systemDefaultZone();
    } else if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone;
    }

    return LocalDate.ofInstant(clock.instant(), clock.zone());
  };

  LocalDate.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }

    requireNonNull(instant, 'instant');
    var offset = zone.rules().offset(instant);
    var epochSec = instant.epochSecond() + offset.totalSeconds();
    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
    return LocalDate.ofEpochDay(epochDay);
  };

  LocalDate.of = function of(year, month, dayOfMonth) {
    return new LocalDate(year, month, dayOfMonth);
  };

  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {
    ChronoField.YEAR.checkValidValue(year);
    var leap = IsoChronology.isLeapYear(year);

    if (dayOfYear === 366 && leap === false) {
      assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
    }

    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;

    if (dayOfYear > monthEnd) {
      moy = moy.plus(1);
    }

    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
    return new LocalDate(year, moy.value(), dom);
  };

  LocalDate.ofEpochDay = function ofEpochDay(epochDay) {
    if (epochDay === void 0) {
      epochDay = 0;
    }

    var adjust, adjustCycles, doyEst, yearEst, zeroDay;
    zeroDay = epochDay + DAYS_0000_TO_1970;
    zeroDay -= 60;
    adjust = 0;

    if (zeroDay < 0) {
      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
      adjust = adjustCycles * 400;
      zeroDay += -adjustCycles * DAYS_PER_CYCLE;
    }

    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));

    if (doyEst < 0) {
      yearEst--;
      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    }

    yearEst += adjust;
    var marchDoy0 = doyEst;
    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
    var month = (marchMonth0 + 2) % 12 + 1;
    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
    yearEst += MathUtil.intDiv(marchMonth0, 10);
    var year = yearEst;
    return new LocalDate(year, month, dom);
  };

  LocalDate.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var date = temporal.query(TemporalQueries.localDate());

    if (date == null) {
      throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }

    return date;
  };

  LocalDate.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE;
    }

    assert(formatter != null, 'formatter', NullPointerException);
    return formatter.parse(text, LocalDate.FROM);
  };

  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
    switch (month) {
      case 2:
        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
        break;

      case 4:
      case 6:
      case 9:
      case 11:
        day = Math.min(day, 30);
        break;
    }

    return LocalDate.of(year, month, day);
  };

  function LocalDate(year, month, dayOfMonth) {
    var _this;

    _this = _ChronoLocalDate.call(this) || this;
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');

    if (month instanceof Month) {
      month = month.value();
    }

    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);

    LocalDate._validate(_this._year, _this._month, _this._day);

    return _this;
  }

  LocalDate._validate = function _validate(year, month, dayOfMonth) {
    var dom;
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);

    if (dayOfMonth > 28) {
      dom = 31;

      switch (month) {
        case 2:
          dom = IsoChronology.isLeapYear(year) ? 29 : 28;
          break;

        case 4:
        case 6:
        case 9:
        case 11:
          dom = 30;
      }

      if (dayOfMonth > dom) {
        if (dayOfMonth === 29) {
          assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
        } else {
          assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
        }
      }
    }
  };

  var _proto = LocalDate.prototype;

  _proto.isSupported = function isSupported(field) {
    return _ChronoLocalDate.prototype.isSupported.call(this, field);
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field.isDateBased()) {
        switch (field) {
          case ChronoField.DAY_OF_MONTH:
            return ValueRange.of(1, this.lengthOfMonth());

          case ChronoField.DAY_OF_YEAR:
            return ValueRange.of(1, this.lengthOfYear());

          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);

          case ChronoField.YEAR_OF_ERA:
            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }

        return field.range();
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    assert(field != null, '', NullPointerException);

    if (field instanceof ChronoField) {
      return this._get0(field);
    }

    return field.getFrom(this);
  };

  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.DAY_OF_WEEK:
        return this.dayOfWeek().value();

      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
        return MathUtil.intMod(this._day - 1, 7) + 1;

      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;

      case ChronoField.DAY_OF_MONTH:
        return this._day;

      case ChronoField.DAY_OF_YEAR:
        return this.dayOfYear();

      case ChronoField.EPOCH_DAY:
        return this.toEpochDay();

      case ChronoField.ALIGNED_WEEK_OF_MONTH:
        return MathUtil.intDiv(this._day - 1, 7) + 1;

      case ChronoField.ALIGNED_WEEK_OF_YEAR:
        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;

      case ChronoField.MONTH_OF_YEAR:
        return this._month;

      case ChronoField.PROLEPTIC_MONTH:
        return this._prolepticMonth();

      case ChronoField.YEAR_OF_ERA:
        return this._year >= 1 ? this._year : 1 - this._year;

      case ChronoField.YEAR:
        return this._year;

      case ChronoField.ERA:
        return this._year >= 1 ? 1 : 0;
    }

    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };

  _proto._prolepticMonth = function _prolepticMonth() {
    return this._year * 12 + (this._month - 1);
  };

  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };

  _proto.year = function year() {
    return this._year;
  };

  _proto.monthValue = function monthValue() {
    return this._month;
  };

  _proto.month = function month() {
    return Month.of(this._month);
  };

  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };

  _proto.dayOfYear = function dayOfYear() {
    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
  };

  _proto.dayOfWeek = function dayOfWeek() {
    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
    return DayOfWeek.of(dow0 + 1);
  };

  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };

  _proto.lengthOfMonth = function lengthOfMonth() {
    switch (this._month) {
      case 2:
        return this.isLeapYear() ? 29 : 28;

      case 4:
      case 6:
      case 9:
      case 11:
        return 30;

      default:
        return 31;
    }
  };

  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');

    if (adjuster instanceof LocalDate) {
      return adjuster;
    }

    return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
  };

  _proto._withField = function _withField(field, newValue) {
    assert(field != null, 'field', NullPointerException);

    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);

      switch (f) {
        case ChronoField.DAY_OF_WEEK:
          return this.plusDays(newValue - this.dayOfWeek().value());

        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));

        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));

        case ChronoField.DAY_OF_MONTH:
          return this.withDayOfMonth(newValue);

        case ChronoField.DAY_OF_YEAR:
          return this.withDayOfYear(newValue);

        case ChronoField.EPOCH_DAY:
          return LocalDate.ofEpochDay(newValue);

        case ChronoField.ALIGNED_WEEK_OF_MONTH:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));

        case ChronoField.ALIGNED_WEEK_OF_YEAR:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));

        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);

        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));

        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);

        case ChronoField.YEAR:
          return this.withYear(newValue);

        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.adjustInto(this, newValue);
  };

  _proto.withYear = function withYear(year) {
    if (this._year === year) {
      return this;
    }

    ChronoField.YEAR.checkValidValue(year);
    return LocalDate._resolvePreviousValid(year, this._month, this._day);
  };

  _proto.withMonth = function withMonth(month) {
    var m = month instanceof Month ? month.value() : month;

    if (this._month === m) {
      return this;
    }

    ChronoField.MONTH_OF_YEAR.checkValidValue(m);
    return LocalDate._resolvePreviousValid(this._year, m, this._day);
  };

  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (this._day === dayOfMonth) {
      return this;
    }

    return LocalDate.of(this._year, this._month, dayOfMonth);
  };

  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    if (this.dayOfYear() === dayOfYear) {
      return this;
    }

    return LocalDate.ofYearDay(this._year, dayOfYear);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.plusDays(amountToAdd);

        case ChronoUnit.WEEKS:
          return this.plusWeeks(amountToAdd);

        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);

        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);

        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));

        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));

        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));

        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }

    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);
  };

  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }

    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);
  };

  _proto.plusWeeks = function plusWeeks(weeksToAdd) {
    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
  };

  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }

    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
    return LocalDate.ofEpochDay(mjDay);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };

  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(yearsToSubtract * -1);
  };

  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(monthsToSubtract * -1);
  };

  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
    return this.plusWeeks(weeksToSubtract * -1);
  };

  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(daysToSubtract * -1);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.localDate()) {
      return this;
    }

    return _ChronoLocalDate.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
  };

  _proto.until = function until(p1, p2) {
    if (arguments.length < 2) {
      return this.until1(p1);
    } else {
      return this.until2(p1, p2);
    }
  };

  _proto.until2 = function until2(endExclusive, unit) {
    var end = LocalDate.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.daysUntil(end);

        case ChronoUnit.WEEKS:
          return MathUtil.intDiv(this.daysUntil(end), 7);

        case ChronoUnit.MONTHS:
          return this._monthsUntil(end);

        case ChronoUnit.YEARS:
          return MathUtil.intDiv(this._monthsUntil(end), 12);

        case ChronoUnit.DECADES:
          return MathUtil.intDiv(this._monthsUntil(end), 120);

        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(this._monthsUntil(end), 1200);

        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(this._monthsUntil(end), 12000);

        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  _proto.daysUntil = function daysUntil(end) {
    return end.toEpochDay() - this.toEpochDay();
  };

  _proto._monthsUntil = function _monthsUntil(end) {
    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
    return MathUtil.intDiv(packed2 - packed1, 32);
  };

  _proto.until1 = function until1(endDate) {
    var end = LocalDate.from(endDate);

    var totalMonths = end._prolepticMonth() - this._prolepticMonth();

    var days = end._day - this._day;

    if (totalMonths > 0 && days < 0) {
      totalMonths--;
      var calcDate = this.plusMonths(totalMonths);
      days = end.toEpochDay() - calcDate.toEpochDay();
    } else if (totalMonths < 0 && days > 0) {
      totalMonths++;
      days -= end.lengthOfMonth();
    }

    var years = MathUtil.intDiv(totalMonths, 12);
    var months = MathUtil.intMod(totalMonths, 12);
    return Period.of(years, months, days);
  };

  _proto.atTime = function atTime() {
    if (arguments.length === 1) {
      return this.atTime1.apply(this, arguments);
    } else {
      return this.atTime4.apply(this, arguments);
    }
  };

  _proto.atTime1 = function atTime1(time) {
    requireNonNull(time, 'time');

    if (time instanceof LocalTime) {
      return LocalDateTime.of(this, time);
    } else if (time instanceof OffsetTime) {
      return this._atTimeOffsetTime(time);
    } else {
      throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ''));
    }
  };

  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
    if (second === void 0) {
      second = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
  };

  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
    return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
  };

  _proto.atStartOfDay = function atStartOfDay(zone) {
    if (zone != null) {
      return this._atStartOfDayWithZone(zone);
    } else {
      return LocalDateTime.of(this, LocalTime.MIDNIGHT);
    }
  };

  _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
    requireNonNull(zone, 'zone');
    var ldt = this.atTime(LocalTime.MIDNIGHT);

    if (zone instanceof ZoneOffset === false) {
      var trans = zone.rules().transition(ldt);

      if (trans != null && trans.isGap()) {
        ldt = trans.dateTimeAfter();
      }
    }

    return ZonedDateTime.of(ldt, zone);
  };

  _proto.toEpochDay = function toEpochDay() {
    var y = this._year;
    var m = this._month;
    var total = 0;
    total += 365 * y;

    if (y >= 0) {
      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
    } else {
      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
    }

    total += MathUtil.intDiv(367 * m - 362, 12);
    total += this.dayOfMonth() - 1;

    if (m > 2) {
      total--;

      if (!IsoChronology.isLeapYear(y)) {
        total--;
      }
    }

    return total - DAYS_0000_TO_1970;
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDate, 'other');
    return this._compareTo0(other);
  };

  _proto._compareTo0 = function _compareTo0(otherDate) {
    var cmp = this._year - otherDate._year;

    if (cmp === 0) {
      cmp = this._month - otherDate._month;

      if (cmp === 0) {
        cmp = this._day - otherDate._day;
      }
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };

  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };

  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof LocalDate) {
      return this._compareTo0(other) === 0;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
  };

  _proto.toString = function toString() {
    var dayString, monthString, yearString;
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    var absYear = Math.abs(yearValue);

    if (absYear < 1000) {
      if (yearValue < 0) {
        yearString = "-" + ("" + (yearValue - 10000)).slice(-4);
      } else {
        yearString = ("" + (yearValue + 10000)).slice(-4);
      }
    } else {
      if (yearValue > 9999) {
        yearString = "+" + yearValue;
      } else {
        yearString = "" + yearValue;
      }
    }

    if (monthValue < 10) {
      monthString = "-0" + monthValue;
    } else {
      monthString = "-" + monthValue;
    }

    if (dayValue < 10) {
      dayString = "-0" + dayValue;
    } else {
      dayString = "-" + dayValue;
    }

    return yearString + monthString + dayString;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return _ChronoLocalDate.prototype.format.call(this, formatter);
  };

  return LocalDate;
}(ChronoLocalDate);
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {
    return LocalDate.from(temporal);
  });
}

var ChronoLocalDateTime = function (_Temporal) {
  _inheritsLoose(ChronoLocalDateTime, _Temporal);

  function ChronoLocalDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }

  var _proto = ChronoLocalDateTime.prototype;

  _proto.chronology = function chronology() {
    return this.toLocalDate().chronology();
  };

  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }

    return _Temporal.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
  };

  _proto.toInstant = function toInstant(offset) {
    requireInstance(offset, ZoneOffset, 'zoneId');
    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
  };

  _proto.toEpochSecond = function toEpochSecond(offset) {
    requireNonNull(offset, 'offset');
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= offset.totalSeconds();
    return MathUtil.safeToInt(secs);
  };

  return ChronoLocalDateTime;
}(Temporal);

var LocalDateTime = function (_ChronoLocalDateTime) {
  _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);

  LocalDateTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalDateTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalDateTime._now(clockOrZone);
    } else {
      return LocalDateTime._now(Clock.system(clockOrZone));
    }
  };

  LocalDateTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    return LocalDateTime.ofInstant(clock.instant(), clock.zone());
  };

  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };

  LocalDateTime.of = function of() {
    if (arguments.length <= 2) {
      return LocalDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return LocalDateTime.ofNumbers.apply(this, arguments);
    }
  };

  LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
    if (hour === void 0) {
      hour = 0;
    }

    if (minute === void 0) {
      minute = 0;
    }

    if (second === void 0) {
      second = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    var date = LocalDate.of(year, month, dayOfMonth);
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new LocalDateTime(date, time);
  };

  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {
    requireNonNull(date, 'date');
    requireNonNull(time, 'time');
    return new LocalDateTime(date, time);
  };

  LocalDateTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }

    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    var offset = zone.rules().offset(instant);
    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
  };

  LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
    if (epochSecond === void 0) {
      epochSecond = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
      offset = nanoOfSecond;
      nanoOfSecond = 0;
    }

    requireNonNull(offset, 'offset');
    var localSecond = epochSecond + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };

  LocalDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');

    if (temporal instanceof LocalDateTime) {
      return temporal;
    } else if (temporal instanceof ZonedDateTime) {
      return temporal.toLocalDateTime();
    }

    try {
      var date = LocalDate.from(temporal);
      var time = LocalTime.from(temporal);
      return new LocalDateTime(date, time);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };

  LocalDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    }

    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalDateTime.FROM);
  };

  function LocalDateTime(date, time) {
    var _this;

    _this = _ChronoLocalDateTime.call(this) || this;
    requireInstance(date, LocalDate, 'date');
    requireInstance(time, LocalTime, 'time');
    _this._date = date;
    _this._time = time;
    return _this;
  }

  var _proto = LocalDateTime.prototype;

  _proto._withDateTime = function _withDateTime(newDate, newTime) {
    if (this._date.equals(newDate) && this._time.equals(newTime)) {
      return this;
    }

    return new LocalDateTime(newDate, newTime);
  };

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
    }

    return field.rangeRefinedBy(this);
  };

  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
    }

    return _ChronoLocalDateTime.prototype.get.call(this, field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
    }

    return field.getFrom(this);
  };

  _proto.year = function year() {
    return this._date.year();
  };

  _proto.monthValue = function monthValue() {
    return this._date.monthValue();
  };

  _proto.month = function month() {
    return this._date.month();
  };

  _proto.dayOfMonth = function dayOfMonth() {
    return this._date.dayOfMonth();
  };

  _proto.dayOfYear = function dayOfYear() {
    return this._date.dayOfYear();
  };

  _proto.dayOfWeek = function dayOfWeek() {
    return this._date.dayOfWeek();
  };

  _proto.hour = function hour() {
    return this._time.hour();
  };

  _proto.minute = function minute() {
    return this._time.minute();
  };

  _proto.second = function second() {
    return this._time.second();
  };

  _proto.nano = function nano() {
    return this._time.nano();
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');

    if (adjuster instanceof LocalDate) {
      return this._withDateTime(adjuster, this._time);
    } else if (adjuster instanceof LocalTime) {
      return this._withDateTime(this._date, adjuster);
    } else if (adjuster instanceof LocalDateTime) {
      return adjuster;
    }

    return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      if (field.isTimeBased()) {
        return this._withDateTime(this._date, this._time.with(field, newValue));
      } else {
        return this._withDateTime(this._date.with(field, newValue), this._time);
      }
    }

    return field.adjustInto(this, newValue);
  };

  _proto.withYear = function withYear(year) {
    return this._withDateTime(this._date.withYear(year), this._time);
  };

  _proto.withMonth = function withMonth(month) {
    return this._withDateTime(this._date.withMonth(month), this._time);
  };

  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
  };

  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
  };

  _proto.withHour = function withHour(hour) {
    var newTime = this._time.withHour(hour);

    return this._withDateTime(this._date, newTime);
  };

  _proto.withMinute = function withMinute(minute) {
    var newTime = this._time.withMinute(minute);

    return this._withDateTime(this._date, newTime);
  };

  _proto.withSecond = function withSecond(second) {
    var newTime = this._time.withSecond(second);

    return this._withDateTime(this._date, newTime);
  };

  _proto.withNano = function withNano(nanoOfSecond) {
    var newTime = this._time.withNano(nanoOfSecond);

    return this._withDateTime(this._date, newTime);
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTime(this._date, this._time.truncatedTo(unit));
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);

        case ChronoUnit.MICROS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);

        case ChronoUnit.MILLIS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);

        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);

        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);

        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);

        case ChronoUnit.HALF_DAYS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
      }

      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusYears = function plusYears(years) {
    var newDate = this._date.plusYears(years);

    return this._withDateTime(newDate, this._time);
  };

  _proto.plusMonths = function plusMonths(months) {
    var newDate = this._date.plusMonths(months);

    return this._withDateTime(newDate, this._time);
  };

  _proto.plusWeeks = function plusWeeks(weeks) {
    var newDate = this._date.plusWeeks(weeks);

    return this._withDateTime(newDate, this._time);
  };

  _proto.plusDays = function plusDays(days) {
    var newDate = this._date.plusDays(days);

    return this._withDateTime(newDate, this._time);
  };

  _proto.plusHours = function plusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
  };

  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
  };

  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
  };

  _proto.plusNanos = function plusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };

  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };

  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };

  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };

  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };

  _proto.minusHours = function minusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
  };

  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
  };

  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
  };

  _proto.minusNanos = function minusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
  };

  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
      return this._withDateTime(newDate, this._time);
    }

    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
    totDays *= sign;
    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;

    var curNoD = this._time.toNanoOfDay();

    totNanos = totNanos * sign + curNoD;
    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
    return this._withDateTime(newDate.plusDays(totDays), newTime);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }

    return _ChronoLocalDateTime.prototype.query.call(this, _query);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
  };

  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalDateTime.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      if (unit.isTimeBased()) {
        var daysUntil = this._date.daysUntil(end._date);

        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();

        if (daysUntil > 0 && timeUntil < 0) {
          daysUntil--;
          timeUntil += LocalTime.NANOS_PER_DAY;
        } else if (daysUntil < 0 && timeUntil > 0) {
          daysUntil++;
          timeUntil -= LocalTime.NANOS_PER_DAY;
        }

        var amount = daysUntil;

        switch (unit) {
          case ChronoUnit.NANOS:
            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
            return MathUtil.safeAdd(amount, timeUntil);

          case ChronoUnit.MICROS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));

          case ChronoUnit.MILLIS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));

          case ChronoUnit.SECONDS:
            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));

          case ChronoUnit.MINUTES:
            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));

          case ChronoUnit.HOURS:
            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));

          case ChronoUnit.HALF_DAYS:
            amount = MathUtil.safeMultiply(amount, 2);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
        }

        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      }

      var endDate = end._date;
      var endTime = end._time;

      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
        endDate = endDate.minusDays(1);
      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
        endDate = endDate.plusDays(1);
      }

      return this._date.until(endDate, unit);
    }

    return unit.between(this, end);
  };

  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.of(this, offset);
  };

  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.of(this, zone);
  };

  _proto.toLocalDate = function toLocalDate() {
    return this._date;
  };

  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDateTime, 'other');
    return this._compareTo0(other);
  };

  _proto._compareTo0 = function _compareTo0(other) {
    var cmp = this._date.compareTo(other.toLocalDate());

    if (cmp === 0) {
      cmp = this._time.compareTo(other.toLocalTime());
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };

  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };

  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof LocalDateTime) {
      return this._date.equals(other._date) && this._time.equals(other._time);
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._date.hashCode() ^ this._time.hashCode();
  };

  _proto.toString = function toString() {
    return this._date.toString() + "T" + this._time.toString();
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };

  return LocalDateTime;
}(ChronoLocalDateTime);
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {
    return LocalDateTime.from(temporal);
  });
}

var LocalTime = function (_Temporal) {
  _inheritsLoose(LocalTime, _Temporal);

  LocalTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalTime._now(clockOrZone);
    } else {
      return LocalTime._now(Clock.system(clockOrZone));
    }
  };

  LocalTime._now = function _now(clock) {
    if (clock === void 0) {
      clock = Clock.systemDefaultZone();
    }

    requireNonNull(clock, 'clock');
    return LocalTime.ofInstant(clock.instant(), clock.zone());
  };

  LocalTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }

    var offset = zone.rules().offset(instant);
    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);
    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);

    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }

    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
  };

  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {
    return new LocalTime(hour, minute, second, nanoOfSecond);
  };

  LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
    if (secondOfDay === void 0) {
      secondOfDay = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);
    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;
    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);
    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;
    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);
  };

  LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
    if (nanoOfDay === void 0) {
      nanoOfDay = 0;
    }

    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);
    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;
    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);
    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;
    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);
    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;
    return new LocalTime(hours, minutes, seconds, nanoOfDay);
  };

  LocalTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var time = temporal.query(TemporalQueries.localTime());

    if (time == null) {
      throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }

    return time;
  };

  LocalTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_TIME;
    }

    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalTime.FROM);
  };

  function LocalTime(hour, minute, second, nanoOfSecond) {
    var _this;

    if (hour === void 0) {
      hour = 0;
    }

    if (minute === void 0) {
      minute = 0;
    }

    if (second === void 0) {
      second = 0;
    }

    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    _this = _Temporal.call(this) || this;

    var _hour = MathUtil.safeToInt(hour);

    var _minute = MathUtil.safeToInt(minute);

    var _second = MathUtil.safeToInt(second);

    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);

    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);

    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
      if (!LocalTime.HOURS[_hour]) {
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        LocalTime.HOURS[_hour] = _assertThisInitialized(_this);
      }

      return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);
    }

    _this._hour = _hour;
    _this._minute = _minute;
    _this._second = _second;
    _this._nano = _nanoOfSecond;
    return _this;
  }

  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {
    ChronoField.HOUR_OF_DAY.checkValidValue(hour);
    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
  };

  var _proto = LocalTime.prototype;

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    requireNonNull(field);
    return _Temporal.prototype.range.call(this, field);
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      return this._get0(field);
    }

    return field.getFrom(this);
  };

  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.NANO_OF_SECOND:
        return this._nano;

      case ChronoField.NANO_OF_DAY:
        return this.toNanoOfDay();

      case ChronoField.MICRO_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000);

      case ChronoField.MICRO_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000);

      case ChronoField.MILLI_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000000);

      case ChronoField.MILLI_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);

      case ChronoField.SECOND_OF_MINUTE:
        return this._second;

      case ChronoField.SECOND_OF_DAY:
        return this.toSecondOfDay();

      case ChronoField.MINUTE_OF_HOUR:
        return this._minute;

      case ChronoField.MINUTE_OF_DAY:
        return this._hour * 60 + this._minute;

      case ChronoField.HOUR_OF_AMPM:
        return MathUtil.intMod(this._hour, 12);

      case ChronoField.CLOCK_HOUR_OF_AMPM:
        {
          var ham = MathUtil.intMod(this._hour, 12);
          return ham % 12 === 0 ? 12 : ham;
        }

      case ChronoField.HOUR_OF_DAY:
        return this._hour;

      case ChronoField.CLOCK_HOUR_OF_DAY:
        return this._hour === 0 ? 24 : this._hour;

      case ChronoField.AMPM_OF_DAY:
        return MathUtil.intDiv(this._hour, 12);
    }

    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };

  _proto.hour = function hour() {
    return this._hour;
  };

  _proto.minute = function minute() {
    return this._minute;
  };

  _proto.second = function second() {
    return this._second;
  };

  _proto.nano = function nano() {
    return this._nano;
  };

  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');

    if (adjuster instanceof LocalTime) {
      return adjuster;
    }

    return _Temporal.prototype._withAdjuster.call(this, adjuster);
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');

    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);

      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this.withNano(newValue);

        case ChronoField.NANO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue);

        case ChronoField.MICRO_OF_SECOND:
          return this.withNano(newValue * 1000);

        case ChronoField.MICRO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000);

        case ChronoField.MILLI_OF_SECOND:
          return this.withNano(newValue * 1000000);

        case ChronoField.MILLI_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000000);

        case ChronoField.SECOND_OF_MINUTE:
          return this.withSecond(newValue);

        case ChronoField.SECOND_OF_DAY:
          return this.plusSeconds(newValue - this.toSecondOfDay());

        case ChronoField.MINUTE_OF_HOUR:
          return this.withMinute(newValue);

        case ChronoField.MINUTE_OF_DAY:
          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));

        case ChronoField.HOUR_OF_AMPM:
          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));

        case ChronoField.CLOCK_HOUR_OF_AMPM:
          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));

        case ChronoField.HOUR_OF_DAY:
          return this.withHour(newValue);

        case ChronoField.CLOCK_HOUR_OF_DAY:
          return this.withHour(newValue === 24 ? 0 : newValue);

        case ChronoField.AMPM_OF_DAY:
          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.adjustInto(this, newValue);
  };

  _proto.withHour = function withHour(hour) {
    if (hour === void 0) {
      hour = 0;
    }

    if (this._hour === hour) {
      return this;
    }

    return new LocalTime(hour, this._minute, this._second, this._nano);
  };

  _proto.withMinute = function withMinute(minute) {
    if (minute === void 0) {
      minute = 0;
    }

    if (this._minute === minute) {
      return this;
    }

    return new LocalTime(this._hour, minute, this._second, this._nano);
  };

  _proto.withSecond = function withSecond(second) {
    if (second === void 0) {
      second = 0;
    }

    if (this._second === second) {
      return this;
    }

    return new LocalTime(this._hour, this._minute, second, this._nano);
  };

  _proto.withNano = function withNano(nanoOfSecond) {
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }

    if (this._nano === nanoOfSecond) {
      return this;
    }

    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');

    if (unit === ChronoUnit.NANOS) {
      return this;
    }

    var unitDur = unit.duration();

    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }

    var dur = unitDur.toNanos();

    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }

    var nod = this.toNanoOfDay();
    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);

        case ChronoUnit.MICROS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);

        case ChronoUnit.MILLIS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);

        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);

        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);

        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);

        case ChronoUnit.HALF_DAYS:
          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusHours = function plusHours(hoursToAdd) {
    if (hoursToAdd === 0) {
      return this;
    }

    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);
    return new LocalTime(newHour, this._minute, this._second, this._nano);
  };

  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    if (minutesToAdd === 0) {
      return this;
    }

    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;
    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);

    if (mofd === newMofd) {
      return this;
    }

    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);
    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);
    return new LocalTime(newHour, newMinute, this._second, this._nano);
  };

  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    if (secondsToAdd === 0) {
      return this;
    }

    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;
    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);

    if (sofd === newSofd) {
      return this;
    }

    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);
    return new LocalTime(newHour, newMinute, newSecond, this._nano);
  };

  _proto.plusNanos = function plusNanos(nanosToAdd) {
    if (nanosToAdd === 0) {
      return this;
    }

    var nofd = this.toNanoOfDay();
    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);

    if (nofd === newNofd) {
      return this;
    }

    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);
    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);
    return new LocalTime(newHour, newMinute, newSecond, newNano);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };

  _proto.minusHours = function minusHours(hoursToSubtract) {
    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));
  };

  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));
  };

  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));
  };

  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localTime()) {
      return this;
    }

    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
      return null;
    }

    return _query.queryFrom(this);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());
  };

  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalTime.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();

      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;

        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1000);

        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1000000);

        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);

        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);

        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);

        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  _proto.atDate = function atDate(date) {
    return LocalDateTime.of(date, this);
  };

  _proto.atOffset = function atOffset(offset) {
    return OffsetTime.of(this, offset);
  };

  _proto.toSecondOfDay = function toSecondOfDay() {
    var total = this._hour * LocalTime.SECONDS_PER_HOUR;
    total += this._minute * LocalTime.SECONDS_PER_MINUTE;
    total += this._second;
    return total;
  };

  _proto.toNanoOfDay = function toNanoOfDay() {
    var total = this._hour * LocalTime.NANOS_PER_HOUR;
    total += this._minute * LocalTime.NANOS_PER_MINUTE;
    total += this._second * LocalTime.NANOS_PER_SECOND;
    total += this._nano;
    return total;
  };

  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalTime, 'other');
    var cmp = MathUtil.compareNumbers(this._hour, other._hour);

    if (cmp === 0) {
      cmp = MathUtil.compareNumbers(this._minute, other._minute);

      if (cmp === 0) {
        cmp = MathUtil.compareNumbers(this._second, other._second);

        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._nano, other._nano);
        }
      }
    }

    return cmp;
  };

  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };

  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof LocalTime) {
      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    var nod = this.toNanoOfDay();
    return MathUtil.hash(nod);
  };

  _proto.toString = function toString() {
    var buf = '';
    var hourValue = this._hour;
    var minuteValue = this._minute;
    var secondValue = this._second;
    var nanoValue = this._nano;
    buf += hourValue < 10 ? '0' : '';
    buf += hourValue;
    buf += minuteValue < 10 ? ':0' : ':';
    buf += minuteValue;

    if (secondValue > 0 || nanoValue > 0) {
      buf += secondValue < 10 ? ':0' : ':';
      buf += secondValue;

      if (nanoValue > 0) {
        buf += '.';

        if (MathUtil.intMod(nanoValue, 1000000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);
        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);
        } else {
          buf += ("" + (nanoValue + 1000000000)).substring(1);
        }
      }
    }

    return buf;
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };

  return LocalTime;
}(Temporal);
function _init$3() {
  LocalTime.HOURS = [];

  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }

  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {
    return LocalTime.from(temporal);
  });
}
LocalTime.HOURS_PER_DAY = 24;
LocalTime.MINUTES_PER_HOUR = 60;
LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.SECONDS_PER_MINUTE = 60;
LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;
LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;
LocalTime.NANOS_PER_SECOND = 1000000000;
LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;

var NANOS_PER_MILLI = 1000000;
var Instant = function (_Temporal) {
  _inheritsLoose(Instant, _Temporal);

  Instant.now = function now(clock) {
    if (clock === void 0) {
      clock = Clock.systemUTC();
    }

    return clock.instant();
  };

  Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }

    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Instant._create(secs, nos);
  };

  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {
    var secs = MathUtil.floorDiv(epochMilli, 1000);
    var mos = MathUtil.floorMod(epochMilli, 1000);
    return Instant._create(secs, mos * 1000000);
  };

  Instant.ofEpochMicro = function ofEpochMicro(epochMicro) {
    var secs = MathUtil.floorDiv(epochMicro, 1000000);
    var mos = MathUtil.floorMod(epochMicro, 1000000);
    return Instant._create(secs, mos * 1000);
  };

  Instant.from = function from(temporal) {
    try {
      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
    }
  };

  Instant.parse = function parse(text) {
    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);
  };

  Instant._create = function _create(seconds, nanoOfSecond) {
    if (seconds === 0 && nanoOfSecond === 0) {
      return Instant.EPOCH;
    }

    return new Instant(seconds, nanoOfSecond);
  };

  Instant._validate = function _validate(seconds, nanoOfSecond) {
    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }

    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }
  };

  function Instant(seconds, nanoOfSecond) {
    var _this;

    _this = _Temporal.call(this) || this;

    Instant._validate(seconds, nanoOfSecond);

    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanoOfSecond);
    return _this;
  }

  var _proto = Instant.prototype;

  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
    }

    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
    }

    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };

  _proto.range = function range(field) {
    return _Temporal.prototype.range.call(this, field);
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this._nanos;

        case ChronoField.MICRO_OF_SECOND:
          return MathUtil.intDiv(this._nanos, 1000);

        case ChronoField.MILLI_OF_SECOND:
          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);

        case ChronoField.INSTANT_SECONDS:
          return this._seconds;
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.epochSecond = function epochSecond() {
    return this._seconds;
  };

  _proto.nano = function nano() {
    return this._nanos;
  };

  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);

      switch (field) {
        case ChronoField.MILLI_OF_SECOND:
          {
            var nval = newValue * NANOS_PER_MILLI;
            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;
          }

        case ChronoField.MICRO_OF_SECOND:
          {
            var _nval = newValue * 1000;

            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;
          }

        case ChronoField.NANO_OF_SECOND:
          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;

        case ChronoField.INSTANT_SECONDS:
          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.adjustInto(this, newValue);
  };

  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');

    if (unit === ChronoUnit.NANOS) {
      return this;
    }

    var unitDur = unit.duration();

    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }

    var dur = unitDur.toNanos();

    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }

    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;

    var result = MathUtil.intDiv(nod, dur) * dur;
    return this.plusNanos(result - nod);
  };

  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit);

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);

        case ChronoUnit.MICROS:
          return this.plusMicros(amountToAdd);

        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);

        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);

        case ChronoUnit.MINUTES:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));

        case ChronoUnit.HOURS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));

        case ChronoUnit.HALF_DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));

        case ChronoUnit.DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.addTo(this, amountToAdd);
  };

  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this._plus(secondsToAdd, 0);
  };

  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);
  };

  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this._plus(0, nanosToAdd);
  };

  _proto.plusMicros = function plusMicros(microsToAdd) {
    return this._plus(MathUtil.intDiv(microsToAdd, 1000000), MathUtil.intMod(microsToAdd, 1000000) * 1000);
  };

  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }

    var epochSec = this._seconds + secondsToAdd;
    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
    return Instant.ofEpochSecond(epochSec, nanoAdjustment);
  };

  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };

  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(secondsToSubtract * -1);
  };

  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return this.plusMillis(-1 * millisToSubtract);
  };

  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * nanosToSubtract);
  };

  _proto.minusMicros = function minusMicros(microsToSubtract) {
    return this.plusMicros(-1 * microsToSubtract);
  };

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    }

    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return null;
    }

    return _query.queryFrom(this);
  };

  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
  };

  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = Instant.from(endExclusive);

    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this._nanosUntil(end);

        case ChronoUnit.MICROS:
          return this._microsUntil(end);

        case ChronoUnit.MILLIS:
          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());

        case ChronoUnit.SECONDS:
          return this._secondsUntil(end);

        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);

        case ChronoUnit.HOURS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);

        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);

        case ChronoUnit.DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
      }

      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }

    return unit.between(this, end);
  };

  _proto._microsUntil = function _microsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalMicros = MathUtil.safeMultiply(secsDiff, 1000000);
    return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1000));
  };

  _proto._nanosUntil = function _nanosUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
  };

  _proto._secondsUntil = function _secondsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var nanosDiff = end.nano() - this.nano();

    if (secsDiff > 0 && nanosDiff < 0) {
      secsDiff--;
    } else if (secsDiff < 0 && nanosDiff > 0) {
      secsDiff++;
    }

    return secsDiff;
  };

  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.ofInstant(this, offset);
  };

  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.ofInstant(this, zone);
  };

  _proto.toEpochMilli = function toEpochMilli() {
    var millis = MathUtil.safeMultiply(this._seconds, 1000);
    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
  };

  _proto.compareTo = function compareTo(otherInstant) {
    requireNonNull(otherInstant, 'otherInstant');
    requireInstance(otherInstant, Instant, 'otherInstant');
    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);

    if (cmp !== 0) {
      return cmp;
    }

    return this._nanos - otherInstant._nanos;
  };

  _proto.isAfter = function isAfter(otherInstant) {
    return this.compareTo(otherInstant) > 0;
  };

  _proto.isBefore = function isBefore(otherInstant) {
    return this.compareTo(otherInstant) < 0;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    if (other instanceof Instant) {
      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._seconds, this._nanos);
  };

  _proto.toString = function toString() {
    return DateTimeFormatter.ISO_INSTANT.format(this);
  };

  _proto.toJSON = function toJSON() {
    return this.toString();
  };

  return Instant;
}(Temporal);
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {
    return Instant.from(temporal);
  });
}

var Clock = function () {
  function Clock() {}

  Clock.systemUTC = function systemUTC() {
    return new SystemClock(ZoneOffset.UTC);
  };

  Clock.systemDefaultZone = function systemDefaultZone() {
    return new SystemClock(ZoneId.systemDefault());
  };

  Clock.system = function system(zone) {
    return new SystemClock(zone);
  };

  Clock.fixed = function fixed(fixedInstant, zoneId) {
    return new FixedClock(fixedInstant, zoneId);
  };

  Clock.offset = function offset(baseClock, duration) {
    return new OffsetClock(baseClock, duration);
  };

  var _proto = Clock.prototype;

  _proto.millis = function millis() {
    abstractMethodFail('Clock.millis');
  };

  _proto.instant = function instant() {
    abstractMethodFail('Clock.instant');
  };

  _proto.zone = function zone() {
    abstractMethodFail('Clock.zone');
  };

  _proto.withZone = function withZone() {
    abstractMethodFail('Clock.withZone');
  };

  return Clock;
}();

var SystemClock = function (_Clock) {
  _inheritsLoose(SystemClock, _Clock);

  function SystemClock(zone) {
    var _this;

    requireNonNull(zone, 'zone');
    _this = _Clock.call(this) || this;
    _this._zone = zone;
    return _this;
  }

  var _proto2 = SystemClock.prototype;

  _proto2.zone = function zone() {
    return this._zone;
  };

  _proto2.millis = function millis() {
    return new Date().getTime();
  };

  _proto2.instant = function instant() {
    return Instant.ofEpochMilli(this.millis());
  };

  _proto2.equals = function equals(obj) {
    if (obj instanceof SystemClock) {
      return this._zone.equals(obj._zone);
    }

    return false;
  };

  _proto2.withZone = function withZone(zone) {
    if (zone.equals(this._zone)) {
      return this;
    }

    return new SystemClock(zone);
  };

  _proto2.toString = function toString() {
    return "SystemClock[" + this._zone.toString() + "]";
  };

  return SystemClock;
}(Clock);

var FixedClock = function (_Clock2) {
  _inheritsLoose(FixedClock, _Clock2);

  function FixedClock(fixedInstant, zoneId) {
    var _this2;

    _this2 = _Clock2.call(this) || this;
    _this2._instant = fixedInstant;
    _this2._zoneId = zoneId;
    return _this2;
  }

  var _proto3 = FixedClock.prototype;

  _proto3.instant = function instant() {
    return this._instant;
  };

  _proto3.millis = function millis() {
    return this._instant.toEpochMilli();
  };

  _proto3.zone = function zone() {
    return this._zoneId;
  };

  _proto3.toString = function toString() {
    return 'FixedClock[]';
  };

  _proto3.equals = function equals(obj) {
    if (obj instanceof FixedClock) {
      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
    }

    return false;
  };

  _proto3.withZone = function withZone(zone) {
    if (zone.equals(this._zoneId)) {
      return this;
    }

    return new FixedClock(this._instant, zone);
  };

  return FixedClock;
}(Clock);

var OffsetClock = function (_Clock3) {
  _inheritsLoose(OffsetClock, _Clock3);

  function OffsetClock(baseClock, offset) {
    var _this3;

    _this3 = _Clock3.call(this) || this;
    _this3._baseClock = baseClock;
    _this3._offset = offset;
    return _this3;
  }

  var _proto4 = OffsetClock.prototype;

  _proto4.zone = function zone() {
    return this._baseClock.zone();
  };

  _proto4.withZone = function withZone(zone) {
    if (zone.equals(this._baseClock.zone())) {
      return this;
    }

    return new OffsetClock(this._baseClock.withZone(zone), this._offset);
  };

  _proto4.millis = function millis() {
    return this._baseClock.millis() + this._offset.toMillis();
  };

  _proto4.instant = function instant() {
    return this._baseClock.instant().plus(this._offset);
  };

  _proto4.equals = function equals(obj) {
    if (obj instanceof OffsetClock) {
      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
    }

    return false;
  };

  _proto4.toString = function toString() {
    return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
  };

  return OffsetClock;
}(Clock);

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneOffsetTransition = function () {
  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {
    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
  };

  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {
    requireNonNull(transition, 'transition');
    requireNonNull(offsetBefore, 'offsetBefore');
    requireNonNull(offsetAfter, 'offsetAfter');

    if (offsetBefore.equals(offsetAfter)) {
      throw new IllegalArgumentException('Offsets must not be equal');
    }

    if (transition.nano() !== 0) {
      throw new IllegalArgumentException('Nano-of-second must be zero');
    }

    if (transition instanceof LocalDateTime) {
      this._transition = transition;
    } else {
      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
    }

    this._offsetBefore = offsetBefore;
    this._offsetAfter = offsetAfter;
  }

  var _proto = ZoneOffsetTransition.prototype;

  _proto.instant = function instant() {
    return this._transition.toInstant(this._offsetBefore);
  };

  _proto.toEpochSecond = function toEpochSecond() {
    return this._transition.toEpochSecond(this._offsetBefore);
  };

  _proto.dateTimeBefore = function dateTimeBefore() {
    return this._transition;
  };

  _proto.dateTimeAfter = function dateTimeAfter() {
    return this._transition.plusSeconds(this.durationSeconds());
  };

  _proto.offsetBefore = function offsetBefore() {
    return this._offsetBefore;
  };

  _proto.offsetAfter = function offsetAfter() {
    return this._offsetAfter;
  };

  _proto.duration = function duration() {
    return Duration.ofSeconds(this.durationSeconds());
  };

  _proto.durationSeconds = function durationSeconds() {
    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
  };

  _proto.isGap = function isGap() {
    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
  };

  _proto.isOverlap = function isOverlap() {
    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
  };

  _proto.isValidOffset = function isValidOffset(offset) {
    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
  };

  _proto.validOffsets = function validOffsets() {
    if (this.isGap()) {
      return [];
    } else {
      return [this._offsetBefore, this._offsetAfter];
    }
  };

  _proto.compareTo = function compareTo(transition) {
    return this.instant().compareTo(transition.instant());
  };

  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }

    if (other instanceof ZoneOffsetTransition) {
      var d = other;
      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
    }

    return false;
  };

  _proto.hashCode = function hashCode() {
    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
  };

  _proto.toString = function toString() {
    return "Transition[" + (this.isGap() ? 'Gap' : 'Overlap') + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
  };

  return ZoneOffsetTransition;
}();

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }

    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }

    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }

    return null;
  });
}

var SystemDefaultZoneRules = function (_ZoneRules) {
  _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);

  function SystemDefaultZoneRules() {
    return _ZoneRules.apply(this, arguments) || this;
  }

  var _proto = SystemDefaultZoneRules.prototype;

  _proto.isFixedOffset = function isFixedOffset() {
    return false;
  };

  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };

  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };

  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;
    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;
    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
  };

  _proto.validOffsets = function validOffsets(localDateTime) {
    return [this.offsetOfLocalDateTime(localDateTime)];
  };

  _proto.transition = function transition() {
    return null;
  };

  _proto.standardOffset = function standardOffset(instant) {
    return this.offsetOfInstant(instant);
  };

  _proto.daylightSavings = function daylightSavings() {
    this._throwNotSupported();
  };

  _proto.isDaylightSavings = function isDaylightSavings() {
    this._throwNotSupported();
  };

  _proto.isValidOffset = function isValidOffset(dateTime, offset) {
    return this.offsetOfLocalDateTime(dateTime).equals(offset);
  };

  _proto.nextTransition = function nextTransition() {
    this._throwNotSupported();
  };

  _proto.previousTransition = function previousTransition() {
    this._throwNotSupported();
  };

  _proto.transitions = function transitions() {
    this._throwNotSupported();
  };

  _proto.transitionRules = function transitionRules() {
    this._throwNotSupported();
  };

  _proto._throwNotSupported = function _throwNotSupported() {
    throw new DateTimeException('not supported operation');
  };

  _proto.equals = function equals(other) {
    if (this === other || other instanceof SystemDefaultZoneRules) {
      return true;
    } else {
      return false;
    }
  };

  _proto.toString = function toString() {
    return 'SYSTEM';
  };

  return SystemDefaultZoneRules;
}(ZoneRules);

var SystemDefaultZoneId = function (_ZoneId) {
  _inheritsLoose(SystemDefaultZoneId, _ZoneId);

  function SystemDefaultZoneId() {
    var _this;

    _this = _ZoneId.call(this) || this;
    _this._rules = new SystemDefaultZoneRules();
    return _this;
  }

  var _proto = SystemDefaultZoneId.prototype;

  _proto.rules = function rules() {
    return this._rules;
  };

  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }

    return false;
  };

  _proto.id = function id() {
    return 'SYSTEM';
  };

  return SystemDefaultZoneId;
}(ZoneId);

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var ZoneIdFactory = function () {
  function ZoneIdFactory() {}

  ZoneIdFactory.systemDefault = function systemDefault() {
    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  };

  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {
    return ZoneRulesProvider.getAvailableZoneIds();
  };

  ZoneIdFactory.of = function of(zoneId) {
    requireNonNull(zoneId, 'zoneId');

    if (zoneId === 'Z') {
      return ZoneOffset.UTC;
    }

    if (zoneId.length === 1) {
      throw new DateTimeException("Invalid zone: " + zoneId);
    }

    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {
      return ZoneOffset.of(zoneId);
    }

    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {
      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
    }

    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {
      var offset = ZoneOffset.of(zoneId.substring(3));

      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
      }

      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
    }

    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {
      var _offset = ZoneOffset.of(zoneId.substring(2));

      if (_offset.totalSeconds() === 0) {
        return new ZoneRegion('UT', _offset.rules());
      }

      return new ZoneRegion("UT" + _offset.id(), _offset.rules());
    }

    if (zoneId === 'SYSTEM') {
      return ZoneId.systemDefault();
    }

    return ZoneRegion.ofId(zoneId);
  };

  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {
    requireNonNull(prefix, 'prefix');
    requireNonNull(offset, 'offset');

    if (prefix.length === 0) {
      return offset;
    }

    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(prefix, offset.rules());
      }

      return new ZoneRegion(prefix + offset.id(), offset.rules());
    }

    throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
  };

  ZoneIdFactory.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var obj = temporal.query(TemporalQueries.zone());

    if (obj == null) {
      throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }

    return obj;
  };

  return ZoneIdFactory;
}();
var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var isInit = false;

function init() {
  if (isInit) {
    return;
  }

  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}

init();

/*
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ToNativeJsConverter = function () {
  function ToNativeJsConverter(temporal, zone) {
    var zonedDateTime;

    if (temporal instanceof Instant) {
      this.instant = temporal;
      return;
    } else if (temporal instanceof LocalDate) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atStartOfDay(zone);
    } else if (temporal instanceof LocalDateTime) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atZone(zone);
    } else if (temporal instanceof ZonedDateTime) {
      if (zone == null) {
        zonedDateTime = temporal;
      } else {
        zonedDateTime = temporal.withZoneSameInstant(zone);
      }
    } else {
      throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
    }

    this.instant = zonedDateTime.toInstant();
  }

  var _proto = ToNativeJsConverter.prototype;

  _proto.toDate = function toDate() {
    return new Date(this.instant.toEpochMilli());
  };

  _proto.toEpochMilli = function toEpochMilli() {
    return this.instant.toEpochMilli();
  };

  return ToNativeJsConverter;
}();

function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}

var NativeJsTemporal = function (_TemporalAccessor) {
  _inheritsLoose(NativeJsTemporal, _TemporalAccessor);

  function NativeJsTemporal(date, zone) {
    var _this;

    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }

    _this = _TemporalAccessor.call(this) || this;
    _this._zone = zone;

    if (date instanceof Date) {
      _this._epochMilli = date.getTime();
      return _assertThisInitialized(_this);
    } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {
      _this._epochMilli = date.toDate().getTime();
      return _assertThisInitialized(_this);
    }

    assert(false, 'date must be either a javascript date or a moment');
    return _this;
  }

  var _proto = NativeJsTemporal.prototype;

  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');

    if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);
    } else if (_query === TemporalQueries.localTime()) {
      return LocalTime.ofInstant(Instant.ofEpochMilli(this._epochMilli), this._zone);
    } else if (_query === TemporalQueries.zone()) {
      return this._zone;
    }

    return _TemporalAccessor.prototype.query.call(this, _query);
  };

  _proto.get = function get(field) {
    return this.getLong(field);
  };

  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');

    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return MathUtil.floorMod(this._epochMilli, 1000) * 1000000;

        case ChronoField.INSTANT_SECONDS:
          return MathUtil.floorDiv(this._epochMilli, 1000);
      }

      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }

    return field.getFrom(this);
  };

  _proto.isSupported = function isSupported(field) {
    return field === ChronoField.INSTANT_SECONDS || field === ChronoField.NANO_OF_SECOND;
  };

  return NativeJsTemporal;
}(TemporalAccessor);

function nativeJs(date, zone) {
  return new NativeJsTemporal(date, zone);
}

function bindUse(jsJoda) {
  var used = [];
  return function use(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }

    return jsJoda;
  };
}

/**
 * @copyright (c) 2016, Philipp Thürwächter & Pattrick Hüper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var _ = {
  assert: assert$1,
  DateTimeBuilder: DateTimeBuilder,
  DateTimeParseContext: DateTimeParseContext,
  DateTimePrintContext: DateTimePrintContext,
  MathUtil: MathUtil,
  StringUtil: StringUtil,
  StringBuilder: StringBuilder
};
var jsJodaExports = {
  _: _,
  convert: convert,
  nativeJs: nativeJs,
  ArithmeticException: ArithmeticException,
  DateTimeException: DateTimeException,
  DateTimeParseException: DateTimeParseException,
  IllegalArgumentException: IllegalArgumentException,
  IllegalStateException: IllegalStateException,
  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,
  NullPointerException: NullPointerException,
  Clock: Clock,
  DayOfWeek: DayOfWeek,
  Duration: Duration,
  Instant: Instant,
  LocalDate: LocalDate,
  LocalTime: LocalTime,
  LocalDateTime: LocalDateTime,
  OffsetTime: OffsetTime,
  OffsetDateTime: OffsetDateTime,
  Month: Month,
  MonthDay: MonthDay,
  Period: Period,
  Year: Year,
  YearConstants: YearConstants,
  YearMonth: YearMonth,
  ZonedDateTime: ZonedDateTime,
  ZoneOffset: ZoneOffset,
  ZoneId: ZoneId,
  ZoneRegion: ZoneRegion,
  ZoneOffsetTransition: ZoneOffsetTransition,
  ZoneRules: ZoneRules,
  ZoneRulesProvider: ZoneRulesProvider,
  ChronoLocalDate: ChronoLocalDate,
  ChronoLocalDateTime: ChronoLocalDateTime,
  ChronoZonedDateTime: ChronoZonedDateTime,
  IsoChronology: IsoChronology,
  ChronoField: ChronoField,
  ChronoUnit: ChronoUnit,
  IsoFields: IsoFields,
  Temporal: Temporal,
  TemporalAccessor: TemporalAccessor,
  TemporalAdjuster: TemporalAdjuster,
  TemporalAdjusters: TemporalAdjusters,
  TemporalAmount: TemporalAmount,
  TemporalField: TemporalField,
  TemporalQueries: TemporalQueries,
  TemporalQuery: TemporalQuery,
  TemporalUnit: TemporalUnit,
  ValueRange: ValueRange,
  DateTimeFormatter: DateTimeFormatter,
  DateTimeFormatterBuilder: DateTimeFormatterBuilder,
  DecimalStyle: DecimalStyle,
  ResolverStyle: ResolverStyle,
  SignStyle: SignStyle,
  TextStyle: TextStyle
};
var use = bindUse(jsJodaExports);
jsJodaExports.use = use;


//# sourceMappingURL=js-joda.esm.js.map


/***/ }),

/***/ "./src/Calculator.ts":
/*!***************************!*\
  !*** ./src/Calculator.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "daysBetween": () => (/* binding */ daysBetween),
/* harmony export */   "afterIntervalTimes": () => (/* binding */ afterIntervalTimes),
/* harmony export */   "recurringEvent": () => (/* binding */ recurringEvent)
/* harmony export */ });
/* harmony import */ var _js_joda_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-joda/core */ "./node_modules/@js-joda/core/dist/js-joda.esm.js");

function daysBetween(start, end) {
    var days = 0;
    days = start.until(end, _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.ChronoUnit.DAYS);
    return days;
}
;
function afterIntervalTimes(start, interval, multiplier) {
    var newPeriod = interval.multipliedBy(multiplier);
    var returnDate = start.plus(newPeriod);
    return returnDate;
}
function recurringEvent(start, end, interval, timeOfDay) {
    //initialize array
    var recurrEvents = [];
    //stay in loop until we've traversed all days
    while (end.compareTo(start) >= 0) {
        //If the `start` time is **earlier in the day** than `timeOfDay`, the first event should take place on the `start` date; otherwise, the first event should take place **exactly** one `interval` after the `start` date
        if (start.compareTo(start.with(timeOfDay)) > 0) {
            start = start.with(timeOfDay);
            start = start.plus(interval);
        }
        else {
            start = start.with(timeOfDay);
            recurrEvents.push(start);
            start = start.plus(interval);
        }
    } //end While Loop
    return recurrEvents;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************!*\
  !*** ./src/Main.ts ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_joda_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @js-joda/core */ "./node_modules/@js-joda/core/dist/js-joda.esm.js");
/* harmony import */ var _Calculator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Calculator */ "./src/Calculator.ts");
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable no-console */


var handleOnSubmit = function (outputID, run) { return function () {
    var output = document.getElementById(outputID);
    try {
        output.innerHTML = run();
    }
    catch (e) {
        if (e instanceof _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.DateTimeParseException)
            output.innerText = "parse error";
        else if (e instanceof Error)
            console.error("".concat(e.constructor.name, ": ").concat(e.message));
        else
            console.error(e.toString());
    }
    return false;
}; };
var getInputElementById = function (id) {
    return document.getElementById(id);
};
var parseNonNegativeInt = function (str) {
    var val = parseInt(str);
    if (isNaN(val))
        throw new _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.DateTimeParseException("invalid integer: " + str);
    else if (val < 0)
        throw new _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.DateTimeParseException("expected a positive integer: " + str);
    else
        return val;
};
window.onload = function () {
    document.getElementById("daysBetween").onsubmit =
        handleOnSubmit("daysBetweenOutput", function () {
            var start = getInputElementById("daysBetweenStart");
            var end = getInputElementById("daysBetweenEnd");
            return (0,_Calculator__WEBPACK_IMPORTED_MODULE_1__.daysBetween)(_js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalDate.parse(start.value), _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalDate.parse(end.value)).toString();
        });
    document.getElementById("afterIntervalTimes").onsubmit =
        handleOnSubmit("afterIntervalTimesOutput", function () {
            var start = getInputElementById("afterIntervalTimesStart");
            var interval = getInputElementById("afterIntervalTimesInterval");
            var multiplier = getInputElementById("afterIntervalTimesMultiplier");
            return (0,_Calculator__WEBPACK_IMPORTED_MODULE_1__.afterIntervalTimes)(_js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalDate.parse(start.value), _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.Period.parse(interval.value), parseNonNegativeInt(multiplier.value)).toString();
        });
    document.getElementById("recurringEvent").onsubmit =
        handleOnSubmit("recurringEventOutput", function () {
            var start = getInputElementById("recurringEventStart");
            var end = getInputElementById("recurringEventEnd");
            var interval = getInputElementById("recurringEventInterval");
            var timeOfDay = getInputElementById("recurringEventTimeOfDay");
            return (0,_Calculator__WEBPACK_IMPORTED_MODULE_1__.recurringEvent)(_js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalDateTime.parse(start.value), _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalDateTime.parse(end.value), _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.Period.parse(interval.value), _js_joda_core__WEBPACK_IMPORTED_MODULE_0__.LocalTime.parse(timeOfDay.value)).reduce(function (output, event) { return output + "<br>" + event.toString(); }, "");
        });
};

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7O0FBRUEseUNBQXlDLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrSEFBK0gsSUFBSTtBQUNuSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLHFEQUFxRDtBQUNwRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixxREFBcUQ7QUFDMUU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxtQkFBbUIsZUFBZTtBQUMxQztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsc0JBQXNCLHlFQUF5RTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3ekI7QUFDeHpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0cmF1QjtBQUVoQixTQUFTLFdBQVcsQ0FDdkIsS0FBZ0IsRUFDaEIsR0FBYztJQUVkLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBQywwREFBZSxDQUFDLENBQUM7SUFDeEMsT0FBTyxJQUFJLENBQUM7QUFDWixDQUFDO0FBQUEsQ0FBQztBQUdDLFNBQVMsa0JBQWtCLENBQzlCLEtBQWdCLEVBQ2hCLFFBQWdCLEVBQ2hCLFVBQWtCO0lBRWxCLElBQUksU0FBUyxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEQsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN2QyxPQUFPLFVBQVUsQ0FBQztBQUV0QixDQUFDO0FBRU0sU0FBUyxjQUFjLENBQzFCLEtBQW9CLEVBQ3BCLEdBQWtCLEVBQ2xCLFFBQWdCLEVBQ2hCLFNBQW9CO0lBR3JCLGtCQUFrQjtJQUNqQixJQUFJLFlBQVksR0FBQyxFQUFFLENBQUM7SUFFckIsNkNBQTZDO0lBQzdDLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBRSxDQUFDLEVBQUM7UUFDM0IsdU5BQXVOO1FBQ3ZOLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFDO1lBQy9DLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzlCLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ2hDO2FBQ007WUFDSCxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUM5QixZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pCLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ2hDO0tBRUEsaUJBQWdCO0lBQ2hCLE9BQU8sWUFBWSxDQUFDO0FBQ3hCLENBQUM7Ozs7Ozs7VUN2REQ7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7QUNOQSw2REFBNkQ7QUFDN0QsK0JBQStCO0FBT1I7QUFNRDtBQUV0QixJQUFNLGNBQWMsR0FBRyxVQUFDLFFBQWdCLEVBQUUsR0FBaUIsSUFBSztJQUM1RCxJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBRSxDQUFDO0lBQ2xELElBQUk7UUFDQSxNQUFNLENBQUMsU0FBUyxHQUFHLEdBQUcsRUFBRSxDQUFDO0tBQzVCO0lBQUMsT0FBTyxDQUFVLEVBQUU7UUFDakIsSUFBSSxDQUFDLFlBQVksaUVBQXNCO1lBQ25DLE1BQU0sQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDO2FBQ2hDLElBQUksQ0FBQyxZQUFZLEtBQUs7WUFDdkIsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxlQUFLLENBQUMsQ0FBQyxPQUFPLENBQUUsQ0FBQyxDQUFDOztZQUVyRCxPQUFPLENBQUMsS0FBSyxDQUFFLENBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQy9DO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyxFQWIrRCxDQWEvRCxDQUFDO0FBRUYsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLEVBQVU7SUFDbkMsZUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQXFCO0FBQS9DLENBQStDLENBQUM7QUFFcEQsSUFBTSxtQkFBbUIsR0FBRyxVQUFDLEdBQVc7SUFDcEMsSUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNWLE1BQU0sSUFBSSxpRUFBc0IsQ0FBQyxtQkFBbUIsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUMzRCxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ1osTUFBTSxJQUFJLGlFQUFzQixDQUFDLCtCQUErQixHQUFHLEdBQUcsQ0FBQyxDQUFDOztRQUV4RSxPQUFPLEdBQUcsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ1osUUFBUSxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUUsQ0FBQyxRQUFRO1FBQ2hELGNBQWMsQ0FBQyxtQkFBbUIsRUFBRTtZQUNoQyxJQUFNLEtBQUssR0FBRyxtQkFBbUIsQ0FBQyxrQkFBa0IsQ0FBRSxDQUFDO1lBQ3ZELElBQU0sR0FBRyxHQUFHLG1CQUFtQixDQUFDLGdCQUFnQixDQUFFLENBQUM7WUFDbkQsT0FBTyx3REFBVyxDQUNkLDBEQUFlLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUM1QiwwREFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FDN0IsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxjQUFjLENBQUMsb0JBQW9CLENBQUUsQ0FBQyxRQUFRO1FBQ3ZELGNBQWMsQ0FBQywwQkFBMEIsRUFBRTtZQUN2QyxJQUFNLEtBQUssR0FBRyxtQkFBbUIsQ0FBQyx5QkFBeUIsQ0FBRSxDQUFDO1lBQzlELElBQU0sUUFBUSxHQUFHLG1CQUFtQixDQUFDLDRCQUE0QixDQUFFLENBQUM7WUFDcEUsSUFBTSxVQUFVLEdBQUcsbUJBQW1CLENBQUMsOEJBQThCLENBQUUsQ0FBQztZQUN4RSxPQUFPLCtEQUFrQixDQUNyQiwwREFBZSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFDNUIsdURBQVksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQzVCLG1CQUFtQixDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FDeEMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUUsQ0FBQyxRQUFRO1FBQ25ELGNBQWMsQ0FBQyxzQkFBc0IsRUFBRTtZQUNuQyxJQUFNLEtBQUssR0FBRyxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBRSxDQUFDO1lBQzFELElBQU0sR0FBRyxHQUFHLG1CQUFtQixDQUFDLG1CQUFtQixDQUFFLENBQUM7WUFDdEQsSUFBTSxRQUFRLEdBQUcsbUJBQW1CLENBQUMsd0JBQXdCLENBQUUsQ0FBQztZQUNoRSxJQUFNLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyx5QkFBeUIsQ0FBRSxDQUFDO1lBQ2xFLE9BQU8sMkRBQWMsQ0FDakIsOERBQW1CLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUNoQyw4REFBbUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQzlCLHVEQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUM1QiwwREFBZSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FDbkMsQ0FBQyxNQUFNLENBQUMsVUFBQyxNQUFNLEVBQUUsS0FBSyxJQUFLLGFBQU0sR0FBRyxNQUFNLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxFQUFsQyxDQUFrQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3hFLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bqcy1qb2RhL2NvcmUvZGlzdC9qcy1qb2RhLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2FsY3VsYXRvci50cyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vLi9zcmMvTWFpbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgQHZlcnNpb24gQGpzLWpvZGEvY29yZSAtIDUuMi4wXG4vLyEgQGNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIsIFBhdHRyaWNrIEjDvHBlciAmIGpzLWpvZGEgY29udHJpYnV0b3JzXG4vLyEgQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4vLyEgQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShuYW1lLCBpbml0LCBzdXBlckVycm9yQ2xhc3MpIHtcbiAgaWYgKHN1cGVyRXJyb3JDbGFzcyA9PT0gdm9pZCAwKSB7XG4gICAgc3VwZXJFcnJvckNsYXNzID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBKc0pvZGFFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICghRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICBpbml0ICYmIGluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG4gIH1cblxuICBKc0pvZGFFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckVycm9yQ2xhc3MucHJvdG90eXBlKTtcbiAgSnNKb2RhRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gbmFtZTtcbiAgSnNKb2RhRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEpzSm9kYUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEpzSm9kYUV4Y2VwdGlvbjtcbn1cblxudmFyIERhdGVUaW1lRXhjZXB0aW9uID0gY3JlYXRlRXJyb3JUeXBlKCdEYXRlVGltZUV4Y2VwdGlvbicsIG1lc3NhZ2VXaXRoQ2F1c2UpO1xudmFyIERhdGVUaW1lUGFyc2VFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ0RhdGVUaW1lUGFyc2VFeGNlcHRpb24nLCBtZXNzYWdlRm9yRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbik7XG52YXIgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ1Vuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uJywgbnVsbCwgRGF0ZVRpbWVFeGNlcHRpb24pO1xudmFyIEFyaXRobWV0aWNFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ0FyaXRobWV0aWNFeGNlcHRpb24nKTtcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbicpO1xudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiA9IGNyZWF0ZUVycm9yVHlwZSgnSWxsZWdhbFN0YXRlRXhjZXB0aW9uJyk7XG52YXIgTnVsbFBvaW50ZXJFeGNlcHRpb24gPSBjcmVhdGVFcnJvclR5cGUoJ051bGxQb2ludGVyRXhjZXB0aW9uJyk7XG5cbmZ1bmN0aW9uIG1lc3NhZ2VXaXRoQ2F1c2UobWVzc2FnZSwgY2F1c2UpIHtcbiAgaWYgKGNhdXNlID09PSB2b2lkIDApIHtcbiAgICBjYXVzZSA9IG51bGw7XG4gIH1cblxuICB2YXIgbXNnID0gbWVzc2FnZSB8fCB0aGlzLm5hbWU7XG5cbiAgaWYgKGNhdXNlICE9PSBudWxsICYmIGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBtc2cgKz0gXCJcXG4tLS0tLS0tXFxuQ2F1c2VkIGJ5OiBcIiArIGNhdXNlLnN0YWNrICsgXCJcXG4tLS0tLS0tXFxuXCI7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG59XG5cbmZ1bmN0aW9uIG1lc3NhZ2VGb3JEYXRlVGltZVBhcnNlRXhjZXB0aW9uKG1lc3NhZ2UsIHRleHQsIGluZGV4LCBjYXVzZSkge1xuICBpZiAodGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgdGV4dCA9ICcnO1xuICB9XG5cbiAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICBpbmRleCA9IDA7XG4gIH1cblxuICBpZiAoY2F1c2UgPT09IHZvaWQgMCkge1xuICAgIGNhdXNlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBtc2cgPSBtZXNzYWdlIHx8IHRoaXMubmFtZTtcbiAgbXNnICs9IFwiOiBcIiArIHRleHQgKyBcIiwgYXQgaW5kZXg6IFwiICsgaW5kZXg7XG5cbiAgaWYgKGNhdXNlICE9PSBudWxsICYmIGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBtc2cgKz0gXCJcXG4tLS0tLS0tXFxuQ2F1c2VkIGJ5OiBcIiArIGNhdXNlLnN0YWNrICsgXCJcXG4tLS0tLS0tXFxuXCI7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG5cbiAgdGhpcy5wYXJzZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG5cbiAgdGhpcy5lcnJvckluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuXG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGFzc2VydGlvbiwgbXNnLCBlcnJvcikge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IGVycm9yKG1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVxdWlyZU5vbk51bGwodmFsdWUsIHBhcmFtZXRlck5hbWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTnVsbFBvaW50ZXJFeGNlcHRpb24ocGFyYW1ldGVyTmFtZSArIFwiIG11c3Qgbm90IGJlIG51bGxcIik7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXF1aXJlSW5zdGFuY2UodmFsdWUsIF9jbGFzcywgcGFyYW1ldGVyTmFtZSkge1xuICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9jbGFzcykpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKHBhcmFtZXRlck5hbWUgKyBcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFwiICsgKF9jbGFzcy5uYW1lID8gX2NsYXNzLm5hbWUgOiBfY2xhc3MpICsgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPyBcIiwgYnV0IGlzIFwiICsgdmFsdWUuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZEZhaWwobWV0aG9kTmFtZSkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYWJzdHJhY3QgbWV0aG9kIFxcXCJcIiArIG1ldGhvZE5hbWUgKyBcIlxcXCIgaXMgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG52YXIgYXNzZXJ0JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFzc2VydDogYXNzZXJ0LFxuICAgIHJlcXVpcmVOb25OdWxsOiByZXF1aXJlTm9uTnVsbCxcbiAgICByZXF1aXJlSW5zdGFuY2U6IHJlcXVpcmVJbnN0YW5jZSxcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWw6IGFic3RyYWN0TWV0aG9kRmFpbFxufSk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNSU5fU0FGRV9JTlRFR0VSID0gLTkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTWF0aFV0aWwgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdGhVdGlsKCkge31cblxuICBNYXRoVXRpbC5pbnREaXYgPSBmdW5jdGlvbiBpbnREaXYoeCwgeSkge1xuICAgIHZhciByID0geCAvIHk7XG4gICAgciA9IE1hdGhVdGlsLnJvdW5kRG93bihyKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG5cbiAgTWF0aFV0aWwuaW50TW9kID0gZnVuY3Rpb24gaW50TW9kKHgsIHkpIHtcbiAgICB2YXIgciA9IHggLSBNYXRoVXRpbC5pbnREaXYoeCwgeSkgKiB5O1xuICAgIHIgPSBNYXRoVXRpbC5yb3VuZERvd24ocik7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHIpO1xuICB9O1xuXG4gIE1hdGhVdGlsLnJvdW5kRG93biA9IGZ1bmN0aW9uIHJvdW5kRG93bihyKSB7XG4gICAgaWYgKHIgPCAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihyKTtcbiAgICB9XG4gIH07XG5cbiAgTWF0aFV0aWwuZmxvb3JEaXYgPSBmdW5jdGlvbiBmbG9vckRpdih4LCB5KSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKHggLyB5KTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8ocik7XG4gIH07XG5cbiAgTWF0aFV0aWwuZmxvb3JNb2QgPSBmdW5jdGlvbiBmbG9vck1vZCh4LCB5KSB7XG4gICAgdmFyIHIgPSB4IC0gTWF0aFV0aWwuZmxvb3JEaXYoeCwgeSkgKiB5O1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyhyKTtcbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlQWRkID0gZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHgpO1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh5KTtcblxuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuXG4gICAgaWYgKHkgPT09IDApIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh4KTtcbiAgICB9XG5cbiAgICB2YXIgciA9IE1hdGhVdGlsLnNhZmVUb0ludCh4ICsgeSk7XG5cbiAgICBpZiAociA9PT0geCB8fCByID09PSB5KSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignSW52YWxpZCBhZGRpdGlvbiBiZXlvbmQgTUFYX1NBRkVfSU5URUdFUiEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlU3VidHJhY3QgPSBmdW5jdGlvbiBzYWZlU3VidHJhY3QoeCwgeSkge1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh4KTtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQoeSk7XG5cbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybygtMSAqIHkpO1xuICAgIH0gZWxzZSBpZiAoeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVaZXJvKHgpO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlVG9JbnQoeCAtIHkpO1xuICB9O1xuXG4gIE1hdGhVdGlsLnNhZmVNdWx0aXBseSA9IGZ1bmN0aW9uIHNhZmVNdWx0aXBseSh4LCB5KSB7XG4gICAgTWF0aFV0aWwudmVyaWZ5SW50KHgpO1xuICAgIE1hdGhVdGlsLnZlcmlmeUludCh5KTtcblxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVplcm8oeSk7XG4gICAgfVxuXG4gICAgaWYgKHkgPT09IDEpIHtcbiAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh4KTtcbiAgICB9XG5cbiAgICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IE1hdGhVdGlsLnNhZmVUb0ludCh4ICogeSk7XG5cbiAgICBpZiAociAvIHkgIT09IHggfHwgeCA9PT0gTUlOX1NBRkVfSU5URUdFUiAmJiB5ID09PSAtMSB8fCB5ID09PSBNSU5fU0FGRV9JTlRFR0VSICYmIHggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbihcIk11bHRpcGxpY2F0aW9uIG92ZXJmbG93czogXCIgKyB4ICsgXCIgKiBcIiArIHkpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1hdGhVdGlsLnBhcnNlSW50ID0gZnVuY3Rpb24gKF9wYXJzZUludCkge1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KF94KSB7XG4gICAgICByZXR1cm4gX3BhcnNlSW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcGFyc2VJbnQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3BhcnNlSW50LnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBwYXJzZUludDtcbiAgfShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgciA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuc2FmZVRvSW50KHIpO1xuICB9KTtcblxuICBNYXRoVXRpbC5zYWZlVG9JbnQgPSBmdW5jdGlvbiBzYWZlVG9JbnQodmFsdWUpIHtcbiAgICBNYXRoVXRpbC52ZXJpZnlJbnQodmFsdWUpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlWmVybyh2YWx1ZSk7XG4gIH07XG5cbiAgTWF0aFV0aWwudmVyaWZ5SW50ID0gZnVuY3Rpb24gdmVyaWZ5SW50KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZTogJ1wiICsgdmFsdWUgKyBcIicsIHVzaW5nIG51bGwgb3IgdW5kZWZpbmVkIGFzIGFyZ3VtZW50XCIpO1xuICAgIH1cblxuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uKCdJbnZhbGlkIGludCB2YWx1ZSwgdXNpbmcgTmFOIGFzIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICUgMSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEFyaXRobWV0aWNFeGNlcHRpb24oXCJJbnZhbGlkIHZhbHVlOiAnXCIgKyB2YWx1ZSArIFwiJyBpcyBhIGZsb2F0XCIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdmFsdWUgPCBNSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbihcIkNhbGN1bGF0aW9uIG92ZXJmbG93cyBhbiBpbnQ6IFwiICsgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBNYXRoVXRpbC5zYWZlWmVybyA9IGZ1bmN0aW9uIHNhZmVaZXJvKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gMCA6ICt2YWx1ZTtcbiAgfTtcblxuICBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyA9IGZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBpZiAoYSA+IGIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIE1hdGhVdGlsLnNtaSA9IGZ1bmN0aW9uIHNtaShpbnQpIHtcbiAgICByZXR1cm4gaW50ID4+PiAxICYgMHg0MDAwMDAwMCB8IGludCAmIDB4QkZGRkZGRkY7XG4gIH07XG5cbiAgTWF0aFV0aWwuaGFzaCA9IGZ1bmN0aW9uIGhhc2gobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBudW1iZXI7XG5cbiAgICB3aGlsZSAobnVtYmVyID4gMHhGRkZGRkZGRikge1xuICAgICAgbnVtYmVyIC89IDB4RkZGRkZGRkY7XG4gICAgICByZXN1bHQgXj0gbnVtYmVyO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zbWkocmVzdWx0KTtcbiAgfTtcblxuICBNYXRoVXRpbC5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHZhciByZXN1bHQgPSAxNztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBudW1iZXJzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbnVtYmVyc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDAsIF9udW1iZXJzID0gbnVtYmVyczsgX2kgPCBfbnVtYmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuID0gX251bWJlcnNbX2ldO1xuICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCA1KSAtIHJlc3VsdCArIE1hdGhVdGlsLmhhc2gobik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2gocmVzdWx0KTtcbiAgfTtcblxuICByZXR1cm4gTWF0aFV0aWw7XG59KCk7XG5NYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSID0gTUFYX1NBRkVfSU5URUdFUjtcbk1hdGhVdGlsLk1JTl9TQUZFX0lOVEVHRVIgPSBNSU5fU0FGRV9JTlRFR0VSO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIEVudW0gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW0obmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVudW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBFbnVtO1xufSgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEFtb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxBbW91bnQoKSB7fVxuXG4gIHZhciBfcHJvdG8gPSBUZW1wb3JhbEFtb3VudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldCh1bml0KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdnZXQnKTtcbiAgfTtcblxuICBfcHJvdG8udW5pdHMgPSBmdW5jdGlvbiB1bml0cygpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3VuaXRzJyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2FkZFRvJyk7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0RnJvbSA9IGZ1bmN0aW9uIHN1YnRyYWN0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnc3VidHJhY3RGcm9tJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsQW1vdW50O1xufSgpO1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlKSB7XG4gIFRlbXBvcmFsQW1vdW50LnByb3RvdHlwZVtTeW1ib2wudG9QcmltaXRpdmVdID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgICBpZiAoaGludCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBjb252ZXJzaW9uIGZyb20gVGVtcG9yYWxBbW91bnQgdG8gYSBudW1iZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnVG8gY29tcGFyZSB1c2UgdGhlIG1ldGhvZHMgLmVxdWFscygpLCAuY29tcGFyZVRvKCksIC5pc0JlZm9yZSgpICcgKyAnb3Igb25lIHRoYXQgaXMgbW9yZSBzdWl0YWJsZSB0byB5b3VyIHVzZSBjYXNlLicpO1xuICB9O1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbFVuaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbXBvcmFsVW5pdCgpIHt9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsVW5pdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdkdXJhdGlvbicpO1xuICB9O1xuXG4gIF9wcm90by5pc0R1cmF0aW9uRXN0aW1hdGVkID0gZnVuY3Rpb24gaXNEdXJhdGlvbkVzdGltYXRlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzRHVyYXRpb25Fc3RpbWF0ZWQnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzRGF0ZUJhc2VkJyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdpc1RpbWVCYXNlZCcpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWRCeScpO1xuICB9O1xuXG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKGRhdGVUaW1lLCBwZXJpb2RUb0FkZCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnYWRkVG8nKTtcbiAgfTtcblxuICBfcHJvdG8uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4odGVtcG9yYWwxLCB0ZW1wb3JhbDIpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2JldHdlZW4nKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxVbml0O1xufSgpO1xuXG52YXIgRHVyYXRpb24gPSBmdW5jdGlvbiAoX1RlbXBvcmFsQW1vdW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKER1cmF0aW9uLCBfVGVtcG9yYWxBbW91bnQpO1xuXG4gIGZ1bmN0aW9uIER1cmF0aW9uKHNlY29uZHMsIG5hbm9zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBbW91bnQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9zZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHNlY29uZHMpO1xuICAgIF90aGlzLl9uYW5vcyA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgRHVyYXRpb24ub2ZEYXlzID0gZnVuY3Rpb24gb2ZEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShNYXRoVXRpbC5zYWZlTXVsdGlwbHkoZGF5cywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSksIDApO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mSG91cnMgPSBmdW5jdGlvbiBvZkhvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGhvdXJzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiksIDApO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mTWludXRlcyA9IGZ1bmN0aW9uIG9mTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1pbnV0ZXMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCAwKTtcbiAgfTtcblxuICBEdXJhdGlvbi5vZlNlY29uZHMgPSBmdW5jdGlvbiBvZlNlY29uZHMoc2Vjb25kcywgbmFub0FkanVzdG1lbnQpIHtcbiAgICBpZiAobmFub0FkanVzdG1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub0FkanVzdG1lbnQgPSAwO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuc2FmZUFkZChzZWNvbmRzLCBNYXRoVXRpbC5mbG9vckRpdihuYW5vQWRqdXN0bWVudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICB2YXIgbm9zID0gTWF0aFV0aWwuZmxvb3JNb2QobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNzLCBub3MpO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mTWlsbGlzID0gZnVuY3Rpb24gb2ZNaWxsaXMobWlsbGlzKSB7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5pbnREaXYobWlsbGlzLCAxMDAwKTtcbiAgICB2YXIgbW9zID0gTWF0aFV0aWwuaW50TW9kKG1pbGxpcywgMTAwMCk7XG5cbiAgICBpZiAobW9zIDwgMCkge1xuICAgICAgbW9zICs9IDEwMDA7XG4gICAgICBzZWNzLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIER1cmF0aW9uLl9jcmVhdGUoc2VjcywgbW9zICogMTAwMDAwMCk7XG4gIH07XG5cbiAgRHVyYXRpb24ub2ZOYW5vcyA9IGZ1bmN0aW9uIG9mTmFub3MobmFub3MpIHtcbiAgICB2YXIgc2VjcyA9IE1hdGhVdGlsLmludERpdihuYW5vcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnRNb2QobmFub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcblxuICAgIGlmIChub3MgPCAwKSB7XG4gICAgICBub3MgKz0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICBzZWNzLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZShzZWNzLCBub3MpO1xuICB9O1xuXG4gIER1cmF0aW9uLm9mID0gZnVuY3Rpb24gb2YoYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLlpFUk8ucGx1cyhhbW91bnQsIHVuaXQpO1xuICB9O1xuXG4gIER1cmF0aW9uLmZyb20gPSBmdW5jdGlvbiBmcm9tKGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhbW91bnQsIFRlbXBvcmFsQW1vdW50KTtcbiAgICB2YXIgZHVyYXRpb24gPSBEdXJhdGlvbi5aRVJPO1xuICAgIGFtb3VudC51bml0cygpLmZvckVhY2goZnVuY3Rpb24gKHVuaXQpIHtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24ucGx1cyhhbW91bnQuZ2V0KHVuaXQpLCB1bml0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZHVyYXRpb247XG4gIH07XG5cbiAgRHVyYXRpb24uYmV0d2VlbiA9IGZ1bmN0aW9uIGJldHdlZW4oc3RhcnRJbmNsdXNpdmUsIGVuZEV4Y2x1c2l2ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHN0YXJ0SW5jbHVzaXZlLCAnc3RhcnRJbmNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICB2YXIgc2VjcyA9IHN0YXJ0SW5jbHVzaXZlLnVudGlsKGVuZEV4Y2x1c2l2ZSwgQ2hyb25vVW5pdC5TRUNPTkRTKTtcbiAgICB2YXIgbmFub3MgPSAwO1xuXG4gICAgaWYgKHN0YXJ0SW5jbHVzaXZlLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKSAmJiBlbmRFeGNsdXNpdmUuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgc3RhcnROb3MgPSBzdGFydEluY2x1c2l2ZS5nZXRMb25nKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgICAgbmFub3MgPSBlbmRFeGNsdXNpdmUuZ2V0TG9uZyhDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCkgLSBzdGFydE5vcztcblxuICAgICAgICBpZiAoc2VjcyA+IDAgJiYgbmFub3MgPCAwKSB7XG4gICAgICAgICAgbmFub3MgKz0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjcyA8IDAgJiYgbmFub3MgPiAwKSB7XG4gICAgICAgICAgbmFub3MgLT0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VjcyA9PT0gMCAmJiBuYW5vcyAhPT0gMCkge1xuICAgICAgICAgIHZhciBhZGp1c3RlZEVuZCA9IGVuZEV4Y2x1c2l2ZS53aXRoKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBzdGFydE5vcyk7XG4gICAgICAgICAgc2VjcyA9IHN0YXJ0SW5jbHVzaXZlLnVudGlsKGFkanVzdGVkRW5kLCBDaHJvbm9Vbml0LlNFQ09ORFMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm9mU2Vjb25kcyhzZWNzLCBuYW5vcyk7XG4gIH07XG5cbiAgRHVyYXRpb24ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICB2YXIgUEFUVEVSTiA9IG5ldyBSZWdFeHAoJyhbLStdPylQKD86KFstK10/WzAtOV0rKUQpPyhUKD86KFstK10/WzAtOV0rKUgpPyg/OihbLStdP1swLTldKylNKT8oPzooWy0rXT9bMC05XSspKD86Wy4sXShbMC05XXswLDl9KSk/Uyk/KT8nLCAnaScpO1xuICAgIHZhciBtYXRjaGVzID0gUEFUVEVSTi5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcbiAgICAgIGlmICgnVCcgPT09IG1hdGNoZXNbM10gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBuZWdhdGUgPSAnLScgPT09IG1hdGNoZXNbMV07XG4gICAgICAgIHZhciBkYXlNYXRjaCA9IG1hdGNoZXNbMl07XG4gICAgICAgIHZhciBob3VyTWF0Y2ggPSBtYXRjaGVzWzRdO1xuICAgICAgICB2YXIgbWludXRlTWF0Y2ggPSBtYXRjaGVzWzVdO1xuICAgICAgICB2YXIgc2Vjb25kTWF0Y2ggPSBtYXRjaGVzWzZdO1xuICAgICAgICB2YXIgZnJhY3Rpb25NYXRjaCA9IG1hdGNoZXNbN107XG5cbiAgICAgICAgaWYgKGRheU1hdGNoICE9IG51bGwgfHwgaG91ck1hdGNoICE9IG51bGwgfHwgbWludXRlTWF0Y2ggIT0gbnVsbCB8fCBzZWNvbmRNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRheXNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgZGF5TWF0Y2gsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVksICdkYXlzJyk7XG5cbiAgICAgICAgICB2YXIgaG91cnNBc1NlY3MgPSBEdXJhdGlvbi5fcGFyc2VOdW1iZXIodGV4dCwgaG91ck1hdGNoLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiwgJ2hvdXJzJyk7XG5cbiAgICAgICAgICB2YXIgbWluc0FzU2VjcyA9IER1cmF0aW9uLl9wYXJzZU51bWJlcih0ZXh0LCBtaW51dGVNYXRjaCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSwgJ21pbnV0ZXMnKTtcblxuICAgICAgICAgIHZhciBzZWNvbmRzID0gRHVyYXRpb24uX3BhcnNlTnVtYmVyKHRleHQsIHNlY29uZE1hdGNoLCAxLCAnc2Vjb25kcycpO1xuXG4gICAgICAgICAgdmFyIG5lZ2F0aXZlU2VjcyA9IHNlY29uZE1hdGNoICE9IG51bGwgJiYgc2Vjb25kTWF0Y2guY2hhckF0KDApID09PSAnLSc7XG5cbiAgICAgICAgICB2YXIgbmFub3MgPSBEdXJhdGlvbi5fcGFyc2VGcmFjdGlvbih0ZXh0LCBmcmFjdGlvbk1hdGNoLCBuZWdhdGl2ZVNlY3MgPyAtMSA6IDEpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlKG5lZ2F0ZSwgZGF5c0FzU2VjcywgaG91cnNBc1NlY3MsIG1pbnNBc1NlY3MsIHNlY29uZHMsIG5hbm9zKTtcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oJ1RleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIER1cmF0aW9uOiBvdmVyZmxvdycsIHRleHQsIDAsIGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbignVGV4dCBjYW5ub3QgYmUgcGFyc2VkIHRvIGEgRHVyYXRpb24nLCB0ZXh0LCAwKTtcbiAgfTtcblxuICBEdXJhdGlvbi5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIodGV4dCwgcGFyc2VkLCBtdWx0aXBsaWVyLCBlcnJvclRleHQpIHtcbiAgICBpZiAocGFyc2VkID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocGFyc2VkWzBdID09PSAnKycpIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVNdWx0aXBseShwYXJzZUZsb2F0KHBhcnNlZCksIG11bHRpcGxpZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbihcIlRleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIER1cmF0aW9uOiBcIiArIGVycm9yVGV4dCwgdGV4dCwgMCwgZXgpO1xuICAgIH1cbiAgfTtcblxuICBEdXJhdGlvbi5fcGFyc2VGcmFjdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZUZyYWN0aW9uKHRleHQsIHBhcnNlZCwgbmVnYXRlKSB7XG4gICAgaWYgKHBhcnNlZCA9PSBudWxsIHx8IHBhcnNlZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHBhcnNlZCA9IChwYXJzZWQgKyBcIjAwMDAwMDAwMFwiKS5zdWJzdHJpbmcoMCwgOSk7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocGFyc2VkKSAqIG5lZ2F0ZTtcbiAgfTtcblxuICBEdXJhdGlvbi5fY3JlYXRlID0gZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZVNlY29uZHNOYW5vcyhhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5fY3JlYXRlTmVnYXRlRGF5c0hvdXJzTWludXRlc1NlY29uZHNOYW5vcyhhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10sIGFyZ3VtZW50c1s0XSwgYXJndW1lbnRzWzVdKTtcbiAgICB9XG4gIH07XG5cbiAgRHVyYXRpb24uX2NyZWF0ZU5lZ2F0ZURheXNIb3Vyc01pbnV0ZXNTZWNvbmRzTmFub3MgPSBmdW5jdGlvbiBfY3JlYXRlTmVnYXRlRGF5c0hvdXJzTWludXRlc1NlY29uZHNOYW5vcyhuZWdhdGUsIGRheXNBc1NlY3MsIGhvdXJzQXNTZWNzLCBtaW5zQXNTZWNzLCBzZWNzLCBuYW5vcykge1xuICAgIHZhciBzZWNvbmRzID0gTWF0aFV0aWwuc2FmZUFkZChkYXlzQXNTZWNzLCBNYXRoVXRpbC5zYWZlQWRkKGhvdXJzQXNTZWNzLCBNYXRoVXRpbC5zYWZlQWRkKG1pbnNBc1NlY3MsIHNlY3MpKSk7XG5cbiAgICBpZiAobmVnYXRlKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKHNlY29uZHMsIG5hbm9zKS5uZWdhdGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNvbmRzLCBuYW5vcyk7XG4gIH07XG5cbiAgRHVyYXRpb24uX2NyZWF0ZVNlY29uZHNOYW5vcyA9IGZ1bmN0aW9uIF9jcmVhdGVTZWNvbmRzTmFub3Moc2Vjb25kcywgbmFub0FkanVzdG1lbnQpIHtcbiAgICBpZiAoc2Vjb25kcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzZWNvbmRzID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub0FkanVzdG1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub0FkanVzdG1lbnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChzZWNvbmRzID09PSAwICYmIG5hbm9BZGp1c3RtZW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uWkVSTztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IER1cmF0aW9uKHNlY29uZHMsIG5hbm9BZGp1c3RtZW50KTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LlNFQ09ORFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5OQU5PUykge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udW5pdHMgPSBmdW5jdGlvbiB1bml0cygpIHtcbiAgICByZXR1cm4gW0Nocm9ub1VuaXQuU0VDT05EUywgQ2hyb25vVW5pdC5OQU5PU107XG4gIH07XG5cbiAgX3Byb3RvLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vjb25kcyA9PT0gMCAmJiB0aGlzLl9uYW5vcyA9PT0gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmRzID0gZnVuY3Rpb24gc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vjb25kcztcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbm9zO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kcyA9IGZ1bmN0aW9uIHdpdGhTZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZShzZWNvbmRzLCB0aGlzLl9uYW5vcyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vcyA9IGZ1bmN0aW9uIHdpdGhOYW5vcyhuYW5vT2ZTZWNvbmQpIHtcbiAgICBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORC5jaGVja1ZhbGlkSW50VmFsdWUobmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gRHVyYXRpb24uX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzRHVyYXRpb24gPSBmdW5jdGlvbiBwbHVzRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICByZXF1aXJlTm9uTnVsbChkdXJhdGlvbiwgJ2R1cmF0aW9uJyk7XG4gICAgcmV0dXJuIHRoaXMucGx1cyhkdXJhdGlvbi5zZWNvbmRzKCksIGR1cmF0aW9uLm5hbm8oKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGR1cmF0aW9uT3JOdW1iZXIsIHVuaXRPck51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVzRHVyYXRpb24oZHVyYXRpb25Pck51bWJlcik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHVuaXRPck51bWJlciBpbnN0YW5jZW9mIFRlbXBvcmFsVW5pdCkge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c0Ftb3VudFVuaXQoZHVyYXRpb25Pck51bWJlciwgdW5pdE9yTnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhkdXJhdGlvbk9yTnVtYmVyLCB1bml0T3JOdW1iZXIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucGx1c0Ftb3VudFVuaXQgPSBmdW5jdGlvbiBwbHVzQW1vdW50VW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuREFZUykge1xuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodW5pdC5pc0R1cmF0aW9uRXN0aW1hdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5pdCBtdXN0IG5vdCBoYXZlIGFuIGVzdGltYXRlZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhbW91bnRUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMTAwMDAwMCAqIDEwMDApICogMTAwMCwgTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCAxMDAwMDAwICogMTAwMCkgKiAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaWxsaXMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHNOYW5vcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkodW5pdC5kdXJhdGlvbigpLnNlY29uZHMoKSwgYW1vdW50VG9BZGQpLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyYXRpb24gPSB1bml0LmR1cmF0aW9uKCkubXVsdGlwbGllZEJ5KGFtb3VudFRvQWRkKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKGR1cmF0aW9uLnNlY29uZHMoKSwgZHVyYXRpb24ubmFubygpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShkYXlzVG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpLCAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0hvdXJzID0gZnVuY3Rpb24gcGx1c0hvdXJzKGhvdXJzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLnNhZmVNdWx0aXBseShob3Vyc1RvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiksIDApO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzTmFub3MoTWF0aFV0aWwuc2FmZU11bHRpcGx5KG1pbnV0ZXNUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSksIDApO1xuICB9O1xuXG4gIF9wcm90by5wbHVzU2Vjb25kcyA9IGZ1bmN0aW9uIHBsdXNTZWNvbmRzKHNlY29uZHNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzTmFub3Moc2Vjb25kc1RvQWRkLCAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbGxpcyA9IGZ1bmN0aW9uIHBsdXNNaWxsaXMobWlsbGlzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKE1hdGhVdGlsLmludERpdihtaWxsaXNUb0FkZCwgMTAwMCksIE1hdGhVdGlsLmludE1vZChtaWxsaXNUb0FkZCwgMTAwMCkgKiAxMDAwMDAwKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kc05hbm9zKDAsIG5hbm9zVG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzU2Vjb25kc05hbm9zID0gZnVuY3Rpb24gcGx1c1NlY29uZHNOYW5vcyhzZWNvbmRzVG9BZGQsIG5hbm9zVG9BZGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChzZWNvbmRzVG9BZGQsICdzZWNvbmRzVG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChuYW5vc1RvQWRkLCAnbmFub3NUb0FkZCcpO1xuXG4gICAgaWYgKHNlY29uZHNUb0FkZCA9PT0gMCAmJiBuYW5vc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZXBvY2hTZWMgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX3NlY29uZHMsIHNlY29uZHNUb0FkZCk7XG4gICAgZXBvY2hTZWMgPSBNYXRoVXRpbC5zYWZlQWRkKGVwb2NoU2VjLCBNYXRoVXRpbC5pbnREaXYobmFub3NUb0FkZCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpKTtcbiAgICBuYW5vc1RvQWRkID0gTWF0aFV0aWwuaW50TW9kKG5hbm9zVG9BZGQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICB2YXIgbmFub0FkanVzdG1lbnQgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX25hbm9zLCBuYW5vc1RvQWRkKTtcbiAgICByZXR1cm4gRHVyYXRpb24ub2ZTZWNvbmRzKGVwb2NoU2VjLCBuYW5vQWRqdXN0bWVudCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzID0gZnVuY3Rpb24gbWludXMoZHVyYXRpb25Pck51bWJlciwgdW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5taW51c0R1cmF0aW9uKGR1cmF0aW9uT3JOdW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5taW51c0Ftb3VudFVuaXQoZHVyYXRpb25Pck51bWJlciwgdW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5taW51c0R1cmF0aW9uID0gZnVuY3Rpb24gbWludXNEdXJhdGlvbihkdXJhdGlvbikge1xuICAgIHJlcXVpcmVOb25OdWxsKGR1cmF0aW9uLCAnZHVyYXRpb24nKTtcbiAgICB2YXIgc2Vjc1RvU3VidHJhY3QgPSBkdXJhdGlvbi5zZWNvbmRzKCk7XG4gICAgdmFyIG5hbm9zVG9TdWJ0cmFjdCA9IGR1cmF0aW9uLm5hbm8oKTtcblxuICAgIGlmIChzZWNzVG9TdWJ0cmFjdCA9PT0gTUlOX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1cyhNQVhfU0FGRV9JTlRFR0VSLCAtbmFub3NUb1N1YnRyYWN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wbHVzKC1zZWNzVG9TdWJ0cmFjdCwgLW5hbm9zVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzQW1vdW50VW5pdCA9IGZ1bmN0aW9uIG1pbnVzQW1vdW50VW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9TdWJ0cmFjdCwgJ2Ftb3VudFRvU3VidHJhY3QnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJldHVybiBhbW91bnRUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzQW1vdW50VW5pdChNQVhfU0FGRV9JTlRFR0VSLCB1bml0KSA6IHRoaXMucGx1c0Ftb3VudFVuaXQoLWFtb3VudFRvU3VidHJhY3QsIHVuaXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5c1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gZGF5c1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNEYXlzKE1BWF9TQUZFX0lOVEVHRVIpIDogdGhpcy5wbHVzRGF5cygtZGF5c1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gaG91cnNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzSG91cnMoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNIb3VycygtaG91cnNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTWludXRlcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c01pbnV0ZXMoLW1pbnV0ZXNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNTZWNvbmRzID0gZnVuY3Rpb24gbWludXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHNlY29uZHNUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzU2Vjb25kcyhNQVhfU0FGRV9JTlRFR0VSKSA6IHRoaXMucGx1c1NlY29uZHMoLXNlY29uZHNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaWxsaXMgPSBmdW5jdGlvbiBtaW51c01pbGxpcyhtaWxsaXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIG1pbGxpc1RvU3VidHJhY3QgPT09IE1JTl9TQUZFX0lOVEVHRVIgPyB0aGlzLnBsdXNNaWxsaXMoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNNaWxsaXMoLW1pbGxpc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c05hbm9zID0gZnVuY3Rpb24gbWludXNOYW5vcyhuYW5vc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gbmFub3NUb1N1YnRyYWN0ID09PSBNSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzTmFub3MoTUFYX1NBRkVfSU5URUdFUikgOiB0aGlzLnBsdXNOYW5vcygtbmFub3NUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbGllZEJ5ID0gZnVuY3Rpb24gbXVsdGlwbGllZEJ5KG11bHRpcGxpY2FuZCkge1xuICAgIGlmIChtdWx0aXBsaWNhbmQgPT09IDApIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5aRVJPO1xuICAgIH1cblxuICAgIGlmIChtdWx0aXBsaWNhbmQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3NlY29uZHMsIG11bHRpcGxpY2FuZCk7XG4gICAgdmFyIG5vcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9uYW5vcywgbXVsdGlwbGljYW5kKTtcbiAgICBzZWNzID0gc2VjcyArIE1hdGhVdGlsLmludERpdihub3MsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICBub3MgPSBNYXRoVXRpbC5pbnRNb2Qobm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuXG4gIF9wcm90by5kaXZpZGVkQnkgPSBmdW5jdGlvbiBkaXZpZGVkQnkoZGl2aXNvcikge1xuICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignQ2Fubm90IGRpdmlkZSBieSB6ZXJvJyk7XG4gICAgfVxuXG4gICAgaWYgKGRpdmlzb3IgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIGRpdmlzb3IpO1xuICAgIHZhciBzZWNzTW9kID0gTWF0aFV0aWwucm91bmREb3duKCh0aGlzLl9zZWNvbmRzIC8gZGl2aXNvciAtIHNlY3MpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHZhciBub3MgPSBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFub3MsIGRpdmlzb3IpO1xuICAgIG5vcyA9IHNlY3NNb2QgKyBub3M7XG4gICAgcmV0dXJuIER1cmF0aW9uLm9mU2Vjb25kcyhzZWNzLCBub3MpO1xuICB9O1xuXG4gIF9wcm90by5uZWdhdGVkID0gZnVuY3Rpb24gbmVnYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsaWVkQnkoLTEpO1xuICB9O1xuXG4gIF9wcm90by5hYnMgPSBmdW5jdGlvbiBhYnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpID8gdGhpcy5uZWdhdGVkKCkgOiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hZGRUbyA9IGZ1bmN0aW9uIGFkZFRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRoaXMuX3NlY29uZHMgIT09IDApIHtcbiAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwucGx1cyh0aGlzLl9zZWNvbmRzLCBDaHJvbm9Vbml0LlNFQ09ORFMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9uYW5vcyAhPT0gMCkge1xuICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMuX25hbm9zLCBDaHJvbm9Vbml0Lk5BTk9TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnN1YnRyYWN0RnJvbSA9IGZ1bmN0aW9uIHN1YnRyYWN0RnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0aGlzLl9zZWNvbmRzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX3NlY29uZHMsIENocm9ub1VuaXQuU0VDT05EUyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25hbm9zICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX25hbm9zLCBDaHJvbm9Vbml0Lk5BTk9TKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnRvRGF5cyA9IGZ1bmN0aW9uIHRvRGF5cygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICB9O1xuXG4gIF9wcm90by50b0hvdXJzID0gZnVuY3Rpb24gdG9Ib3VycygpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcbiAgfTtcblxuICBfcHJvdG8udG9NaW51dGVzID0gZnVuY3Rpb24gdG9NaW51dGVzKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvTWlsbGlzID0gZnVuY3Rpb24gdG9NaWxsaXMoKSB7XG4gICAgdmFyIG1pbGxpcyA9IE1hdGgucm91bmQoTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3NlY29uZHMsIDEwMDApKTtcbiAgICBtaWxsaXMgPSBNYXRoVXRpbC5zYWZlQWRkKG1pbGxpcywgTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCAxMDAwMDAwKSk7XG4gICAgcmV0dXJuIG1pbGxpcztcbiAgfTtcblxuICBfcHJvdG8udG9OYW5vcyA9IGZ1bmN0aW9uIHRvTmFub3MoKSB7XG4gICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsTmFub3MsIHRoaXMuX25hbm9zKTtcbiAgICByZXR1cm4gdG90YWxOYW5vcztcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyRHVyYXRpb24pIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlckR1cmF0aW9uLCAnb3RoZXJEdXJhdGlvbicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlckR1cmF0aW9uLCBEdXJhdGlvbiwgJ290aGVyRHVyYXRpb24nKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fc2Vjb25kcywgb3RoZXJEdXJhdGlvbi5zZWNvbmRzKCkpO1xuXG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbmFub3MgLSBvdGhlckR1cmF0aW9uLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyRHVyYXRpb24pIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXJEdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRHVyYXRpb24gaW5zdGFuY2VvZiBEdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpID09PSBvdGhlckR1cmF0aW9uLnNlY29uZHMoKSAmJiB0aGlzLm5hbm8oKSA9PT0gb3RoZXJEdXJhdGlvbi5uYW5vKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzID09PSBEdXJhdGlvbi5aRVJPKSB7XG4gICAgICByZXR1cm4gJ1BUMFMnO1xuICAgIH1cblxuICAgIHZhciBob3VycyA9IE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgdmFyIG1pbnV0ZXMgPSBNYXRoVXRpbC5pbnREaXYoTWF0aFV0aWwuaW50TW9kKHRoaXMuX3NlY29uZHMsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIHNlY3MgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIHJ2YWwgPSAnUFQnO1xuXG4gICAgaWYgKGhvdXJzICE9PSAwKSB7XG4gICAgICBydmFsICs9IGhvdXJzICsgXCJIXCI7XG4gICAgfVxuXG4gICAgaWYgKG1pbnV0ZXMgIT09IDApIHtcbiAgICAgIHJ2YWwgKz0gbWludXRlcyArIFwiTVwiO1xuICAgIH1cblxuICAgIGlmIChzZWNzID09PSAwICYmIHRoaXMuX25hbm9zID09PSAwICYmIHJ2YWwubGVuZ3RoID4gMikge1xuICAgICAgcmV0dXJuIHJ2YWw7XG4gICAgfVxuXG4gICAgaWYgKHNlY3MgPCAwICYmIHRoaXMuX25hbm9zID4gMCkge1xuICAgICAgaWYgKHNlY3MgPT09IC0xKSB7XG4gICAgICAgIHJ2YWwgKz0gJy0wJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJ2YWwgKz0gc2VjcyArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2YWwgKz0gc2VjcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmFub3MgPiAwKSB7XG4gICAgICBydmFsICs9ICcuJztcbiAgICAgIHZhciBuYW5vU3RyaW5nO1xuXG4gICAgICBpZiAoc2VjcyA8IDApIHtcbiAgICAgICAgbmFub1N0cmluZyA9IFwiXCIgKyAoMiAqIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EIC0gdGhpcy5fbmFub3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFub1N0cmluZyA9IFwiXCIgKyAoTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgKyB0aGlzLl9uYW5vcyk7XG4gICAgICB9XG5cbiAgICAgIG5hbm9TdHJpbmcgPSBuYW5vU3RyaW5nLnNsaWNlKDEsIG5hbm9TdHJpbmcubGVuZ3RoKTtcbiAgICAgIHJ2YWwgKz0gbmFub1N0cmluZztcblxuICAgICAgd2hpbGUgKHJ2YWwuY2hhckF0KHJ2YWwubGVuZ3RoIC0gMSkgPT09ICcwJykge1xuICAgICAgICBydmFsID0gcnZhbC5zbGljZSgwLCBydmFsLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJ2YWwgKz0gJ1MnO1xuICAgIHJldHVybiBydmFsO1xuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gRHVyYXRpb247XG59KFRlbXBvcmFsQW1vdW50KTtcbmZ1bmN0aW9uIF9pbml0JG4oKSB7XG4gIER1cmF0aW9uLlpFUk8gPSBuZXcgRHVyYXRpb24oMCwgMCk7XG59XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UubWQgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBZZWFyQ29uc3RhbnRzID0gZnVuY3Rpb24gWWVhckNvbnN0YW50cygpIHt9O1xuZnVuY3Rpb24gX2luaXQkbSgpIHtcbiAgWWVhckNvbnN0YW50cy5NSU5fVkFMVUUgPSAtOTk5OTk5O1xuICBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSA9IDk5OTk5OTtcbn1cblxudmFyIENocm9ub1VuaXQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsVW5pdCkge1xuICBfaW5oZXJpdHNMb29zZShDaHJvbm9Vbml0LCBfVGVtcG9yYWxVbml0KTtcblxuICBmdW5jdGlvbiBDaHJvbm9Vbml0KG5hbWUsIGVzdGltYXRlZER1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxVbml0LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgX3RoaXMuX2R1cmF0aW9uID0gZXN0aW1hdGVkRHVyYXRpb247XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub1VuaXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uaXNEdXJhdGlvbkVzdGltYXRlZCA9IGZ1bmN0aW9uIGlzRHVyYXRpb25Fc3RpbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEYXRlQmFzZWQoKSB8fCB0aGlzID09PSBDaHJvbm9Vbml0LkZPUkVWRVI7XG4gIH07XG5cbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKENocm9ub1VuaXQuREFZUykgPj0gMCAmJiB0aGlzICE9PSBDaHJvbm9Vbml0LkZPUkVWRVI7XG4gIH07XG5cbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKENocm9ub1VuaXQuREFZUykgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIGlmICh0aGlzID09PSBDaHJvbm9Vbml0LkZPUkVWRVIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGVtcG9yYWwucGx1cygxLCB0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlbXBvcmFsLnBsdXMoLTEsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwsIGFtb3VudCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5wbHVzKGFtb3VudCwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHRlbXBvcmFsMSwgdGVtcG9yYWwyKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsMS51bnRpbCh0ZW1wb3JhbDIsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kdXJhdGlvbigpLmNvbXBhcmVUbyhvdGhlci5kdXJhdGlvbigpKTtcbiAgfTtcblxuICByZXR1cm4gQ2hyb25vVW5pdDtcbn0oVGVtcG9yYWxVbml0KTtcbmZ1bmN0aW9uIF9pbml0JGwoKSB7XG4gIENocm9ub1VuaXQuTkFOT1MgPSBuZXcgQ2hyb25vVW5pdCgnTmFub3MnLCBEdXJhdGlvbi5vZk5hbm9zKDEpKTtcbiAgQ2hyb25vVW5pdC5NSUNST1MgPSBuZXcgQ2hyb25vVW5pdCgnTWljcm9zJywgRHVyYXRpb24ub2ZOYW5vcygxMDAwKSk7XG4gIENocm9ub1VuaXQuTUlMTElTID0gbmV3IENocm9ub1VuaXQoJ01pbGxpcycsIER1cmF0aW9uLm9mTmFub3MoMTAwMDAwMCkpO1xuICBDaHJvbm9Vbml0LlNFQ09ORFMgPSBuZXcgQ2hyb25vVW5pdCgnU2Vjb25kcycsIER1cmF0aW9uLm9mU2Vjb25kcygxKSk7XG4gIENocm9ub1VuaXQuTUlOVVRFUyA9IG5ldyBDaHJvbm9Vbml0KCdNaW51dGVzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDYwKSk7XG4gIENocm9ub1VuaXQuSE9VUlMgPSBuZXcgQ2hyb25vVW5pdCgnSG91cnMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzYwMCkpO1xuICBDaHJvbm9Vbml0LkhBTEZfREFZUyA9IG5ldyBDaHJvbm9Vbml0KCdIYWxmRGF5cycsIER1cmF0aW9uLm9mU2Vjb25kcyg0MzIwMCkpO1xuICBDaHJvbm9Vbml0LkRBWVMgPSBuZXcgQ2hyb25vVW5pdCgnRGF5cycsIER1cmF0aW9uLm9mU2Vjb25kcyg4NjQwMCkpO1xuICBDaHJvbm9Vbml0LldFRUtTID0gbmV3IENocm9ub1VuaXQoJ1dlZWtzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDcgKiA4NjQwMCkpO1xuICBDaHJvbm9Vbml0Lk1PTlRIUyA9IG5ldyBDaHJvbm9Vbml0KCdNb250aHMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgLyAxMikpO1xuICBDaHJvbm9Vbml0LllFQVJTID0gbmV3IENocm9ub1VuaXQoJ1llYXJzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyKSk7XG4gIENocm9ub1VuaXQuREVDQURFUyA9IG5ldyBDaHJvbm9Vbml0KCdEZWNhZGVzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyICogMTApKTtcbiAgQ2hyb25vVW5pdC5DRU5UVVJJRVMgPSBuZXcgQ2hyb25vVW5pdCgnQ2VudHVyaWVzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyICogMTAwKSk7XG4gIENocm9ub1VuaXQuTUlMTEVOTklBID0gbmV3IENocm9ub1VuaXQoJ01pbGxlbm5pYScsIER1cmF0aW9uLm9mU2Vjb25kcygzMTU1Njk1MiAqIDEwMDApKTtcbiAgQ2hyb25vVW5pdC5FUkFTID0gbmV3IENocm9ub1VuaXQoJ0VyYXMnLCBEdXJhdGlvbi5vZlNlY29uZHMoMzE1NTY5NTIgKiAoWWVhckNvbnN0YW50cy5NQVhfVkFMVUUgKyAxKSkpO1xuICBDaHJvbm9Vbml0LkZPUkVWRVIgPSBuZXcgQ2hyb25vVW5pdCgnRm9yZXZlcicsIER1cmF0aW9uLm9mU2Vjb25kcyhNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSLCA5OTk5OTk5OTkpKTtcbn1cblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuXG52YXIgVGVtcG9yYWxGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxGaWVsZCgpIHt9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsRmllbGQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc0RhdGVCYXNlZCA9IGZ1bmN0aW9uIGlzRGF0ZUJhc2VkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNEYXRlQmFzZWQnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ2lzVGltZUJhc2VkJyk7XG4gIH07XG5cbiAgX3Byb3RvLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdiYXNlVW5pdCcpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdyYW5nZVVuaXQnKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3JhbmdlJyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlUmVmaW5lZEJ5ID0gZnVuY3Rpb24gcmFuZ2VSZWZpbmVkQnkodGVtcG9yYWwpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ3JhbmdlUmVmaW5lZEJ5Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdnZXRGcm9tJyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsLCBuZXdWYWx1ZSkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnYWRqdXN0SW50bycpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWRCeScpO1xuICB9O1xuXG4gIF9wcm90by5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGRpc3BsYXlOYW1lKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnZGlzcGxheU5hbWUnKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdlcXVhbHMnKTtcbiAgfTtcblxuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCduYW1lJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsRmllbGQ7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBWYWx1ZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYWx1ZVJhbmdlKG1pblNtYWxsZXN0LCBtaW5MYXJnZXN0LCBtYXhTbWFsbGVzdCwgbWF4TGFyZ2VzdCkge1xuICAgIGFzc2VydCghKG1pblNtYWxsZXN0ID4gbWluTGFyZ2VzdCksIFwiU21hbGxlc3QgbWluaW11bSB2YWx1ZSAnXCIgKyBtaW5TbWFsbGVzdCArIFwiJyBtdXN0IGJlIGxlc3MgdGhhbiBsYXJnZXN0IG1pbmltdW0gdmFsdWUgJ1wiICsgbWluTGFyZ2VzdCArIFwiJ1wiLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIGFzc2VydCghKG1heFNtYWxsZXN0ID4gbWF4TGFyZ2VzdCksIFwiU21hbGxlc3QgbWF4aW11bSB2YWx1ZSAnXCIgKyBtYXhTbWFsbGVzdCArIFwiJyBtdXN0IGJlIGxlc3MgdGhhbiBsYXJnZXN0IG1heGltdW0gdmFsdWUgJ1wiICsgbWF4TGFyZ2VzdCArIFwiJ1wiLCBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24pO1xuICAgIGFzc2VydCghKG1pbkxhcmdlc3QgPiBtYXhMYXJnZXN0KSwgXCJNaW5pbXVtIHZhbHVlICdcIiArIG1pbkxhcmdlc3QgKyBcIicgbXVzdCBiZSBsZXNzIHRoYW4gbWF4aW11bSB2YWx1ZSAnXCIgKyBtYXhMYXJnZXN0ICsgXCInXCIsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgdGhpcy5fbWluU21hbGxlc3QgPSBtaW5TbWFsbGVzdDtcbiAgICB0aGlzLl9taW5MYXJnZXN0ID0gbWluTGFyZ2VzdDtcbiAgICB0aGlzLl9tYXhMYXJnZXN0ID0gbWF4TGFyZ2VzdDtcbiAgICB0aGlzLl9tYXhTbWFsbGVzdCA9IG1heFNtYWxsZXN0O1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFZhbHVlUmFuZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc0ZpeGVkID0gZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluU21hbGxlc3QgPT09IHRoaXMuX21pbkxhcmdlc3QgJiYgdGhpcy5fbWF4U21hbGxlc3QgPT09IHRoaXMuX21heExhcmdlc3Q7XG4gIH07XG5cbiAgX3Byb3RvLm1pbmltdW0gPSBmdW5jdGlvbiBtaW5pbXVtKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdDtcbiAgfTtcblxuICBfcHJvdG8ubGFyZ2VzdE1pbmltdW0gPSBmdW5jdGlvbiBsYXJnZXN0TWluaW11bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluTGFyZ2VzdDtcbiAgfTtcblxuICBfcHJvdG8ubWF4aW11bSA9IGZ1bmN0aW9uIG1heGltdW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heExhcmdlc3Q7XG4gIH07XG5cbiAgX3Byb3RvLnNtYWxsZXN0TWF4aW11bSA9IGZ1bmN0aW9uIHNtYWxsZXN0TWF4aW11bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4U21hbGxlc3Q7XG4gIH07XG5cbiAgX3Byb3RvLmlzVmFsaWRWYWx1ZSA9IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm1pbmltdW0oKSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB0aGlzLm1heGltdW0oKTtcbiAgfTtcblxuICBfcHJvdG8uY2hlY2tWYWxpZFZhbHVlID0gZnVuY3Rpb24gY2hlY2tWYWxpZFZhbHVlKHZhbHVlLCBmaWVsZCkge1xuICAgIHZhciBtc2c7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZFZhbHVlKHZhbHVlKSkge1xuICAgICAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICAgICAgbXNnID0gXCJJbnZhbGlkIHZhbHVlIGZvciBcIiArIGZpZWxkICsgXCIgKHZhbGlkIHZhbHVlcyBcIiArIHRoaXMudG9TdHJpbmcoKSArIFwiKTogXCIgKyB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IFwiSW52YWxpZCB2YWx1ZSAodmFsaWQgdmFsdWVzIFwiICsgdGhpcy50b1N0cmluZygpICsgXCIpOiBcIiArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNzZXJ0KGZhbHNlLCBtc2csIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmNoZWNrVmFsaWRJbnRWYWx1ZSA9IGZ1bmN0aW9uIGNoZWNrVmFsaWRJbnRWYWx1ZSh2YWx1ZSwgZmllbGQpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkSW50VmFsdWUodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBpbnQgdmFsdWUgZm9yIFwiICsgZmllbGQgKyBcIjogXCIgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBpc1ZhbGlkSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ludFZhbHVlKCkgJiYgdGhpcy5pc1ZhbGlkVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5pc0ludFZhbHVlID0gZnVuY3Rpb24gaXNJbnRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5pbXVtKCkgPj0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiAmJiB0aGlzLm1heGltdW0oKSA8PSBNYXRoVXRpbC5NQVhfU0FGRV9JTlRFR0VSO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFZhbHVlUmFuZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5TbWFsbGVzdCA9PT0gb3RoZXIuX21pblNtYWxsZXN0ICYmIHRoaXMuX21pbkxhcmdlc3QgPT09IG90aGVyLl9taW5MYXJnZXN0ICYmIHRoaXMuX21heFNtYWxsZXN0ID09PSBvdGhlci5fbWF4U21hbGxlc3QgJiYgdGhpcy5fbWF4TGFyZ2VzdCA9PT0gb3RoZXIuX21heExhcmdlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5oYXNoQ29kZSh0aGlzLl9taW5TbWFsbGVzdCwgdGhpcy5fbWluTGFyZ2VzdCwgdGhpcy5fbWF4U21hbGxlc3QsIHRoaXMuX21heExhcmdlc3QpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBzdHIgPSB0aGlzLm1pbmltdW0oKSArICh0aGlzLm1pbmltdW0oKSAhPT0gdGhpcy5sYXJnZXN0TWluaW11bSgpID8gXCIvXCIgKyB0aGlzLmxhcmdlc3RNaW5pbXVtKCkgOiAnJyk7XG4gICAgc3RyICs9ICcgLSAnO1xuICAgIHN0ciArPSB0aGlzLnNtYWxsZXN0TWF4aW11bSgpICsgKHRoaXMuc21hbGxlc3RNYXhpbXVtKCkgIT09IHRoaXMubWF4aW11bSgpID8gXCIvXCIgKyB0aGlzLm1heGltdW0oKSA6ICcnKTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIFZhbHVlUmFuZ2Uub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJhbmdlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbHVlUmFuZ2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVSYW5nZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBcIiArIGFyZ3VtZW50cy5sZW5ndGgsIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBWYWx1ZVJhbmdlO1xufSgpO1xuXG52YXIgQ2hyb25vRmllbGQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsRmllbGQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vRmllbGQsIF9UZW1wb3JhbEZpZWxkKTtcblxuICBDaHJvbm9GaWVsZC5ieU5hbWUgPSBmdW5jdGlvbiBieU5hbWUoZmllbGROYW1lKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKENocm9ub0ZpZWxkW3Byb3BdKSB7XG4gICAgICAgIGlmIChDaHJvbm9GaWVsZFtwcm9wXSBpbnN0YW5jZW9mIENocm9ub0ZpZWxkICYmIENocm9ub0ZpZWxkW3Byb3BdLm5hbWUoKSA9PT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIENocm9ub0ZpZWxkW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENocm9ub0ZpZWxkKG5hbWUsIGJhc2VVbml0LCByYW5nZVVuaXQsIHJhbmdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxGaWVsZC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIF90aGlzLl9iYXNlVW5pdCA9IGJhc2VVbml0O1xuICAgIF90aGlzLl9yYW5nZVVuaXQgPSByYW5nZVVuaXQ7XG4gICAgX3RoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub0ZpZWxkLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubmFtZSA9IGZ1bmN0aW9uIG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VVbml0O1xuICB9O1xuXG4gIF9wcm90by5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhbmdlVW5pdDtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8uY2hlY2tWYWxpZFZhbHVlID0gZnVuY3Rpb24gY2hlY2tWYWxpZFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUodmFsdWUsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5jaGVja1ZhbGlkSW50VmFsdWUgPSBmdW5jdGlvbiBjaGVja1ZhbGlkSW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZSh2YWx1ZSwgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgdmFyIGRhdGVCYXNlZCA9IHRoaXMgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fTU9OVEggfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5FUE9DSF9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuWUVBUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5FUkE7XG4gICAgcmV0dXJuIGRhdGVCYXNlZDtcbiAgfTtcblxuICBfcHJvdG8uaXNUaW1lQmFzZWQgPSBmdW5jdGlvbiBpc1RpbWVCYXNlZCgpIHtcbiAgICB2YXIgdGltZUJhc2VkID0gdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZIHx8IHRoaXMgPT09IENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSB8fCB0aGlzID09PSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0gfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkgfHwgdGhpcyA9PT0gQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk7XG4gICAgcmV0dXJuIHRpbWVCYXNlZDtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5yYW5nZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RnJvbSA9IGZ1bmN0aW9uIGdldEZyb20odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuZ2V0TG9uZyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lKCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgodGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gQ2hyb25vRmllbGQ7XG59KFRlbXBvcmFsRmllbGQpO1xuZnVuY3Rpb24gX2luaXQkaygpIHtcbiAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgPSBuZXcgQ2hyb25vRmllbGQoJ05hbm9PZlNlY29uZCcsIENocm9ub1VuaXQuTkFOT1MsIENocm9ub1VuaXQuU0VDT05EUywgVmFsdWVSYW5nZS5vZigwLCA5OTk5OTk5OTkpKTtcbiAgQ2hyb25vRmllbGQuTkFOT19PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ05hbm9PZkRheScsIENocm9ub1VuaXQuTkFOT1MsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCA4NjQwMCAqIDEwMDAwMDAwMDAgLSAxKSk7XG4gIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCA9IG5ldyBDaHJvbm9GaWVsZCgnTWljcm9PZlNlY29uZCcsIENocm9ub1VuaXQuTUlDUk9TLCBDaHJvbm9Vbml0LlNFQ09ORFMsIFZhbHVlUmFuZ2Uub2YoMCwgOTk5OTk5KSk7XG4gIENocm9ub0ZpZWxkLk1JQ1JPX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnTWljcm9PZkRheScsIENocm9ub1VuaXQuTUlDUk9TLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgODY0MDAgKiAxMDAwMDAwIC0gMSkpO1xuICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQgPSBuZXcgQ2hyb25vRmllbGQoJ01pbGxpT2ZTZWNvbmQnLCBDaHJvbm9Vbml0Lk1JTExJUywgQ2hyb25vVW5pdC5TRUNPTkRTLCBWYWx1ZVJhbmdlLm9mKDAsIDk5OSkpO1xuICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ01pbGxpT2ZEYXknLCBDaHJvbm9Vbml0Lk1JTExJUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDg2NDAwICogMTAwMCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSA9IG5ldyBDaHJvbm9GaWVsZCgnU2Vjb25kT2ZNaW51dGUnLCBDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuTUlOVVRFUywgVmFsdWVSYW5nZS5vZigwLCA1OSkpO1xuICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdTZWNvbmRPZkRheScsIENocm9ub1VuaXQuU0VDT05EUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDg2NDAwIC0gMSkpO1xuICBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiA9IG5ldyBDaHJvbm9GaWVsZCgnTWludXRlT2ZIb3VyJywgQ2hyb25vVW5pdC5NSU5VVEVTLCBDaHJvbm9Vbml0LkhPVVJTLCBWYWx1ZVJhbmdlLm9mKDAsIDU5KSk7XG4gIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkgPSBuZXcgQ2hyb25vRmllbGQoJ01pbnV0ZU9mRGF5JywgQ2hyb25vVW5pdC5NSU5VVEVTLCBDaHJvbm9Vbml0LkRBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgMjQgKiA2MCAtIDEpKTtcbiAgQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNID0gbmV3IENocm9ub0ZpZWxkKCdIb3VyT2ZBbVBtJywgQ2hyb25vVW5pdC5IT1VSUywgQ2hyb25vVW5pdC5IQUxGX0RBWVMsIFZhbHVlUmFuZ2Uub2YoMCwgMTEpKTtcbiAgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNID0gbmV3IENocm9ub0ZpZWxkKCdDbG9ja0hvdXJPZkFtUG0nLCBDaHJvbm9Vbml0LkhPVVJTLCBDaHJvbm9Vbml0LkhBTEZfREFZUywgVmFsdWVSYW5nZS5vZigxLCAxMikpO1xuICBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnSG91ck9mRGF5JywgQ2hyb25vVW5pdC5IT1VSUywgQ2hyb25vVW5pdC5EQVlTLCBWYWx1ZVJhbmdlLm9mKDAsIDIzKSk7XG4gIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZID0gbmV3IENocm9ub0ZpZWxkKCdDbG9ja0hvdXJPZkRheScsIENocm9ub1VuaXQuSE9VUlMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigxLCAyNCkpO1xuICBDaHJvbm9GaWVsZC5BTVBNX09GX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnQW1QbU9mRGF5JywgQ2hyb25vVW5pdC5IQUxGX0RBWVMsIENocm9ub1VuaXQuREFZUywgVmFsdWVSYW5nZS5vZigwLCAxKSk7XG4gIENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLID0gbmV3IENocm9ub0ZpZWxkKCdEYXlPZldlZWsnLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuV0VFS1MsIFZhbHVlUmFuZ2Uub2YoMSwgNykpO1xuICBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkRGF5T2ZXZWVrSW5Nb250aCcsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5XRUVLUywgVmFsdWVSYW5nZS5vZigxLCA3KSk7XG4gIENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnQWxpZ25lZERheU9mV2Vla0luWWVhcicsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5XRUVLUywgVmFsdWVSYW5nZS5vZigxLCA3KSk7XG4gIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCA9IG5ldyBDaHJvbm9GaWVsZCgnRGF5T2ZNb250aCcsIENocm9ub1VuaXQuREFZUywgQ2hyb25vVW5pdC5NT05USFMsIFZhbHVlUmFuZ2Uub2YoMSwgMjgsIDMxKSwgJ2RheScpO1xuICBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnRGF5T2ZZZWFyJywgQ2hyb25vVW5pdC5EQVlTLCBDaHJvbm9Vbml0LllFQVJTLCBWYWx1ZVJhbmdlLm9mKDEsIDM2NSwgMzY2KSk7XG4gIENocm9ub0ZpZWxkLkVQT0NIX0RBWSA9IG5ldyBDaHJvbm9GaWVsZCgnRXBvY2hEYXknLCBDaHJvbm9Vbml0LkRBWVMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihNYXRoLmZsb29yKFllYXJDb25zdGFudHMuTUlOX1ZBTFVFICogMzY1LjI1KSwgTWF0aC5mbG9vcihZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSAqIDM2NS4yNSkpKTtcbiAgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX01PTlRIID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkV2Vla09mTW9udGgnLCBDaHJvbm9Vbml0LldFRUtTLCBDaHJvbm9Vbml0Lk1PTlRIUywgVmFsdWVSYW5nZS5vZigxLCA0LCA1KSk7XG4gIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSID0gbmV3IENocm9ub0ZpZWxkKCdBbGlnbmVkV2Vla09mWWVhcicsIENocm9ub1VuaXQuV0VFS1MsIENocm9ub1VuaXQuWUVBUlMsIFZhbHVlUmFuZ2Uub2YoMSwgNTMpKTtcbiAgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiA9IG5ldyBDaHJvbm9GaWVsZCgnTW9udGhPZlllYXInLCBDaHJvbm9Vbml0Lk1PTlRIUywgQ2hyb25vVW5pdC5ZRUFSUywgVmFsdWVSYW5nZS5vZigxLCAxMiksICdtb250aCcpO1xuICBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEggPSBuZXcgQ2hyb25vRmllbGQoJ1Byb2xlcHRpY01vbnRoJywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihZZWFyQ29uc3RhbnRzLk1JTl9WQUxVRSAqIDEyLCBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSAqIDEyICsgMTEpKTtcbiAgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgPSBuZXcgQ2hyb25vRmllbGQoJ1llYXJPZkVyYScsIENocm9ub1VuaXQuWUVBUlMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZigxLCBZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSwgWWVhckNvbnN0YW50cy5NQVhfVkFMVUUgKyAxKSk7XG4gIENocm9ub0ZpZWxkLllFQVIgPSBuZXcgQ2hyb25vRmllbGQoJ1llYXInLCBDaHJvbm9Vbml0LllFQVJTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoWWVhckNvbnN0YW50cy5NSU5fVkFMVUUsIFllYXJDb25zdGFudHMuTUFYX1ZBTFVFKSwgJ3llYXInKTtcbiAgQ2hyb25vRmllbGQuRVJBID0gbmV3IENocm9ub0ZpZWxkKCdFcmEnLCBDaHJvbm9Vbml0LkVSQVMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZigwLCAxKSk7XG4gIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyA9IG5ldyBDaHJvbm9GaWVsZCgnSW5zdGFudFNlY29uZHMnLCBDaHJvbm9Vbml0LlNFQ09ORFMsIENocm9ub1VuaXQuRk9SRVZFUiwgVmFsdWVSYW5nZS5vZihNSU5fU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKSk7XG4gIENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTID0gbmV3IENocm9ub0ZpZWxkKCdPZmZzZXRTZWNvbmRzJywgQ2hyb25vVW5pdC5TRUNPTkRTLCBDaHJvbm9Vbml0LkZPUkVWRVIsIFZhbHVlUmFuZ2Uub2YoLTE4ICogMzYwMCwgMTggKiAzNjAwKSk7XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRlbXBvcmFsUXVlcmllcygpIHt9XG5cbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCA9IGZ1bmN0aW9uIHpvbmVJZCgpIHtcbiAgICByZXR1cm4gVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQ7XG4gIH07XG5cbiAgVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuQ0hST05PO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24gPSBmdW5jdGlvbiBwcmVjaXNpb24oKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5QUkVDSVNJT047XG4gIH07XG5cbiAgVGVtcG9yYWxRdWVyaWVzLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuWk9ORTtcbiAgfTtcblxuICBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiBUZW1wb3JhbFF1ZXJpZXMuT0ZGU0VUO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUgPSBmdW5jdGlvbiBsb2NhbERhdGUoKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9EQVRFO1xuICB9O1xuXG4gIFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUgPSBmdW5jdGlvbiBsb2NhbFRpbWUoKSB7XG4gICAgcmV0dXJuIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9USU1FO1xuICB9O1xuXG4gIHJldHVybiBUZW1wb3JhbFF1ZXJpZXM7XG59KCk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEFjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFjY2Vzc29yKCkge31cblxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnZ2V0TG9uZycpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWQnKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxBY2Nlc3Nvcjtcbn0oKTtcblxudmFyIFRlbXBvcmFsUXVlcnkgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGVtcG9yYWxRdWVyeSwgX0VudW0pO1xuXG4gIGZ1bmN0aW9uIFRlbXBvcmFsUXVlcnkoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUZW1wb3JhbFF1ZXJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucXVlcnlGcm9tID0gZnVuY3Rpb24gcXVlcnlGcm9tKHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdxdWVyeUZyb20nKTtcbiAgfTtcblxuICByZXR1cm4gVGVtcG9yYWxRdWVyeTtcbn0oRW51bSk7XG5mdW5jdGlvbiBjcmVhdGVUZW1wb3JhbFF1ZXJ5KG5hbWUsIHF1ZXJ5RnJvbUZ1bmN0aW9uKSB7XG4gIHZhciBFeHRlbmRlZFRlbXBvcmFsUXVlcnkgPSBmdW5jdGlvbiAoX1RlbXBvcmFsUXVlcnkpIHtcbiAgICBfaW5oZXJpdHNMb29zZShFeHRlbmRlZFRlbXBvcmFsUXVlcnksIF9UZW1wb3JhbFF1ZXJ5KTtcblxuICAgIGZ1bmN0aW9uIEV4dGVuZGVkVGVtcG9yYWxRdWVyeSgpIHtcbiAgICAgIHJldHVybiBfVGVtcG9yYWxRdWVyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIEV4dGVuZGVkVGVtcG9yYWxRdWVyeTtcbiAgfShUZW1wb3JhbFF1ZXJ5KTtcblxuICBFeHRlbmRlZFRlbXBvcmFsUXVlcnkucHJvdG90eXBlLnF1ZXJ5RnJvbSA9IHF1ZXJ5RnJvbUZ1bmN0aW9uO1xuICByZXR1cm4gbmV3IEV4dGVuZGVkVGVtcG9yYWxRdWVyeShuYW1lKTtcbn1cblxudmFyIERheU9mV2VlayA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShEYXlPZldlZWssIF9UZW1wb3JhbEFjY2Vzc29yKTtcblxuICBmdW5jdGlvbiBEYXlPZldlZWsob3JkaW5hbCwgbmFtZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsQWNjZXNzb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERheU9mV2Vlay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9yZGluYWwgPSBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsO1xuICB9O1xuXG4gIF9wcm90by5uYW1lID0gZnVuY3Rpb24gbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfTtcblxuICBEYXlPZldlZWsudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBFTlVNUy5zbGljZSgpO1xuICB9O1xuXG4gIERheU9mV2Vlay52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZihuYW1lKSB7XG4gICAgdmFyIG9yZGluYWwgPSAwO1xuXG4gICAgZm9yIChvcmRpbmFsOyBvcmRpbmFsIDwgRU5VTVMubGVuZ3RoOyBvcmRpbmFsKyspIHtcbiAgICAgIGlmIChFTlVNU1tvcmRpbmFsXS5uYW1lKCkgPT09IG5hbWUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIERheU9mV2Vlay5vZihvcmRpbmFsICsgMSk7XG4gIH07XG5cbiAgRGF5T2ZXZWVrLm9mID0gZnVuY3Rpb24gb2YoZGF5T2ZXZWVrKSB7XG4gICAgaWYgKGRheU9mV2VlayA8IDEgfHwgZGF5T2ZXZWVrID4gNykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZSBmb3IgRGF5T2ZXZWVrOiBcIiArIGRheU9mV2Vlayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEVOVU1TW2RheU9mV2VlayAtIDFdO1xuICB9O1xuXG4gIERheU9mV2Vlay5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIGFzc2VydCh0ZW1wb3JhbCAhPSBudWxsLCAndGVtcG9yYWwnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBEYXlPZldlZWspIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIERheU9mV2Vlay5vZih0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRGF0ZVRpbWVFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBEYXlPZldlZWsgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJyksIGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udmFsdWUgPSBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbCArIDE7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoc3R5bGUsIGxvY2FsZSkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQgeWV0IScpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZCA9PT0gQ2hyb25vRmllbGQuREFZX09GX1dFRUs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkICE9IG51bGwgJiYgZmllbGQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuREFZX09GX1dFRUspIHtcbiAgICAgIHJldHVybiBmaWVsZC5yYW5nZSgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSykge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yYW5nZShmaWVsZCkuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuZ2V0TG9uZyhmaWVsZCksIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzID0gZnVuY3Rpb24gcGx1cyhkYXlzKSB7XG4gICAgdmFyIGFtb3VudCA9IE1hdGhVdGlsLmZsb29yTW9kKGRheXMsIDcpO1xuICAgIHJldHVybiBFTlVNU1tNYXRoVXRpbC5mbG9vck1vZCh0aGlzLl9vcmRpbmFsICsgKGFtb3VudCArIDcpLCA3KV07XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzID0gZnVuY3Rpb24gbWludXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLnBsdXMoLTEgKiBNYXRoVXRpbC5mbG9vck1vZChkYXlzLCA3KSk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5EQVlTO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYXNzZXJ0KF9xdWVyeSAhPSBudWxsLCAncXVlcnknLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLCB0aGlzLnZhbHVlKCkpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIERheU9mV2VlaywgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX29yZGluYWwgLSBvdGhlci5fb3JkaW5hbDtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIERheU9mV2Vlaztcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgRU5VTVM7XG5mdW5jdGlvbiBfaW5pdCRqKCkge1xuICBEYXlPZldlZWsuTU9OREFZID0gbmV3IERheU9mV2VlaygwLCAnTU9OREFZJyk7XG4gIERheU9mV2Vlay5UVUVTREFZID0gbmV3IERheU9mV2VlaygxLCAnVFVFU0RBWScpO1xuICBEYXlPZldlZWsuV0VETkVTREFZID0gbmV3IERheU9mV2VlaygyLCAnV0VETkVTREFZJyk7XG4gIERheU9mV2Vlay5USFVSU0RBWSA9IG5ldyBEYXlPZldlZWsoMywgJ1RIVVJTREFZJyk7XG4gIERheU9mV2Vlay5GUklEQVkgPSBuZXcgRGF5T2ZXZWVrKDQsICdGUklEQVknKTtcbiAgRGF5T2ZXZWVrLlNBVFVSREFZID0gbmV3IERheU9mV2Vlayg1LCAnU0FUVVJEQVknKTtcbiAgRGF5T2ZXZWVrLlNVTkRBWSA9IG5ldyBEYXlPZldlZWsoNiwgJ1NVTkRBWScpO1xuICBEYXlPZldlZWsuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0RheU9mV2Vlay5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIERheU9mV2Vlay5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG4gIEVOVU1TID0gW0RheU9mV2Vlay5NT05EQVksIERheU9mV2Vlay5UVUVTREFZLCBEYXlPZldlZWsuV0VETkVTREFZLCBEYXlPZldlZWsuVEhVUlNEQVksIERheU9mV2Vlay5GUklEQVksIERheU9mV2Vlay5TQVRVUkRBWSwgRGF5T2ZXZWVrLlNVTkRBWV07XG59XG5cbnZhciBNb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShNb250aCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIGZ1bmN0aW9uIE1vbnRoKHZhbHVlLCBuYW1lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBY2Nlc3Nvci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3ZhbHVlID0gTWF0aFV0aWwuc2FmZVRvSW50KHZhbHVlKTtcbiAgICBfdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1vbnRoLnByb3RvdHlwZTtcblxuICBfcHJvdG8udmFsdWUgPSBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLm9yZGluYWwgPSBmdW5jdGlvbiBvcmRpbmFsKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSAtIDE7XG4gIH07XG5cbiAgX3Byb3RvLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9O1xuXG4gIF9wcm90by5kaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIGRpc3BsYXlOYW1lKHN0eWxlLCBsb2NhbGUpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkIHlldCEnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGlmIChudWxsID09PSBmaWVsZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkICE9IG51bGwgJiYgZmllbGQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1cyA9IGZ1bmN0aW9uIHBsdXMobW9udGhzKSB7XG4gICAgdmFyIGFtb3VudCA9IE1hdGhVdGlsLmludE1vZChtb250aHMsIDEyKSArIDEyO1xuICAgIHZhciBuZXdNb250aFZhbCA9IE1hdGhVdGlsLmludE1vZCh0aGlzLnZhbHVlKCkgKyBhbW91bnQsIDEyKTtcbiAgICBuZXdNb250aFZhbCA9IG5ld01vbnRoVmFsID09PSAwID8gMTIgOiBuZXdNb250aFZhbDtcbiAgICByZXR1cm4gTW9udGgub2YobmV3TW9udGhWYWwpO1xuICB9O1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLnBsdXMoLTEgKiBNYXRoVXRpbC5pbnRNb2QobW9udGhzLCAxMikpO1xuICB9O1xuXG4gIF9wcm90by5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgobGVhcFllYXIpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICAgIHJldHVybiBsZWFwWWVhciA/IDI5IDogMjg7XG5cbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICBjYXNlIE1vbnRoLlNFUFRFTUJFUjpcbiAgICAgIGNhc2UgTW9udGguTk9WRU1CRVI6XG4gICAgICAgIHJldHVybiAzMDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubWluTGVuZ3RoID0gZnVuY3Rpb24gbWluTGVuZ3RoKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBNb250aC5GRUJSVUFSWTpcbiAgICAgICAgcmV0dXJuIDI4O1xuXG4gICAgICBjYXNlIE1vbnRoLkFQUklMOlxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gMzA7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAzMTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm1heExlbmd0aCA9IGZ1bmN0aW9uIG1heExlbmd0aCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICAgIHJldHVybiAyOTtcblxuICAgICAgY2FzZSBNb250aC5BUFJJTDpcbiAgICAgIGNhc2UgTW9udGguSlVORTpcbiAgICAgIGNhc2UgTW9udGguU0VQVEVNQkVSOlxuICAgICAgY2FzZSBNb250aC5OT1ZFTUJFUjpcbiAgICAgICAgcmV0dXJuIDMwO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5maXJzdERheU9mWWVhciA9IGZ1bmN0aW9uIGZpcnN0RGF5T2ZZZWFyKGxlYXBZZWFyKSB7XG4gICAgdmFyIGxlYXAgPSBsZWFwWWVhciA/IDEgOiAwO1xuXG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIE1vbnRoLkpBTlVBUlk6XG4gICAgICAgIHJldHVybiAxO1xuXG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgICByZXR1cm4gMzI7XG5cbiAgICAgIGNhc2UgTW9udGguTUFSQ0g6XG4gICAgICAgIHJldHVybiA2MCArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICAgIHJldHVybiA5MSArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguTUFZOlxuICAgICAgICByZXR1cm4gMTIxICsgbGVhcDtcblxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgICByZXR1cm4gMTUyICsgbGVhcDtcblxuICAgICAgY2FzZSBNb250aC5KVUxZOlxuICAgICAgICByZXR1cm4gMTgyICsgbGVhcDtcblxuICAgICAgY2FzZSBNb250aC5BVUdVU1Q6XG4gICAgICAgIHJldHVybiAyMTMgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLlNFUFRFTUJFUjpcbiAgICAgICAgcmV0dXJuIDI0NCArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguT0NUT0JFUjpcbiAgICAgICAgcmV0dXJuIDI3NCArIGxlYXA7XG5cbiAgICAgIGNhc2UgTW9udGguTk9WRU1CRVI6XG4gICAgICAgIHJldHVybiAzMDUgKyBsZWFwO1xuXG4gICAgICBjYXNlIE1vbnRoLkRFQ0VNQkVSOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDMzNSArIGxlYXA7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5maXJzdE1vbnRoT2ZRdWFydGVyID0gZnVuY3Rpb24gZmlyc3RNb250aE9mUXVhcnRlcigpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgTW9udGguSkFOVUFSWTpcbiAgICAgIGNhc2UgTW9udGguRkVCUlVBUlk6XG4gICAgICBjYXNlIE1vbnRoLk1BUkNIOlxuICAgICAgICByZXR1cm4gTW9udGguSkFOVUFSWTtcblxuICAgICAgY2FzZSBNb250aC5BUFJJTDpcbiAgICAgIGNhc2UgTW9udGguTUFZOlxuICAgICAgY2FzZSBNb250aC5KVU5FOlxuICAgICAgICByZXR1cm4gTW9udGguQVBSSUw7XG5cbiAgICAgIGNhc2UgTW9udGguSlVMWTpcbiAgICAgIGNhc2UgTW9udGguQVVHVVNUOlxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICAgIHJldHVybiBNb250aC5KVUxZO1xuXG4gICAgICBjYXNlIE1vbnRoLk9DVE9CRVI6XG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgY2FzZSBNb250aC5ERUNFTUJFUjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBNb250aC5PQ1RPQkVSO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBhc3NlcnQoX3F1ZXJ5ICE9IG51bGwsICdxdWVyeSgpIHBhcmFtZXRlciBtdXN0IG5vdCBiZSBudWxsJywgRGF0ZVRpbWVFeGNlcHRpb24pO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTU9OVEhTO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBNb250aC5KQU5VQVJZOlxuICAgICAgICByZXR1cm4gJ0pBTlVBUlknO1xuXG4gICAgICBjYXNlIE1vbnRoLkZFQlJVQVJZOlxuICAgICAgICByZXR1cm4gJ0ZFQlJVQVJZJztcblxuICAgICAgY2FzZSBNb250aC5NQVJDSDpcbiAgICAgICAgcmV0dXJuICdNQVJDSCc7XG5cbiAgICAgIGNhc2UgTW9udGguQVBSSUw6XG4gICAgICAgIHJldHVybiAnQVBSSUwnO1xuXG4gICAgICBjYXNlIE1vbnRoLk1BWTpcbiAgICAgICAgcmV0dXJuICdNQVknO1xuXG4gICAgICBjYXNlIE1vbnRoLkpVTkU6XG4gICAgICAgIHJldHVybiAnSlVORSc7XG5cbiAgICAgIGNhc2UgTW9udGguSlVMWTpcbiAgICAgICAgcmV0dXJuICdKVUxZJztcblxuICAgICAgY2FzZSBNb250aC5BVUdVU1Q6XG4gICAgICAgIHJldHVybiAnQVVHVVNUJztcblxuICAgICAgY2FzZSBNb250aC5TRVBURU1CRVI6XG4gICAgICAgIHJldHVybiAnU0VQVEVNQkVSJztcblxuICAgICAgY2FzZSBNb250aC5PQ1RPQkVSOlxuICAgICAgICByZXR1cm4gJ09DVE9CRVInO1xuXG4gICAgICBjYXNlIE1vbnRoLk5PVkVNQkVSOlxuICAgICAgICByZXR1cm4gJ05PVkVNQkVSJztcblxuICAgICAgY2FzZSBNb250aC5ERUNFTUJFUjpcbiAgICAgICAgcmV0dXJuICdERUNFTUJFUic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcInVua25vd24gTW9udGgsIHZhbHVlOiBcIiArIHRoaXMudmFsdWUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIHRoaXMudmFsdWUoKSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE1vbnRoLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgLSBvdGhlci5fdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzID09PSBvdGhlcjtcbiAgfTtcblxuICBNb250aC52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZihuYW1lKSB7XG4gICAgdmFyIG9yZGluYWwgPSAwO1xuXG4gICAgZm9yIChvcmRpbmFsOyBvcmRpbmFsIDwgTU9OVEhTLmxlbmd0aDsgb3JkaW5hbCsrKSB7XG4gICAgICBpZiAoTU9OVEhTW29yZGluYWxdLm5hbWUoKSA9PT0gbmFtZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gTW9udGgub2Yob3JkaW5hbCArIDEpO1xuICB9O1xuXG4gIE1vbnRoLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgICByZXR1cm4gTU9OVEhTLnNsaWNlKCk7XG4gIH07XG5cbiAgTW9udGgub2YgPSBmdW5jdGlvbiBvZihtb250aCkge1xuICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikge1xuICAgICAgYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgdmFsdWUgZm9yIE1vbnRoT2ZZZWFyOiBcIiArIG1vbnRoLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1PTlRIU1ttb250aCAtIDFdO1xuICB9O1xuXG4gIE1vbnRoLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTW9udGgpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIE1vbnRoLm9mKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gTW9udGggZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIgb2YgdHlwZSBcIiArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSwgZXgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTW9udGg7XG59KFRlbXBvcmFsQWNjZXNzb3IpO1xudmFyIE1PTlRIUztcbmZ1bmN0aW9uIF9pbml0JGkoKSB7XG4gIE1vbnRoLkpBTlVBUlkgPSBuZXcgTW9udGgoMSwgJ0pBTlVBUlknKTtcbiAgTW9udGguRkVCUlVBUlkgPSBuZXcgTW9udGgoMiwgJ0ZFQlJVQVJZJyk7XG4gIE1vbnRoLk1BUkNIID0gbmV3IE1vbnRoKDMsICdNQVJDSCcpO1xuICBNb250aC5BUFJJTCA9IG5ldyBNb250aCg0LCAnQVBSSUwnKTtcbiAgTW9udGguTUFZID0gbmV3IE1vbnRoKDUsICdNQVknKTtcbiAgTW9udGguSlVORSA9IG5ldyBNb250aCg2LCAnSlVORScpO1xuICBNb250aC5KVUxZID0gbmV3IE1vbnRoKDcsICdKVUxZJyk7XG4gIE1vbnRoLkFVR1VTVCA9IG5ldyBNb250aCg4LCAnQVVHVVNUJyk7XG4gIE1vbnRoLlNFUFRFTUJFUiA9IG5ldyBNb250aCg5LCAnU0VQVEVNQkVSJyk7XG4gIE1vbnRoLk9DVE9CRVIgPSBuZXcgTW9udGgoMTAsICdPQ1RPQkVSJyk7XG4gIE1vbnRoLk5PVkVNQkVSID0gbmV3IE1vbnRoKDExLCAnTk9WRU1CRVInKTtcbiAgTW9udGguREVDRU1CRVIgPSBuZXcgTW9udGgoMTIsICdERUNFTUJFUicpO1xuICBNT05USFMgPSBbTW9udGguSkFOVUFSWSwgTW9udGguRkVCUlVBUlksIE1vbnRoLk1BUkNILCBNb250aC5BUFJJTCwgTW9udGguTUFZLCBNb250aC5KVU5FLCBNb250aC5KVUxZLCBNb250aC5BVUdVU1QsIE1vbnRoLlNFUFRFTUJFUiwgTW9udGguT0NUT0JFUiwgTW9udGguTk9WRU1CRVIsIE1vbnRoLkRFQ0VNQkVSXTtcbn1cblxudmFyIFBBVFRFUk4gPSAvKFstK10/KVAoPzooWy0rXT9bMC05XSspWSk/KD86KFstK10/WzAtOV0rKU0pPyg/OihbLStdP1swLTldKylXKT8oPzooWy0rXT9bMC05XSspRCk/LztcbnZhciBQZXJpb2QgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQW1vdW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFBlcmlvZCwgX1RlbXBvcmFsQW1vdW50KTtcblxuICBmdW5jdGlvbiBQZXJpb2QoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsQW1vdW50LmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIHZhciBfeWVhcnMgPSBNYXRoVXRpbC5zYWZlVG9JbnQoeWVhcnMpO1xuXG4gICAgdmFyIF9tb250aHMgPSBNYXRoVXRpbC5zYWZlVG9JbnQobW9udGhzKTtcblxuICAgIHZhciBfZGF5cyA9IE1hdGhVdGlsLnNhZmVUb0ludChkYXlzKTtcblxuICAgIGlmIChfeWVhcnMgPT09IDAgJiYgX21vbnRocyA9PT0gMCAmJiBfZGF5cyA9PT0gMCkge1xuICAgICAgaWYgKCFQZXJpb2QuWkVSTykge1xuICAgICAgICBfdGhpcy5feWVhcnMgPSBfeWVhcnM7XG4gICAgICAgIF90aGlzLl9tb250aHMgPSBfbW9udGhzO1xuICAgICAgICBfdGhpcy5fZGF5cyA9IF9kYXlzO1xuICAgICAgICBQZXJpb2QuWkVSTyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGVyaW9kLlpFUk8gfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX3llYXJzID0gX3llYXJzO1xuICAgIF90aGlzLl9tb250aHMgPSBfbW9udGhzO1xuICAgIF90aGlzLl9kYXlzID0gX2RheXM7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUGVyaW9kLm9mWWVhcnMgPSBmdW5jdGlvbiBvZlllYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIDAsIDApO1xuICB9O1xuXG4gIFBlcmlvZC5vZk1vbnRocyA9IGZ1bmN0aW9uIG9mTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKDAsIG1vbnRocywgMCk7XG4gIH07XG5cbiAgUGVyaW9kLm9mV2Vla3MgPSBmdW5jdGlvbiBvZldlZWtzKHdlZWtzKSB7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoMCwgMCwgTWF0aFV0aWwuc2FmZU11bHRpcGx5KHdlZWtzLCA3KSk7XG4gIH07XG5cbiAgUGVyaW9kLm9mRGF5cyA9IGZ1bmN0aW9uIG9mRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoMCwgMCwgZGF5cyk7XG4gIH07XG5cbiAgUGVyaW9kLm9mID0gZnVuY3Rpb24gb2YoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKHllYXJzLCBtb250aHMsIGRheXMpO1xuICB9O1xuXG4gIFBlcmlvZC5mcm9tID0gZnVuY3Rpb24gZnJvbShhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50IGluc3RhbmNlb2YgUGVyaW9kKSB7XG4gICAgICByZXR1cm4gYW1vdW50O1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHZhciB5ZWFycyA9IDA7XG4gICAgdmFyIG1vbnRocyA9IDA7XG4gICAgdmFyIGRheXMgPSAwO1xuICAgIHZhciB1bml0cyA9IGFtb3VudC51bml0cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bml0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVuaXQgPSB1bml0c1tpXTtcbiAgICAgIHZhciB1bml0QW1vdW50ID0gYW1vdW50LmdldCh1bml0KTtcblxuICAgICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuWUVBUlMpIHtcbiAgICAgICAgeWVhcnMgPSBNYXRoVXRpbC5zYWZlVG9JbnQodW5pdEFtb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTU9OVEhTKSB7XG4gICAgICAgIG1vbnRocyA9IE1hdGhVdGlsLnNhZmVUb0ludCh1bml0QW1vdW50KTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5EQVlTKSB7XG4gICAgICAgIGRheXMgPSBNYXRoVXRpbC5zYWZlVG9JbnQodW5pdEFtb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJVbml0IG11c3QgYmUgWWVhcnMsIE1vbnRocyBvciBEYXlzLCBidXQgd2FzIFwiICsgdW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gIH07XG5cbiAgUGVyaW9kLmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHN0YXJ0RGF0ZSwgJ3N0YXJ0RGF0ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZERhdGUsICdlbmREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHN0YXJ0RGF0ZSwgTG9jYWxEYXRlLCAnc3RhcnREYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGVuZERhdGUsIExvY2FsRGF0ZSwgJ2VuZERhdGUnKTtcbiAgICByZXR1cm4gc3RhcnREYXRlLnVudGlsKGVuZERhdGUpO1xuICB9O1xuXG4gIFBlcmlvZC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBQZXJpb2QuX3BhcnNlKHRleHQpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBBcml0aG1ldGljRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKCdUZXh0IGNhbm5vdCBiZSBwYXJzZWQgdG8gYSBQZXJpb2QnLCB0ZXh0LCAwLCBleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUGVyaW9kLl9wYXJzZSA9IGZ1bmN0aW9uIF9wYXJzZSh0ZXh0KSB7XG4gICAgdmFyIG1hdGNoZXMgPSBQQVRURVJOLmV4ZWModGV4dCk7XG5cbiAgICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgICB2YXIgbmVnYXRlID0gJy0nID09PSBtYXRjaGVzWzFdID8gLTEgOiAxO1xuICAgICAgdmFyIHllYXJNYXRjaCA9IG1hdGNoZXNbMl07XG4gICAgICB2YXIgbW9udGhNYXRjaCA9IG1hdGNoZXNbM107XG4gICAgICB2YXIgd2Vla01hdGNoID0gbWF0Y2hlc1s0XTtcbiAgICAgIHZhciBkYXlNYXRjaCA9IG1hdGNoZXNbNV07XG5cbiAgICAgIGlmICh5ZWFyTWF0Y2ggIT0gbnVsbCB8fCBtb250aE1hdGNoICE9IG51bGwgfHwgd2Vla01hdGNoICE9IG51bGwgfHwgZGF5TWF0Y2ggIT0gbnVsbCkge1xuICAgICAgICB2YXIgeWVhcnMgPSBQZXJpb2QuX3BhcnNlTnVtYmVyKHRleHQsIHllYXJNYXRjaCwgbmVnYXRlKTtcblxuICAgICAgICB2YXIgbW9udGhzID0gUGVyaW9kLl9wYXJzZU51bWJlcih0ZXh0LCBtb250aE1hdGNoLCBuZWdhdGUpO1xuXG4gICAgICAgIHZhciB3ZWVrcyA9IFBlcmlvZC5fcGFyc2VOdW1iZXIodGV4dCwgd2Vla01hdGNoLCBuZWdhdGUpO1xuXG4gICAgICAgIHZhciBkYXlzID0gUGVyaW9kLl9wYXJzZU51bWJlcih0ZXh0LCBkYXlNYXRjaCwgbmVnYXRlKTtcblxuICAgICAgICBkYXlzID0gTWF0aFV0aWwuc2FmZUFkZChkYXlzLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkod2Vla3MsIDcpKTtcbiAgICAgICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oJ1RleHQgY2Fubm90IGJlIHBhcnNlZCB0byBhIFBlcmlvZCcsIHRleHQsIDApO1xuICB9O1xuXG4gIFBlcmlvZC5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIodGV4dCwgc3RyLCBuZWdhdGUpIHtcbiAgICBpZiAoc3RyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSBNYXRoVXRpbC5wYXJzZUludChzdHIpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodmFsLCBuZWdhdGUpO1xuICB9O1xuXG4gIFBlcmlvZC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoeWVhcnMsIG1vbnRocywgZGF5cykge1xuICAgIHJldHVybiBuZXcgUGVyaW9kKHllYXJzLCBtb250aHMsIGRheXMpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBQZXJpb2QucHJvdG90eXBlO1xuXG4gIF9wcm90by51bml0cyA9IGZ1bmN0aW9uIHVuaXRzKCkge1xuICAgIHJldHVybiBbQ2hyb25vVW5pdC5ZRUFSUywgQ2hyb25vVW5pdC5NT05USFMsIENocm9ub1VuaXQuREFZU107XG4gIH07XG5cbiAgX3Byb3RvLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQodW5pdCkge1xuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LllFQVJTKSB7XG4gICAgICByZXR1cm4gdGhpcy5feWVhcnM7XG4gICAgfVxuXG4gICAgaWYgKHVuaXQgPT09IENocm9ub1VuaXQuTU9OVEhTKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICAgIH1cblxuICAgIGlmICh1bml0ID09PSBDaHJvbm9Vbml0LkRBWVMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXlzO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gUGVyaW9kLlpFUk87XG4gIH07XG5cbiAgX3Byb3RvLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl95ZWFycyA8IDAgfHwgdGhpcy5fbW9udGhzIDwgMCB8fCB0aGlzLl9kYXlzIDwgMDtcbiAgfTtcblxuICBfcHJvdG8ueWVhcnMgPSBmdW5jdGlvbiB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcnM7XG4gIH07XG5cbiAgX3Byb3RvLm1vbnRocyA9IGZ1bmN0aW9uIG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9udGhzO1xuICB9O1xuXG4gIF9wcm90by5kYXlzID0gZnVuY3Rpb24gZGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF5cztcbiAgfTtcblxuICBfcHJvdG8ud2l0aFllYXJzID0gZnVuY3Rpb24gd2l0aFllYXJzKHllYXJzKSB7XG4gICAgaWYgKHllYXJzID09PSB0aGlzLl95ZWFycykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoeWVhcnMsIHRoaXMuX21vbnRocywgdGhpcy5fZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNb250aHMgPSBmdW5jdGlvbiB3aXRoTW9udGhzKG1vbnRocykge1xuICAgIGlmIChtb250aHMgPT09IHRoaXMuX21vbnRocykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIG1vbnRocywgdGhpcy5fZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEYXlzID0gZnVuY3Rpb24gd2l0aERheXMoZGF5cykge1xuICAgIGlmIChkYXlzID09PSB0aGlzLl9kYXlzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZSh0aGlzLl95ZWFycywgdGhpcy5fbW9udGhzLCBkYXlzKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1cyA9IGZ1bmN0aW9uIHBsdXMoYW1vdW50VG9BZGQpIHtcbiAgICB2YXIgYW1vdW50ID0gUGVyaW9kLmZyb20oYW1vdW50VG9BZGQpO1xuICAgIHJldHVybiBQZXJpb2QuY3JlYXRlKE1hdGhVdGlsLnNhZmVBZGQodGhpcy5feWVhcnMsIGFtb3VudC5feWVhcnMpLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX21vbnRocywgYW1vdW50Ll9tb250aHMpLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX2RheXMsIGFtb3VudC5fZGF5cykpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZShNYXRoVXRpbC5zYWZlVG9JbnQoTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl95ZWFycywgeWVhcnNUb0FkZCkpLCB0aGlzLl9tb250aHMsIHRoaXMuX2RheXMpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTW9udGhzID0gZnVuY3Rpb24gcGx1c01vbnRocyhtb250aHNUb0FkZCkge1xuICAgIGlmIChtb250aHNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIE1hdGhVdGlsLnNhZmVUb0ludChNYXRoVXRpbC5zYWZlQWRkKHRoaXMuX21vbnRocywgbW9udGhzVG9BZGQpKSwgdGhpcy5fZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNEYXlzID0gZnVuY3Rpb24gcGx1c0RheXMoZGF5c1RvQWRkKSB7XG4gICAgaWYgKGRheXNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUodGhpcy5feWVhcnMsIHRoaXMuX21vbnRocywgTWF0aFV0aWwuc2FmZVRvSW50KE1hdGhVdGlsLnNhZmVBZGQodGhpcy5fZGF5cywgZGF5c1RvQWRkKSkpO1xuICB9O1xuXG4gIF9wcm90by5taW51cyA9IGZ1bmN0aW9uIG1pbnVzKGFtb3VudFRvU3VidHJhY3QpIHtcbiAgICB2YXIgYW1vdW50ID0gUGVyaW9kLmZyb20oYW1vdW50VG9TdWJ0cmFjdCk7XG4gICAgcmV0dXJuIFBlcmlvZC5jcmVhdGUoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHRoaXMuX3llYXJzLCBhbW91bnQuX3llYXJzKSwgTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHRoaXMuX21vbnRocywgYW1vdW50Ll9tb250aHMpLCBNYXRoVXRpbC5zYWZlU3VidHJhY3QodGhpcy5fZGF5cywgYW1vdW50Ll9kYXlzKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNZZWFycygtMSAqIHllYXJzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoLTEgKiBtb250aHNUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoLTEgKiBkYXlzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGxpZWRCeSA9IGZ1bmN0aW9uIG11bHRpcGxpZWRCeShzY2FsYXIpIHtcbiAgICBpZiAodGhpcyA9PT0gUGVyaW9kLlpFUk8gfHwgc2NhbGFyID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZShNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5feWVhcnMsIHNjYWxhciksIE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9tb250aHMsIHNjYWxhciksIE1hdGhVdGlsLnNhZmVNdWx0aXBseSh0aGlzLl9kYXlzLCBzY2FsYXIpKTtcbiAgfTtcblxuICBfcHJvdG8ubmVnYXRlZCA9IGZ1bmN0aW9uIG5lZ2F0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbGllZEJ5KC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubm9ybWFsaXplZCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZWQoKSB7XG4gICAgdmFyIHRvdGFsTW9udGhzID0gdGhpcy50b1RvdGFsTW9udGhzKCk7XG4gICAgdmFyIHNwbGl0WWVhcnMgPSBNYXRoVXRpbC5pbnREaXYodG90YWxNb250aHMsIDEyKTtcbiAgICB2YXIgc3BsaXRNb250aHMgPSBNYXRoVXRpbC5pbnRNb2QodG90YWxNb250aHMsIDEyKTtcblxuICAgIGlmIChzcGxpdFllYXJzID09PSB0aGlzLl95ZWFycyAmJiBzcGxpdE1vbnRocyA9PT0gdGhpcy5fbW9udGhzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gUGVyaW9kLmNyZWF0ZShNYXRoVXRpbC5zYWZlVG9JbnQoc3BsaXRZZWFycyksIHNwbGl0TW9udGhzLCB0aGlzLl9kYXlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9Ub3RhbE1vbnRocyA9IGZ1bmN0aW9uIHRvVG90YWxNb250aHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXJzICogMTIgKyB0aGlzLl9tb250aHM7XG4gIH07XG5cbiAgX3Byb3RvLmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGhpcy5feWVhcnMgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLl9tb250aHMgIT09IDApIHtcbiAgICAgICAgdGVtcG9yYWwgPSB0ZW1wb3JhbC5wbHVzKHRoaXMudG9Ub3RhbE1vbnRocygpLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5feWVhcnMsIENocm9ub1VuaXQuWUVBUlMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbW9udGhzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLnBsdXModGhpcy5fbW9udGhzLCBDaHJvbm9Vbml0Lk1PTlRIUyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RheXMgIT09IDApIHtcbiAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwucGx1cyh0aGlzLl9kYXlzLCBDaHJvbm9Vbml0LkRBWVMpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgfTtcblxuICBfcHJvdG8uc3VidHJhY3RGcm9tID0gZnVuY3Rpb24gc3VidHJhY3RGcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRoaXMuX3llYXJzICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5fbW9udGhzICE9PSAwKSB7XG4gICAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwubWludXModGhpcy50b1RvdGFsTW9udGhzKCksIENocm9ub1VuaXQuTU9OVEhTKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBvcmFsID0gdGVtcG9yYWwubWludXModGhpcy5feWVhcnMsIENocm9ub1VuaXQuWUVBUlMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbW9udGhzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX21vbnRocywgQ2hyb25vVW5pdC5NT05USFMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kYXlzICE9PSAwKSB7XG4gICAgICB0ZW1wb3JhbCA9IHRlbXBvcmFsLm1pbnVzKHRoaXMuX2RheXMsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBvcmFsO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFBlcmlvZCkge1xuICAgICAgdmFyIG90aGVyID0gb2JqO1xuICAgICAgcmV0dXJuIHRoaXMuX3llYXJzID09PSBvdGhlci5feWVhcnMgJiYgdGhpcy5fbW9udGhzID09PSBvdGhlci5fbW9udGhzICYmIHRoaXMuX2RheXMgPT09IG90aGVyLl9kYXlzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaENvZGUodGhpcy5feWVhcnMsIHRoaXMuX21vbnRocywgdGhpcy5fZGF5cyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMgPT09IFBlcmlvZC5aRVJPKSB7XG4gICAgICByZXR1cm4gJ1AwRCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSAnUCc7XG5cbiAgICAgIGlmICh0aGlzLl95ZWFycyAhPT0gMCkge1xuICAgICAgICBidWYgKz0gdGhpcy5feWVhcnMgKyBcIllcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX21vbnRocyAhPT0gMCkge1xuICAgICAgICBidWYgKz0gdGhpcy5fbW9udGhzICsgXCJNXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kYXlzICE9PSAwKSB7XG4gICAgICAgIGJ1ZiArPSB0aGlzLl9kYXlzICsgXCJEXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gUGVyaW9kO1xufShUZW1wb3JhbEFtb3VudCk7XG5mdW5jdGlvbiBfaW5pdCRoKCkge1xuICBQZXJpb2Qub2ZEYXlzKDApO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBQYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9lcnJvckluZGV4ID0gLTE7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUGFyc2VQb3NpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldEluZGV4ID0gZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICB9O1xuXG4gIF9wcm90by5zZXRJbmRleCA9IGZ1bmN0aW9uIHNldEluZGV4KGluZGV4KSB7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RXJyb3JJbmRleCA9IGZ1bmN0aW9uIGdldEVycm9ySW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Vycm9ySW5kZXg7XG4gIH07XG5cbiAgX3Byb3RvLnNldEVycm9ySW5kZXggPSBmdW5jdGlvbiBzZXRFcnJvckluZGV4KGVycm9ySW5kZXgpIHtcbiAgICB0aGlzLl9lcnJvckluZGV4ID0gZXJyb3JJbmRleDtcbiAgfTtcblxuICByZXR1cm4gUGFyc2VQb3NpdGlvbjtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIEVudW1NYXAgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1NYXAoKSB7XG4gICAgdGhpcy5fbWFwID0ge307XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRW51bU1hcC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnB1dEFsbCA9IGZ1bmN0aW9uIHB1dEFsbChvdGhlck1hcCkge1xuICAgIGZvciAodmFyIGtleSBpbiBvdGhlck1hcC5fbWFwKSB7XG4gICAgICB0aGlzLl9tYXBba2V5XSA9IG90aGVyTWFwLl9tYXBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY29udGFpbnNLZXkgPSBmdW5jdGlvbiBjb250YWluc0tleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhc093blByb3BlcnR5KGtleS5uYW1lKCkpICYmIHRoaXMuZ2V0KGtleSkgIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXBba2V5Lm5hbWUoKV07XG4gIH07XG5cbiAgX3Byb3RvLnB1dCA9IGZ1bmN0aW9uIHB1dChrZXksIHZhbCkge1xuICAgIHJldHVybiB0aGlzLnNldChrZXksIHZhbCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgIHRoaXMuX21hcFtrZXkubmFtZSgpXSA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmV0YWluQWxsID0gZnVuY3Rpb24gcmV0YWluQWxsKGtleUxpc3QpIHtcbiAgICB2YXIgbWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlMaXN0W2ldLm5hbWUoKTtcbiAgICAgIG1hcFtrZXldID0gdGhpcy5fbWFwW2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoa2V5KSB7XG4gICAgdmFyIGtleU5hbWUgPSBrZXkubmFtZSgpO1xuICAgIHZhciB2YWwgPSB0aGlzLl9tYXBba2V5TmFtZV07XG4gICAgdGhpcy5fbWFwW2tleU5hbWVdID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG5cbiAgX3Byb3RvLmtleVNldCA9IGZ1bmN0aW9uIGtleVNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9O1xuXG4gIHJldHVybiBFbnVtTWFwO1xufSgpO1xuXG52YXIgUmVzb2x2ZXJTdHlsZSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShSZXNvbHZlclN0eWxlLCBfRW51bSk7XG5cbiAgZnVuY3Rpb24gUmVzb2x2ZXJTdHlsZSgpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIFJlc29sdmVyU3R5bGU7XG59KEVudW0pO1xuUmVzb2x2ZXJTdHlsZS5TVFJJQ1QgPSBuZXcgUmVzb2x2ZXJTdHlsZSgnU1RSSUNUJyk7XG5SZXNvbHZlclN0eWxlLlNNQVJUID0gbmV3IFJlc29sdmVyU3R5bGUoJ1NNQVJUJyk7XG5SZXNvbHZlclN0eWxlLkxFTklFTlQgPSBuZXcgUmVzb2x2ZXJTdHlsZSgnTEVOSUVOVCcpO1xuXG52YXIgVGVtcG9yYWwgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWNjZXNzb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGVtcG9yYWwsIF9UZW1wb3JhbEFjY2Vzc29yKTtcblxuICBmdW5jdGlvbiBUZW1wb3JhbCgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRlbXBvcmFsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnaXNTdXBwb3J0ZWQnKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXMgPSBmdW5jdGlvbiBtaW51cyhhbW91bnQsIHVuaXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW51c0Ftb3VudChhbW91bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWludXNVbml0KGFtb3VudCwgdW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fbWludXNBbW91bnQgPSBmdW5jdGlvbiBfbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGFtb3VudCwgVGVtcG9yYWxBbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvU3VidHJhY3QsICdhbW91bnRUb1N1YnRyYWN0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodW5pdCwgVGVtcG9yYWxVbml0LCAndW5pdCcpO1xuICAgIHJldHVybiB0aGlzLl9wbHVzVW5pdCgtYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXMgPSBmdW5jdGlvbiBwbHVzKGFtb3VudCwgdW5pdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdXNBbW91bnQoYW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KGFtb3VudCwgdW5pdCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGx1c0Ftb3VudCA9IGZ1bmN0aW9uIF9wbHVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCwgJ2Ftb3VudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShhbW91bnQsIFRlbXBvcmFsQW1vdW50LCAnYW1vdW50Jyk7XG4gICAgcmV0dXJuIGFtb3VudC5hZGRUbyh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdfcGx1c1VuaXQnKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRUZW1wb3JhbCwgdW5pdCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgndW50aWwnKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aCA9IGZ1bmN0aW9uIF93aXRoKGFkanVzdGVyT3JGaWVsZCwgbmV3VmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoQWRqdXN0ZXIoYWRqdXN0ZXJPckZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhGaWVsZChhZGp1c3Rlck9yRmllbGQsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl93aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiBfd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuICAgIGFzc2VydCh0eXBlb2YgYWRqdXN0ZXIuYWRqdXN0SW50byA9PT0gJ2Z1bmN0aW9uJywgJ2FkanVzdGVyIG11c3QgYmUgYSBUZW1wb3JhbEFkanVzdGVyJywgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKTtcbiAgICByZXR1cm4gYWRqdXN0ZXIuYWRqdXN0SW50byh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdfd2l0aEZpZWxkJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsO1xufShUZW1wb3JhbEFjY2Vzc29yKTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSkge1xuICBUZW1wb3JhbC5wcm90b3R5cGVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9IGZ1bmN0aW9uIChoaW50KSB7XG4gICAgaWYgKGhpbnQgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgY29udmVyc2lvbiBmcm9tIFRlbXBvcmFsIHRvIGEgbnVtYmVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ1RvIGNvbXBhcmUgdXNlIHRoZSBtZXRob2RzIC5lcXVhbHMoKSwgLmNvbXBhcmVUbygpLCAuaXNCZWZvcmUoKSAnICsgJ29yIG9uZSB0aGF0IGlzIG1vcmUgc3VpdGFibGUgdG8geW91ciB1c2UgY2FzZS4nKTtcbiAgfTtcbn1cblxudmFyIENocm9ub0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vTG9jYWxEYXRlLCBfVGVtcG9yYWwpO1xuXG4gIGZ1bmN0aW9uIENocm9ub0xvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gX1RlbXBvcmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaHJvbm9Mb2NhbERhdGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpO1xuICAgIH0gZWxzZSBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRPclVuaXQgIT0gbnVsbCAmJiBmaWVsZE9yVW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNocm9ub2xvZ3koKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5EQVlTO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheSh0aGlzLnRvRXBvY2hEYXkoKSk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5FUE9DSF9EQVksIHRoaXMudG9FcG9jaERheSgpKTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIENocm9ub0xvY2FsRGF0ZTtcbn0oVGVtcG9yYWwpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgU3RyaW5nVXRpbCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nVXRpbCgpIHt9XG5cbiAgU3RyaW5nVXRpbC5zdGFydHNXaXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aCh0ZXh0LCBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHRleHQuaW5kZXhPZihwYXR0ZXJuKSA9PT0gMDtcbiAgfTtcblxuICBTdHJpbmdVdGlsLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUodGV4dCkge1xuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjaHIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgICAgaGFzaCB8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoVXRpbC5zbWkoaGFzaCk7XG4gIH07XG5cbiAgcmV0dXJuIFN0cmluZ1V0aWw7XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFpvbmVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZUlkKCkge31cblxuICBab25lSWQuc3lzdGVtRGVmYXVsdCA9IGZ1bmN0aW9uIHN5c3RlbURlZmF1bHQoKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xuICB9O1xuXG4gIFpvbmVJZC5nZXRBdmFpbGFibGVab25lSWRzID0gZnVuY3Rpb24gZ2V0QXZhaWxhYmxlWm9uZUlkcygpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ25vdCBzdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG4gIH07XG5cbiAgWm9uZUlkLm9mID0gZnVuY3Rpb24gb2Yoem9uZUlkKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwibm90IHN1cHBvcnRlZCBvcGVyYXRpb25cIiArIHpvbmVJZCk7XG4gIH07XG5cbiAgWm9uZUlkLm9mT2Zmc2V0ID0gZnVuY3Rpb24gb2ZPZmZzZXQocHJlZml4LCBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJub3Qgc3VwcG9ydGVkIG9wZXJhdGlvblwiICsgcHJlZml4ICsgb2Zmc2V0KTtcbiAgfTtcblxuICBab25lSWQuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJub3Qgc3VwcG9ydGVkIG9wZXJhdGlvblwiICsgdGVtcG9yYWwpO1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBab25lSWQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZUlkLmlkJyk7XG4gIH07XG5cbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lSWQucnVsZXMnKTtcbiAgfTtcblxuICBfcHJvdG8ubm9ybWFsaXplZCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZWQoKSB7XG4gICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcygpO1xuXG4gICAgaWYgKHJ1bGVzLmlzRml4ZWRPZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIHJ1bGVzLm9mZnNldChJbnN0YW50LkVQT0NIKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmlkKCkgPT09IG90aGVyLmlkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiBTdHJpbmdVdGlsLmhhc2hDb2RlKHRoaXMuaWQoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQoKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVJZDtcbn0oKTtcblxudmFyIFpvbmVSdWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZVJ1bGVzKCkge31cblxuICBab25lUnVsZXMub2YgPSBmdW5jdGlvbiBvZihvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXR1cm4gbmV3IEZpeGVkKG9mZnNldCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IFpvbmVSdWxlcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRml4ZWRPZmZzZXQgPSBmdW5jdGlvbiBpc0ZpeGVkT2Zmc2V0KCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLmlzRml4ZWRPZmZzZXQnKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0KGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpIHtcbiAgICBpZiAoaW5zdGFudE9yTG9jYWxEYXRlVGltZSBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldE9mSW5zdGFudChpbnN0YW50T3JMb2NhbERhdGVUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0T2ZMb2NhbERhdGVUaW1lKGluc3RhbnRPckxvY2FsRGF0ZVRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0T2ZJbnN0YW50ID0gZnVuY3Rpb24gb2Zmc2V0T2ZJbnN0YW50KGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5vZmZzZXRJbnN0YW50Jyk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mRXBvY2hNaWxsaSA9IGZ1bmN0aW9uIG9mZnNldE9mRXBvY2hNaWxsaShlcG9jaE1pbGxpKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0T2ZFcG9jaE1pbGxpJyk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIG9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMub2Zmc2V0TG9jYWxEYXRlVGltZScpO1xuICB9O1xuXG4gIF9wcm90by52YWxpZE9mZnNldHMgPSBmdW5jdGlvbiB2YWxpZE9mZnNldHMobG9jYWxEYXRlVGltZSkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnZhbGlkT2Zmc2V0cycpO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihsb2NhbERhdGVUaW1lKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudHJhbnNpdGlvbicpO1xuICB9O1xuXG4gIF9wcm90by5zdGFuZGFyZE9mZnNldCA9IGZ1bmN0aW9uIHN0YW5kYXJkT2Zmc2V0KGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5zdGFuZGFyZE9mZnNldCcpO1xuICB9O1xuXG4gIF9wcm90by5kYXlsaWdodFNhdmluZ3MgPSBmdW5jdGlvbiBkYXlsaWdodFNhdmluZ3MoaW5zdGFudCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLmRheWxpZ2h0U2F2aW5ncycpO1xuICB9O1xuXG4gIF9wcm90by5pc0RheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdzKGluc3RhbnQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5pc0RheWxpZ2h0U2F2aW5ncycpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkT2Zmc2V0ID0gZnVuY3Rpb24gaXNWYWxpZE9mZnNldChsb2NhbERhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ1pvbmVSdWxlcy5pc1ZhbGlkT2Zmc2V0Jyk7XG4gIH07XG5cbiAgX3Byb3RvLm5leHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gbmV4dFRyYW5zaXRpb24oaW5zdGFudCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLm5leHRUcmFuc2l0aW9uJyk7XG4gIH07XG5cbiAgX3Byb3RvLnByZXZpb3VzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHByZXZpb3VzVHJhbnNpdGlvbihpbnN0YW50KSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMucHJldmlvdXNUcmFuc2l0aW9uJyk7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zaXRpb25zID0gZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdab25lUnVsZXMudHJhbnNpdGlvbnMnKTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNpdGlvblJ1bGVzID0gZnVuY3Rpb24gdHJhbnNpdGlvblJ1bGVzKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnRyYW5zaXRpb25SdWxlcycpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnWm9uZVJ1bGVzLnRvU3RyaW5nJyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBab25lUnVsZXM7XG59KCk7XG5cbnZhciBGaXhlZCA9IGZ1bmN0aW9uIChfWm9uZVJ1bGVzKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpeGVkLCBfWm9uZVJ1bGVzKTtcblxuICBmdW5jdGlvbiBGaXhlZChvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lUnVsZXMuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBGaXhlZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0ZpeGVkT2Zmc2V0ID0gZnVuY3Rpb24gaXNGaXhlZE9mZnNldCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8yLm9mZnNldE9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mZnNldE9mSW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICB9O1xuXG4gIF9wcm90bzIub2Zmc2V0T2ZFcG9jaE1pbGxpID0gZnVuY3Rpb24gb2Zmc2V0T2ZFcG9jaE1pbGxpKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gIH07XG5cbiAgX3Byb3RvMi5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiBvZmZzZXRPZkxvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8yLnZhbGlkT2Zmc2V0cyA9IGZ1bmN0aW9uIHZhbGlkT2Zmc2V0cygpIHtcbiAgICByZXR1cm4gW3RoaXMuX29mZnNldF07XG4gIH07XG5cbiAgX3Byb3RvMi50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBfcHJvdG8yLnN0YW5kYXJkT2Zmc2V0ID0gZnVuY3Rpb24gc3RhbmRhcmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8yLmRheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGRheWxpZ2h0U2F2aW5ncygpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uWkVSTztcbiAgfTtcblxuICBfcHJvdG8yLmlzRGF5bGlnaHRTYXZpbmdzID0gZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ3MoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzIuaXNWYWxpZE9mZnNldCA9IGZ1bmN0aW9uIGlzVmFsaWRPZmZzZXQobG9jYWxEYXRlVGltZSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldC5lcXVhbHMob2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRUcmFuc2l0aW9uID0gZnVuY3Rpb24gbmV4dFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvMi5wcmV2aW91c1RyYW5zaXRpb24gPSBmdW5jdGlvbiBwcmV2aW91c1RyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvMi50cmFuc2l0aW9ucyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICBfcHJvdG8yLnRyYW5zaXRpb25SdWxlcyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25SdWxlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEZpeGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LmVxdWFscyhvdGhlci5fb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIkZpeGVkUnVsZXM6XCIgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoKTtcbiAgfTtcblxuICByZXR1cm4gRml4ZWQ7XG59KFpvbmVSdWxlcyk7XG5cbnZhciBTRUNPTkRTX0NBQ0hFID0ge307XG52YXIgSURfQ0FDSEUgPSB7fTtcbnZhciBab25lT2Zmc2V0ID0gZnVuY3Rpb24gKF9ab25lSWQpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZU9mZnNldCwgX1pvbmVJZCk7XG5cbiAgZnVuY3Rpb24gWm9uZU9mZnNldCh0b3RhbFNlY29uZHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lSWQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgWm9uZU9mZnNldC5fdmFsaWRhdGVUb3RhbFNlY29uZHModG90YWxTZWNvbmRzKTtcblxuICAgIF90aGlzLl90b3RhbFNlY29uZHMgPSBNYXRoVXRpbC5zYWZlVG9JbnQodG90YWxTZWNvbmRzKTtcbiAgICBfdGhpcy5fcnVsZXMgPSBab25lUnVsZXMub2YoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLl9pZCA9IFpvbmVPZmZzZXQuX2J1aWxkSWQodG90YWxTZWNvbmRzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWm9uZU9mZnNldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvdGFsU2Vjb25kcyA9IGZ1bmN0aW9uIHRvdGFsU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzO1xuICB9O1xuXG4gIF9wcm90by5pZCA9IGZ1bmN0aW9uIGlkKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfTtcblxuICBab25lT2Zmc2V0Ll9idWlsZElkID0gZnVuY3Rpb24gX2J1aWxkSWQodG90YWxTZWNvbmRzKSB7XG4gICAgaWYgKHRvdGFsU2Vjb25kcyA9PT0gMCkge1xuICAgICAgcmV0dXJuICdaJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFic1RvdGFsU2Vjb25kcyA9IE1hdGguYWJzKHRvdGFsU2Vjb25kcyk7XG4gICAgICB2YXIgYWJzSG91cnMgPSBNYXRoVXRpbC5pbnREaXYoYWJzVG90YWxTZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgICB2YXIgYWJzTWludXRlcyA9IE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnREaXYoYWJzVG90YWxTZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgICAgdmFyIGJ1ZiA9IFwiXCIgKyAodG90YWxTZWNvbmRzIDwgMCA/ICctJyA6ICcrJykgKyAoYWJzSG91cnMgPCAxMCA/ICcwJyA6ICcnKSArIGFic0hvdXJzICsgKGFic01pbnV0ZXMgPCAxMCA/ICc6MCcgOiAnOicpICsgYWJzTWludXRlcztcbiAgICAgIHZhciBhYnNTZWNvbmRzID0gTWF0aFV0aWwuaW50TW9kKGFic1RvdGFsU2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG5cbiAgICAgIGlmIChhYnNTZWNvbmRzICE9PSAwKSB7XG4gICAgICAgIGJ1ZiArPSAoYWJzU2Vjb25kcyA8IDEwID8gJzowJyA6ICc6JykgKyBhYnNTZWNvbmRzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgfTtcblxuICBab25lT2Zmc2V0Ll92YWxpZGF0ZVRvdGFsU2Vjb25kcyA9IGZ1bmN0aW9uIF92YWxpZGF0ZVRvdGFsU2Vjb25kcyh0b3RhbFNlY29uZHMpIHtcbiAgICBpZiAoTWF0aC5hYnModG90YWxTZWNvbmRzKSA+IFpvbmVPZmZzZXQuTUFYX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignWm9uZSBvZmZzZXQgbm90IGluIHZhbGlkIHJhbmdlOiAtMTg6MDAgdG8gKzE4OjAwJyk7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVPZmZzZXQuX3ZhbGlkYXRlID0gZnVuY3Rpb24gX3ZhbGlkYXRlKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgaWYgKGhvdXJzIDwgLTE4IHx8IGhvdXJzID4gMTgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmUgb2Zmc2V0IGhvdXJzIG5vdCBpbiB2YWxpZCByYW5nZTogdmFsdWUgXCIgKyBob3VycyArIFwiIGlzIG5vdCBpbiB0aGUgcmFuZ2UgLTE4IHRvIDE4XCIpO1xuICAgIH1cblxuICAgIGlmIChob3VycyA+IDApIHtcbiAgICAgIGlmIChtaW51dGVzIDwgMCB8fCBzZWNvbmRzIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1pvbmUgb2Zmc2V0IG1pbnV0ZXMgYW5kIHNlY29uZHMgbXVzdCBiZSBwb3NpdGl2ZSBiZWNhdXNlIGhvdXJzIGlzIHBvc2l0aXZlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3VycyA8IDApIHtcbiAgICAgIGlmIChtaW51dGVzID4gMCB8fCBzZWNvbmRzID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1pvbmUgb2Zmc2V0IG1pbnV0ZXMgYW5kIHNlY29uZHMgbXVzdCBiZSBuZWdhdGl2ZSBiZWNhdXNlIGhvdXJzIGlzIG5lZ2F0aXZlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW51dGVzID4gMCAmJiBzZWNvbmRzIDwgMCB8fCBtaW51dGVzIDwgMCAmJiBzZWNvbmRzID4gMCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdab25lIG9mZnNldCBtaW51dGVzIGFuZCBzZWNvbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaWduJyk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKG1pbnV0ZXMpID4gNTkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmUgb2Zmc2V0IG1pbnV0ZXMgbm90IGluIHZhbGlkIHJhbmdlOiBhYnModmFsdWUpIFwiICsgTWF0aC5hYnMobWludXRlcykgKyBcIiBpcyBub3QgaW4gdGhlIHJhbmdlIDAgdG8gNTlcIik7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHNlY29uZHMpID4gNTkpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmUgb2Zmc2V0IHNlY29uZHMgbm90IGluIHZhbGlkIHJhbmdlOiBhYnModmFsdWUpIFwiICsgTWF0aC5hYnMoc2Vjb25kcykgKyBcIiBpcyBub3QgaW4gdGhlIHJhbmdlIDAgdG8gNTlcIik7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGhvdXJzKSA9PT0gMTggJiYgKE1hdGguYWJzKG1pbnV0ZXMpID4gMCB8fCBNYXRoLmFicyhzZWNvbmRzKSA+IDApKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1pvbmUgb2Zmc2V0IG5vdCBpbiB2YWxpZCByYW5nZTogLTE4OjAwIHRvICsxODowMCcpO1xuICAgIH1cbiAgfTtcblxuICBab25lT2Zmc2V0Lm9mID0gZnVuY3Rpb24gb2Yob2Zmc2V0SWQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXRJZCwgJ29mZnNldElkJyk7XG4gICAgdmFyIG9mZnNldCA9IElEX0NBQ0hFW29mZnNldElkXTtcblxuICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHM7XG5cbiAgICBzd2l0Y2ggKG9mZnNldElkLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBvZmZzZXRJZCA9IG9mZnNldElkWzBdICsgXCIwXCIgKyBvZmZzZXRJZFsxXTtcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBob3VycyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAxLCBmYWxzZSk7XG4gICAgICAgIG1pbnV0ZXMgPSAwO1xuICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgaG91cnMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgMSwgZmFsc2UpO1xuICAgICAgICBtaW51dGVzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDMsIGZhbHNlKTtcbiAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCA0LCB0cnVlKTtcbiAgICAgICAgc2Vjb25kcyA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDc6XG4gICAgICAgIGhvdXJzID0gWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIob2Zmc2V0SWQsIDEsIGZhbHNlKTtcbiAgICAgICAgbWludXRlcyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAzLCBmYWxzZSk7XG4gICAgICAgIHNlY29uZHMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNSwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5OlxuICAgICAgICBob3VycyA9IFpvbmVPZmZzZXQuX3BhcnNlTnVtYmVyKG9mZnNldElkLCAxLCBmYWxzZSk7XG4gICAgICAgIG1pbnV0ZXMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNCwgdHJ1ZSk7XG4gICAgICAgIHNlY29uZHMgPSBab25lT2Zmc2V0Ll9wYXJzZU51bWJlcihvZmZzZXRJZCwgNywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBpbnZhbGlkIGZvcm1hdDogXCIgKyBvZmZzZXRJZCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0ID0gb2Zmc2V0SWRbMF07XG5cbiAgICBpZiAoZmlyc3QgIT09ICcrJyAmJiBmaXJzdCAhPT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBwbHVzL21pbnVzIG5vdCBmb3VuZCB3aGVuIGV4cGVjdGVkOiBcIiArIG9mZnNldElkKTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3QgPT09ICctJykge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKC1ob3VycywgLW1pbnV0ZXMsIC1zZWNvbmRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXNTZWNvbmRzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICB9XG4gIH07XG5cbiAgWm9uZU9mZnNldC5fcGFyc2VOdW1iZXIgPSBmdW5jdGlvbiBfcGFyc2VOdW1iZXIob2Zmc2V0SWQsIHBvcywgcHJlY2VkZWRCeUNvbG9uKSB7XG4gICAgaWYgKHByZWNlZGVkQnlDb2xvbiAmJiBvZmZzZXRJZFtwb3MgLSAxXSAhPT0gJzonKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbnZhbGlkIElEIGZvciBab25lT2Zmc2V0LCBjb2xvbiBub3QgZm91bmQgd2hlbiBleHBlY3RlZDogXCIgKyBvZmZzZXRJZCk7XG4gICAgfVxuXG4gICAgdmFyIGNoMSA9IG9mZnNldElkW3Bvc107XG4gICAgdmFyIGNoMiA9IG9mZnNldElkW3BvcyArIDFdO1xuXG4gICAgaWYgKGNoMSA8ICcwJyB8fCBjaDEgPiAnOScgfHwgY2gyIDwgJzAnIHx8IGNoMiA+ICc5Jykge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBJRCBmb3IgWm9uZU9mZnNldCwgbm9uIG51bWVyaWMgY2hhcmFjdGVycyBmb3VuZDogXCIgKyBvZmZzZXRJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChjaDEuY2hhckNvZGVBdCgwKSAtIDQ4KSAqIDEwICsgKGNoMi5jaGFyQ29kZUF0KDApIC0gNDgpO1xuICB9O1xuXG4gIFpvbmVPZmZzZXQub2ZIb3VycyA9IGZ1bmN0aW9uIG9mSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIDAsIDApO1xuICB9O1xuXG4gIFpvbmVPZmZzZXQub2ZIb3Vyc01pbnV0ZXMgPSBmdW5jdGlvbiBvZkhvdXJzTWludXRlcyhob3VycywgbWludXRlcykge1xuICAgIHJldHVybiBab25lT2Zmc2V0Lm9mSG91cnNNaW51dGVzU2Vjb25kcyhob3VycywgbWludXRlcywgMCk7XG4gIH07XG5cbiAgWm9uZU9mZnNldC5vZkhvdXJzTWludXRlc1NlY29uZHMgPSBmdW5jdGlvbiBvZkhvdXJzTWludXRlc1NlY29uZHMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICBab25lT2Zmc2V0Ll92YWxpZGF0ZShob3VycywgbWludXRlcywgc2Vjb25kcyk7XG5cbiAgICB2YXIgdG90YWxTZWNvbmRzID0gaG91cnMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiArIG1pbnV0ZXMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFICsgc2Vjb25kcztcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyh0b3RhbFNlY29uZHMpO1xuICB9O1xuXG4gIFpvbmVPZmZzZXQub2ZUb3RhbE1pbnV0ZXMgPSBmdW5jdGlvbiBvZlRvdGFsTWludXRlcyh0b3RhbE1pbnV0ZXMpIHtcbiAgICB2YXIgdG90YWxTZWNvbmRzID0gdG90YWxNaW51dGVzICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURTtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyh0b3RhbFNlY29uZHMpO1xuICB9O1xuXG4gIFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHMgPSBmdW5jdGlvbiBvZlRvdGFsU2Vjb25kcyh0b3RhbFNlY29uZHMpIHtcbiAgICBpZiAodG90YWxTZWNvbmRzICUgKDE1ICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSkgPT09IDApIHtcbiAgICAgIHZhciB0b3RhbFNlY3MgPSB0b3RhbFNlY29uZHM7XG4gICAgICB2YXIgcmVzdWx0ID0gU0VDT05EU19DQUNIRVt0b3RhbFNlY3NdO1xuXG4gICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFpvbmVPZmZzZXQodG90YWxTZWNvbmRzKTtcbiAgICAgICAgU0VDT05EU19DQUNIRVt0b3RhbFNlY3NdID0gcmVzdWx0O1xuICAgICAgICBJRF9DQUNIRVtyZXN1bHQuaWQoKV0gPSByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgWm9uZU9mZnNldCh0b3RhbFNlY29uZHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucnVsZXMgPSBmdW5jdGlvbiBydWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcnVsZXM7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIGlmIChmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3RhbFNlY29uZHM7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gX3F1ZXJ5LnF1ZXJ5RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgdGhpcy5fdG90YWxTZWNvbmRzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJldHVybiBvdGhlci5fdG90YWxTZWNvbmRzIC0gdGhpcy5fdG90YWxTZWNvbmRzO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFpvbmVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3RhbFNlY29uZHMgPT09IG9iai5fdG90YWxTZWNvbmRzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxTZWNvbmRzO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfTtcblxuICByZXR1cm4gWm9uZU9mZnNldDtcbn0oWm9uZUlkKTtcbmZ1bmN0aW9uIF9pbml0JGcoKSB7XG4gIFpvbmVPZmZzZXQuTUFYX1NFQ09ORFMgPSAxOCAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSO1xuICBab25lT2Zmc2V0LlVUQyA9IFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHMoMCk7XG4gIFpvbmVPZmZzZXQuTUlOID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcygtWm9uZU9mZnNldC5NQVhfU0VDT05EUyk7XG4gIFpvbmVPZmZzZXQuTUFYID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhab25lT2Zmc2V0Lk1BWF9TRUNPTkRTKTtcbn1cblxudmFyIERhdGVUaW1lQnVpbGRlciA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShEYXRlVGltZUJ1aWxkZXIsIF9UZW1wb3JhbEFjY2Vzc29yKTtcblxuICBEYXRlVGltZUJ1aWxkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGZpZWxkLCB2YWx1ZSkge1xuICAgIHZhciBkdGIgPSBuZXcgRGF0ZVRpbWVCdWlsZGVyKCk7XG5cbiAgICBkdGIuX2FkZEZpZWxkVmFsdWUoZmllbGQsIHZhbHVlKTtcblxuICAgIHJldHVybiBkdGI7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGF0ZVRpbWVCdWlsZGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsQWNjZXNzb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmZpZWxkVmFsdWVzID0gbmV3IEVudW1NYXAoKTtcbiAgICBfdGhpcy5jaHJvbm8gPSBudWxsO1xuICAgIF90aGlzLnpvbmUgPSBudWxsO1xuICAgIF90aGlzLmRhdGUgPSBudWxsO1xuICAgIF90aGlzLnRpbWUgPSBudWxsO1xuICAgIF90aGlzLmxlYXBTZWNvbmQgPSBmYWxzZTtcbiAgICBfdGhpcy5leGNlc3NEYXlzID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWVCdWlsZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RmllbGRWYWx1ZTAgPSBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlMChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkVmFsdWVzLmdldChmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGRGaWVsZFZhbHVlID0gZnVuY3Rpb24gX2FkZEZpZWxkVmFsdWUoZmllbGQsIHZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHZhciBvbGQgPSB0aGlzLmdldEZpZWxkVmFsdWUwKGZpZWxkKTtcblxuICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQgIT09IHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJDb25mbGljdCBmb3VuZDogXCIgKyBmaWVsZCArIFwiIFwiICsgb2xkICsgXCIgZGlmZmVycyBmcm9tIFwiICsgZmllbGQgKyBcIiBcIiArIHZhbHVlICsgXCI6IFwiICsgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1dEZpZWxkVmFsdWUwKGZpZWxkLCB2YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wdXRGaWVsZFZhbHVlMCA9IGZ1bmN0aW9uIF9wdXRGaWVsZFZhbHVlMChmaWVsZCwgdmFsdWUpIHtcbiAgICB0aGlzLmZpZWxkVmFsdWVzLnB1dChmaWVsZCwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShyZXNvbHZlclN0eWxlLCByZXNvbHZlckZpZWxkcykge1xuICAgIGlmIChyZXNvbHZlckZpZWxkcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZpZWxkVmFsdWVzLnJldGFpbkFsbChyZXNvbHZlckZpZWxkcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWVyZ2VEYXRlKHJlc29sdmVyU3R5bGUpO1xuXG4gICAgdGhpcy5fbWVyZ2VUaW1lKHJlc29sdmVyU3R5bGUpO1xuXG4gICAgdGhpcy5fcmVzb2x2ZVRpbWVJbmZlclplcm9lcyhyZXNvbHZlclN0eWxlKTtcblxuICAgIGlmICh0aGlzLmV4Y2Vzc0RheXMgIT0gbnVsbCAmJiB0aGlzLmV4Y2Vzc0RheXMuaXNaZXJvKCkgPT09IGZhbHNlICYmIHRoaXMuZGF0ZSAhPSBudWxsICYmIHRoaXMudGltZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRhdGUgPSB0aGlzLmRhdGUucGx1cyh0aGlzLmV4Y2Vzc0RheXMpO1xuICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLlpFUk87XG4gICAgfVxuXG4gICAgdGhpcy5fcmVzb2x2ZUluc3RhbnQoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fbWVyZ2VEYXRlID0gZnVuY3Rpb24gX21lcmdlRGF0ZShyZXNvbHZlclN0eWxlKSB7XG4gICAgdGhpcy5fY2hlY2tEYXRlKElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UucmVzb2x2ZURhdGUodGhpcy5maWVsZFZhbHVlcywgcmVzb2x2ZXJTdHlsZSkpO1xuICB9O1xuXG4gIF9wcm90by5fY2hlY2tEYXRlID0gZnVuY3Rpb24gX2NoZWNrRGF0ZShkYXRlKSB7XG4gICAgaWYgKGRhdGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRhdGUpO1xuXG4gICAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gdGhpcy5maWVsZFZhbHVlcy5rZXlTZXQoKSkge1xuICAgICAgICB2YXIgZmllbGQgPSBDaHJvbm9GaWVsZC5ieU5hbWUoZmllbGROYW1lKTtcblxuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5nZXQoZmllbGQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5pc0RhdGVCYXNlZCgpKSB7XG4gICAgICAgICAgICAgIHZhciB2YWwxID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsMSA9IGRhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRGF0ZVRpbWVFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgdmFsMiA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcblxuICAgICAgICAgICAgICBpZiAodmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkNvbmZsaWN0IGZvdW5kOiBGaWVsZCBcIiArIGZpZWxkICsgXCIgXCIgKyB2YWwxICsgXCIgZGlmZmVycyBmcm9tIFwiICsgZmllbGQgKyBcIiBcIiArIHZhbDIgKyBcIiBkZXJpdmVkIGZyb20gXCIgKyBkYXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX21lcmdlVGltZSA9IGZ1bmN0aW9uIF9tZXJnZVRpbWUocmVzb2x2ZXJTdHlsZSkge1xuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZKSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNNQVJUICYmIGNoID09PSAwKSA7IGVsc2Uge1xuICAgICAgICAgIENocm9ub0ZpZWxkLkNMT0NLX0hPVVJfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSwgY2ggPT09IDI0ID8gMCA6IGNoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0pKSB7XG4gICAgICB2YXIgX2NoID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TTUFSVCAmJiBfY2ggPT09IDApIDsgZWxzZSB7XG4gICAgICAgICAgQ2hyb25vRmllbGQuQ0xPQ0tfSE9VUl9PRl9BTVBNLmNoZWNrVmFsaWRWYWx1ZShfY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNLCBfY2ggPT09IDEyID8gMCA6IF9jaCk7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLkFNUE1fT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZSh0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5BTVBNX09GX0RBWSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE0pKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTS5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNKSkge1xuICAgICAgdmFyIGFwID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQU1QTV9PRl9EQVkpO1xuICAgICAgdmFyIGhhcCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkhPVVJfT0ZfQU1QTSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIGFwICogMTIgKyBoYXApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKSkge1xuICAgICAgdmFyIG5vZCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobm9kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYobm9kLCAxMDAwMDAwMDAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIE1hdGhVdGlsLmludE1vZChub2QsIDEwMDAwMDAwMDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkpKSB7XG4gICAgICB2YXIgY29kID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5NSUNST19PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKGNvZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSwgTWF0aFV0aWwuaW50RGl2KGNvZCwgMTAwMDAwMCkpO1xuXG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCwgTWF0aFV0aWwuaW50TW9kKGNvZCwgMTAwMDAwMCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JTExJX09GX0RBWSkpIHtcbiAgICAgIHZhciBsb2QgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JTExJX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobG9kKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkRmllbGRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYobG9kLCAxMDAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05ELCBNYXRoVXRpbC5pbnRNb2QobG9kLCAxMDAwKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWSkpIHtcbiAgICAgIHZhciBzb2QgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzb2QpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRGaWVsZFZhbHVlKENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLCBNYXRoVXRpbC5pbnREaXYoc29kLCAzNjAwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIE1hdGhVdGlsLmludE1vZChNYXRoVXRpbC5pbnREaXYoc29kLCA2MCksIDYwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSwgTWF0aFV0aWwuaW50TW9kKHNvZCwgNjApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfREFZKSkge1xuICAgICAgdmFyIG1vZCA9IHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkpO1xuXG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKG1vZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIE1hdGhVdGlsLmludERpdihtb2QsIDYwKSk7XG5cbiAgICAgIHRoaXMuX2FkZEZpZWxkVmFsdWUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIsIE1hdGhVdGlsLmludE1vZChtb2QsIDYwKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVyU3R5bGUgIT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSkge1xuICAgICAgICBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORC5jaGVja1ZhbGlkVmFsdWUodGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSAmJiB0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBsb3MgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuICAgICAgdmFyIGNvcyA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCk7XG5cbiAgICAgIHRoaXMuX3B1dEZpZWxkVmFsdWUwKENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCwgbG9zICogMTAwMCArIE1hdGhVdGlsLmludE1vZChjb3MsIDEwMDApKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuXG4gICAgICB0aGlzLl9wdXRGaWVsZFZhbHVlMChDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQsIE1hdGhVdGlsLmludERpdihub3MsIDEwMDApKTtcblxuICAgICAgdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpICYmIHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICB2YXIgX25vcyA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcblxuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05ELCBNYXRoVXRpbC5pbnREaXYoX25vcywgMTAwMDAwMCkpO1xuXG4gICAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCkpIHtcbiAgICAgIHZhciBfY29zID0gdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EKTtcblxuICAgICAgdGhpcy5fcHV0RmllbGRWYWx1ZTAoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIF9jb3MgKiAxMDAwKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EKSkge1xuICAgICAgdmFyIF9sb3MgPSB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQpO1xuXG4gICAgICB0aGlzLl9wdXRGaWVsZFZhbHVlMChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgX2xvcyAqIDEwMDAwMDApO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3Jlc29sdmVUaW1lSW5mZXJaZXJvZXMgPSBmdW5jdGlvbiBfcmVzb2x2ZVRpbWVJbmZlclplcm9lcyhyZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIGhvZCA9IHRoaXMuZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZKTtcbiAgICB2YXIgbW9oID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHZhciBzb20gPSB0aGlzLmZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFKTtcbiAgICB2YXIgbm9zID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuXG4gICAgaWYgKGhvZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1vaCA9PSBudWxsICYmIChzb20gIT0gbnVsbCB8fCBub3MgIT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobW9oICE9IG51bGwgJiYgc29tID09IG51bGwgJiYgbm9zICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICBpZiAoaG9kICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU01BUlQgJiYgaG9kID09PSAyNCAmJiAobW9oID09IG51bGwgfHwgbW9oID09PSAwKSAmJiAoc29tID09IG51bGwgfHwgc29tID09PSAwKSAmJiAobm9zID09IG51bGwgfHwgbm9zID09PSAwKSkge1xuICAgICAgICAgIGhvZCA9IDA7XG4gICAgICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLm9mRGF5cygxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBob2RWYWwgPSBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWS5jaGVja1ZhbGlkSW50VmFsdWUoaG9kKTtcblxuICAgICAgICBpZiAobW9oICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgbW9oVmFsID0gQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIuY2hlY2tWYWxpZEludFZhbHVlKG1vaCk7XG5cbiAgICAgICAgICBpZiAoc29tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBzb21WYWwgPSBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLmNoZWNrVmFsaWRJbnRWYWx1ZShzb20pO1xuXG4gICAgICAgICAgICBpZiAobm9zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIG5vc1ZhbCA9IENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELmNoZWNrVmFsaWRJbnRWYWx1ZShub3MpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwsIHNvbVZhbCwgbm9zVmFsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgbW9oVmFsLCBzb21WYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZE9iamVjdChMb2NhbFRpbWUub2YoaG9kVmFsLCBtb2hWYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNvbSA9PSBudWxsICYmIG5vcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mKGhvZFZhbCwgMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaG9kICE9IG51bGwpIHtcbiAgICAgICAgdmFyIF9ob2RWYWwgPSBob2Q7XG5cbiAgICAgICAgaWYgKG1vaCAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHNvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgbm9zID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsTmFub3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoX2hvZFZhbCwgMzYwMDAwMDAwMDAwMCk7XG4gICAgICAgICAgICB0b3RhbE5hbm9zID0gTWF0aFV0aWwuc2FmZUFkZCh0b3RhbE5hbm9zLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkobW9oLCA2MDAwMDAwMDAwMCkpO1xuICAgICAgICAgICAgdG90YWxOYW5vcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxOYW5vcywgTWF0aFV0aWwuc2FmZU11bHRpcGx5KHNvbSwgMTAwMDAwMDAwMCkpO1xuICAgICAgICAgICAgdG90YWxOYW5vcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxOYW5vcywgbm9zKTtcbiAgICAgICAgICAgIHZhciBleGNlc3NEYXlzID0gTWF0aFV0aWwuZmxvb3JEaXYodG90YWxOYW5vcywgODY0MDAwMDAwMDAwMDApO1xuICAgICAgICAgICAgdmFyIG5vZCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdGFsTmFub3MsIDg2NDAwMDAwMDAwMDAwKTtcblxuICAgICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZk5hbm9PZkRheShub2QpKTtcblxuICAgICAgICAgICAgdGhpcy5leGNlc3NEYXlzID0gUGVyaW9kLm9mRGF5cyhleGNlc3NEYXlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRvdGFsU2VjcyA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShfaG9kVmFsLCAzNjAwKTtcbiAgICAgICAgICAgIHRvdGFsU2VjcyA9IE1hdGhVdGlsLnNhZmVBZGQodG90YWxTZWNzLCBNYXRoVXRpbC5zYWZlTXVsdGlwbHkobW9oLCA2MCkpO1xuXG4gICAgICAgICAgICB2YXIgX2V4Y2Vzc0RheXMgPSBNYXRoVXRpbC5mbG9vckRpdih0b3RhbFNlY3MsIDg2NDAwKTtcblxuICAgICAgICAgICAgdmFyIHNvZCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdGFsU2VjcywgODY0MDApO1xuXG4gICAgICAgICAgICB0aGlzLl9hZGRPYmplY3QoTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkoc29kKSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXhjZXNzRGF5cyA9IFBlcmlvZC5vZkRheXMoX2V4Y2Vzc0RheXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2V4Y2Vzc0RheXMyID0gTWF0aFV0aWwuc2FmZVRvSW50KE1hdGhVdGlsLmZsb29yRGl2KF9ob2RWYWwsIDI0KSk7XG5cbiAgICAgICAgICBfaG9kVmFsID0gTWF0aFV0aWwuZmxvb3JNb2QoX2hvZFZhbCwgMjQpO1xuXG4gICAgICAgICAgdGhpcy5fYWRkT2JqZWN0KExvY2FsVGltZS5vZihfaG9kVmFsLCAwKSk7XG5cbiAgICAgICAgICB0aGlzLmV4Y2Vzc0RheXMgPSBQZXJpb2Qub2ZEYXlzKF9leGNlc3NEYXlzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSk7XG4gICAgdGhpcy5maWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuTUlOVVRFX09GX0hPVVIpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUpO1xuICAgIHRoaXMuZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZE9iamVjdCA9IGZ1bmN0aW9uIF9hZGRPYmplY3QoZGF0ZU9yVGltZSkge1xuICAgIGlmIChkYXRlT3JUaW1lIGluc3RhbmNlb2YgQ2hyb25vTG9jYWxEYXRlKSB7XG4gICAgICB0aGlzLmRhdGUgPSBkYXRlT3JUaW1lO1xuICAgIH0gZWxzZSBpZiAoZGF0ZU9yVGltZSBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgdGhpcy50aW1lID0gZGF0ZU9yVGltZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9yZXNvbHZlSW5zdGFudCA9IGZ1bmN0aW9uIF9yZXNvbHZlSW5zdGFudCgpIHtcbiAgICBpZiAodGhpcy5kYXRlICE9IG51bGwgJiYgdGhpcy50aW1lICE9IG51bGwpIHtcbiAgICAgIHZhciBvZmZzZXRTZWNzID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpO1xuXG4gICAgICBpZiAob2Zmc2V0U2VjcyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKG9mZnNldFNlY3MpO1xuICAgICAgICB2YXIgaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUob2Zmc2V0KS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICAgIHRoaXMuZmllbGRWYWx1ZXMucHV0KENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUywgaW5zdGFudCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBfaW5zdGFudCA9IHRoaXMuZGF0ZS5hdFRpbWUodGhpcy50aW1lKS5hdFpvbmUodGhpcy56b25lKS5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG5cbiAgICAgICAgdGhpcy5maWVsZFZhbHVlcy5wdXQoQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTLCBfaW5zdGFudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KGZpZWxkKSAmJiB0aGlzLmZpZWxkVmFsdWVzLmdldChmaWVsZCkgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLmRhdGUuaXNTdXBwb3J0ZWQoZmllbGQpIHx8IHRoaXMudGltZSAhPSBudWxsICYmIHRoaXMudGltZS5pc1N1cHBvcnRlZChmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RmllbGRWYWx1ZTAoZmllbGQpO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmRhdGUgIT0gbnVsbCAmJiB0aGlzLmRhdGUuaXNTdXBwb3J0ZWQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRpbWUgIT0gbnVsbCAmJiB0aGlzLnRpbWUuaXNTdXBwb3J0ZWQoZmllbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkZpZWxkIG5vdCBmb3VuZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hyb25vO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGUgIT0gbnVsbCA/IExvY2FsRGF0ZS5mcm9tKHRoaXMuZGF0ZSkgOiBudWxsO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWU7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMucHJlY2lzaW9uKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGltZUJ1aWxkZXI7XG59KFRlbXBvcmFsQWNjZXNzb3IpO1xuXG52YXIgRGF0ZVRpbWVQYXJzZUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGVUaW1lUGFyc2VDb250ZXh0KCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRGF0ZVRpbWVQYXJzZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0b3JTZWxmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0b3JGb3JtYXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29uc3RydWN0b3JQYXJhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nhc2VTZW5zaXRpdmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmljdCA9IHRydWU7XG4gICAgdGhpcy5fcGFyc2VkID0gW25ldyBQYXJzZWQodGhpcyldO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERhdGVUaW1lUGFyc2VDb250ZXh0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2NvbnN0cnVjdG9yUGFyYW0gPSBmdW5jdGlvbiBfY29uc3RydWN0b3JQYXJhbShsb2NhbGUsIHN5bWJvbHMsIGNocm9ub2xvZ3kpIHtcbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5fc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgdGhpcy5fb3ZlcnJpZGVDaHJvbm9sb2d5ID0gY2hyb25vbG9neTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbnN0cnVjdG9yRm9ybWF0dGVyID0gZnVuY3Rpb24gX2NvbnN0cnVjdG9yRm9ybWF0dGVyKGZvcm1hdHRlcikge1xuICAgIHRoaXMuX2xvY2FsZSA9IGZvcm1hdHRlci5sb2NhbGUoKTtcbiAgICB0aGlzLl9zeW1ib2xzID0gZm9ybWF0dGVyLmRlY2ltYWxTdHlsZSgpO1xuICAgIHRoaXMuX292ZXJyaWRlQ2hyb25vbG9neSA9IGZvcm1hdHRlci5jaHJvbm9sb2d5KCk7XG4gIH07XG5cbiAgX3Byb3RvLl9jb25zdHJ1Y3RvclNlbGYgPSBmdW5jdGlvbiBfY29uc3RydWN0b3JTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5fbG9jYWxlID0gb3RoZXIuX2xvY2FsZTtcbiAgICB0aGlzLl9zeW1ib2xzID0gb3RoZXIuX3N5bWJvbHM7XG4gICAgdGhpcy5fb3ZlcnJpZGVDaHJvbm9sb2d5ID0gb3RoZXIuX292ZXJyaWRlQ2hyb25vbG9neTtcbiAgICB0aGlzLl9vdmVycmlkZVpvbmUgPSBvdGhlci5fb3ZlcnJpZGVab25lO1xuICAgIHRoaXMuX2Nhc2VTZW5zaXRpdmUgPSBvdGhlci5fY2FzZVNlbnNpdGl2ZTtcbiAgICB0aGlzLl9zdHJpY3QgPSBvdGhlci5fc3RyaWN0O1xuICAgIHRoaXMuX3BhcnNlZCA9IFtuZXcgUGFyc2VkKHRoaXMpXTtcbiAgfTtcblxuICBfcHJvdG8uY29weSA9IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZVBhcnNlQ29udGV4dCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uc3ltYm9scyA9IGZ1bmN0aW9uIHN5bWJvbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bWJvbHM7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3RyaWN0ID0gZnVuY3Rpb24gaXNTdHJpY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmljdDtcbiAgfTtcblxuICBfcHJvdG8uc2V0U3RyaWN0ID0gZnVuY3Rpb24gc2V0U3RyaWN0KHN0cmljdCkge1xuICAgIHRoaXMuX3N0cmljdCA9IHN0cmljdDtcbiAgfTtcblxuICBfcHJvdG8ubG9jYWxlID0gZnVuY3Rpb24gbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH07XG5cbiAgX3Byb3RvLnNldExvY2FsZSA9IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0T3B0aW9uYWwgPSBmdW5jdGlvbiBzdGFydE9wdGlvbmFsKCkge1xuICAgIHRoaXMuX3BhcnNlZC5wdXNoKHRoaXMuY3VycmVudFBhcnNlZCgpLmNvcHkoKSk7XG4gIH07XG5cbiAgX3Byb3RvLmVuZE9wdGlvbmFsID0gZnVuY3Rpb24gZW5kT3B0aW9uYWwoc3VjY2Vzc2Z1bCkge1xuICAgIGlmIChzdWNjZXNzZnVsKSB7XG4gICAgICB0aGlzLl9wYXJzZWQuc3BsaWNlKHRoaXMuX3BhcnNlZC5sZW5ndGggLSAyLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VkLnNwbGljZSh0aGlzLl9wYXJzZWQubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pc0Nhc2VTZW5zaXRpdmUgPSBmdW5jdGlvbiBpc0Nhc2VTZW5zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc2VTZW5zaXRpdmU7XG4gIH07XG5cbiAgX3Byb3RvLnNldENhc2VTZW5zaXRpdmUgPSBmdW5jdGlvbiBzZXRDYXNlU2Vuc2l0aXZlKGNhc2VTZW5zaXRpdmUpIHtcbiAgICB0aGlzLl9jYXNlU2Vuc2l0aXZlID0gY2FzZVNlbnNpdGl2ZTtcbiAgfTtcblxuICBfcHJvdG8uc3ViU2VxdWVuY2VFcXVhbHMgPSBmdW5jdGlvbiBzdWJTZXF1ZW5jZUVxdWFscyhjczEsIG9mZnNldDEsIGNzMiwgb2Zmc2V0MiwgbGVuZ3RoKSB7XG4gICAgaWYgKG9mZnNldDEgKyBsZW5ndGggPiBjczEubGVuZ3RoIHx8IG9mZnNldDIgKyBsZW5ndGggPiBjczIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQ2FzZVNlbnNpdGl2ZSgpKSB7XG4gICAgICBjczEgPSBjczEudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNzMiA9IGNzMi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaDEgPSBjczFbb2Zmc2V0MSArIGldO1xuICAgICAgdmFyIGNoMiA9IGNzMltvZmZzZXQyICsgaV07XG5cbiAgICAgIGlmIChjaDEgIT09IGNoMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmNoYXJFcXVhbHMgPSBmdW5jdGlvbiBjaGFyRXF1YWxzKGNoMSwgY2gyKSB7XG4gICAgaWYgKHRoaXMuaXNDYXNlU2Vuc2l0aXZlKCkpIHtcbiAgICAgIHJldHVybiBjaDEgPT09IGNoMjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jaGFyRXF1YWxzSWdub3JlQ2FzZShjaDEsIGNoMik7XG4gIH07XG5cbiAgX3Byb3RvLmNoYXJFcXVhbHNJZ25vcmVDYXNlID0gZnVuY3Rpb24gY2hhckVxdWFsc0lnbm9yZUNhc2UoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMxID09PSBjMiB8fCBjMS50b0xvd2VyQ2FzZSgpID09PSBjMi50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIF9wcm90by5zZXRQYXJzZWRGaWVsZCA9IGZ1bmN0aW9uIHNldFBhcnNlZEZpZWxkKGZpZWxkLCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpIHtcbiAgICB2YXIgY3VycmVudFBhcnNlZEZpZWxkVmFsdWVzID0gdGhpcy5jdXJyZW50UGFyc2VkKCkuZmllbGRWYWx1ZXM7XG4gICAgdmFyIG9sZCA9IGN1cnJlbnRQYXJzZWRGaWVsZFZhbHVlcy5nZXQoZmllbGQpO1xuICAgIGN1cnJlbnRQYXJzZWRGaWVsZFZhbHVlcy5zZXQoZmllbGQsIHZhbHVlKTtcbiAgICByZXR1cm4gb2xkICE9IG51bGwgJiYgb2xkICE9PSB2YWx1ZSA/IH5lcnJvclBvcyA6IHN1Y2Nlc3NQb3M7XG4gIH07XG5cbiAgX3Byb3RvLnNldFBhcnNlZFpvbmUgPSBmdW5jdGlvbiBzZXRQYXJzZWRab25lKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHRoaXMuY3VycmVudFBhcnNlZCgpLnpvbmUgPSB6b25lO1xuICB9O1xuXG4gIF9wcm90by5nZXRQYXJzZWQgPSBmdW5jdGlvbiBnZXRQYXJzZWQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFyc2VkKCkuZmllbGRWYWx1ZXMuZ2V0KGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8udG9QYXJzZWQgPSBmdW5jdGlvbiB0b1BhcnNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFyc2VkKCk7XG4gIH07XG5cbiAgX3Byb3RvLmN1cnJlbnRQYXJzZWQgPSBmdW5jdGlvbiBjdXJyZW50UGFyc2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJzZWRbdGhpcy5fcGFyc2VkLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIF9wcm90by5zZXRQYXJzZWRMZWFwU2Vjb25kID0gZnVuY3Rpb24gc2V0UGFyc2VkTGVhcFNlY29uZCgpIHtcbiAgICB0aGlzLmN1cnJlbnRQYXJzZWQoKS5sZWFwU2Vjb25kID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RWZmZWN0aXZlQ2hyb25vbG9neSA9IGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUNocm9ub2xvZ3koKSB7XG4gICAgdmFyIGNocm9ubyA9IHRoaXMuY3VycmVudFBhcnNlZCgpLmNocm9ubztcblxuICAgIGlmIChjaHJvbm8gPT0gbnVsbCkge1xuICAgICAgY2hyb25vID0gdGhpcy5fb3ZlcnJpZGVDaHJvbm9sb2d5O1xuXG4gICAgICBpZiAoY2hyb25vID09IG51bGwpIHtcbiAgICAgICAgY2hyb25vID0gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hyb25vO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGltZVBhcnNlQ29udGV4dDtcbn0oKTtcblxudmFyIFBhcnNlZCA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoUGFyc2VkLCBfVGVtcG9yYWwpO1xuXG4gIGZ1bmN0aW9uIFBhcnNlZChkYXRlVGltZVBhcnNlQ29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5jaHJvbm8gPSBudWxsO1xuICAgIF90aGlzLnpvbmUgPSBudWxsO1xuICAgIF90aGlzLmZpZWxkVmFsdWVzID0gbmV3IEVudW1NYXAoKTtcbiAgICBfdGhpcy5sZWFwU2Vjb25kID0gZmFsc2U7XG4gICAgX3RoaXMuZGF0ZVRpbWVQYXJzZUNvbnRleHQgPSBkYXRlVGltZVBhcnNlQ29udGV4dDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFBhcnNlZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5jb3B5ID0gZnVuY3Rpb24gY29weSgpIHtcbiAgICB2YXIgY2xvbmVkID0gbmV3IFBhcnNlZCgpO1xuICAgIGNsb25lZC5jaHJvbm8gPSB0aGlzLmNocm9ubztcbiAgICBjbG9uZWQuem9uZSA9IHRoaXMuem9uZTtcbiAgICBjbG9uZWQuZmllbGRWYWx1ZXMucHV0QWxsKHRoaXMuZmllbGRWYWx1ZXMpO1xuICAgIGNsb25lZC5sZWFwU2Vjb25kID0gdGhpcy5sZWFwU2Vjb25kO1xuICAgIGNsb25lZC5kYXRlVGltZVBhcnNlQ29udGV4dCA9IHRoaXMuZGF0ZVRpbWVQYXJzZUNvbnRleHQ7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRWYWx1ZXMgKyBcIiwgXCIgKyB0aGlzLmNocm9ubyArIFwiLCBcIiArIHRoaXMuem9uZTtcbiAgfTtcblxuICBfcHJvdG8yLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5maWVsZFZhbHVlcy5jb250YWluc0tleShmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICB2YXIgdmFsID0gdGhpcy5maWVsZFZhbHVlcy5nZXQoZmllbGQpO1xuICAgIGFzc2VydCh2YWwgIT0gbnVsbCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBfcHJvdG8yLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hyb25vO1xuICAgIH1cblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90bzIudG9CdWlsZGVyID0gZnVuY3Rpb24gdG9CdWlsZGVyKCkge1xuICAgIHZhciBidWlsZGVyID0gbmV3IERhdGVUaW1lQnVpbGRlcigpO1xuICAgIGJ1aWxkZXIuZmllbGRWYWx1ZXMucHV0QWxsKHRoaXMuZmllbGRWYWx1ZXMpO1xuICAgIGJ1aWxkZXIuY2hyb25vID0gdGhpcy5kYXRlVGltZVBhcnNlQ29udGV4dC5nZXRFZmZlY3RpdmVDaHJvbm9sb2d5KCk7XG5cbiAgICBpZiAodGhpcy56b25lICE9IG51bGwpIHtcbiAgICAgIGJ1aWxkZXIuem9uZSA9IHRoaXMuem9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVpbGRlci56b25lID0gdGhpcy5vdmVycmlkZVpvbmU7XG4gICAgfVxuXG4gICAgYnVpbGRlci5sZWFwU2Vjb25kID0gdGhpcy5sZWFwU2Vjb25kO1xuICAgIGJ1aWxkZXIuZXhjZXNzRGF5cyA9IHRoaXMuZXhjZXNzRGF5cztcbiAgICByZXR1cm4gYnVpbGRlcjtcbiAgfTtcblxuICByZXR1cm4gUGFyc2VkO1xufShUZW1wb3JhbCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIERhdGVUaW1lUHJpbnRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRlVGltZVByaW50Q29udGV4dCh0ZW1wb3JhbCwgbG9jYWxlT3JGb3JtYXR0ZXIsIHN5bWJvbHMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBEYXRlVGltZUZvcm1hdHRlcikge1xuICAgICAgdGhpcy5fdGVtcG9yYWwgPSBEYXRlVGltZVByaW50Q29udGV4dC5hZGp1c3QodGVtcG9yYWwsIGxvY2FsZU9yRm9ybWF0dGVyKTtcbiAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZU9yRm9ybWF0dGVyLmxvY2FsZSgpO1xuICAgICAgdGhpcy5fc3ltYm9scyA9IGxvY2FsZU9yRm9ybWF0dGVyLmRlY2ltYWxTdHlsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wb3JhbCA9IHRlbXBvcmFsO1xuICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlT3JGb3JtYXR0ZXI7XG4gICAgICB0aGlzLl9zeW1ib2xzID0gc3ltYm9scztcbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25hbCA9IDA7XG4gIH1cblxuICBEYXRlVGltZVByaW50Q29udGV4dC5hZGp1c3QgPSBmdW5jdGlvbiBhZGp1c3QodGVtcG9yYWwsIGZvcm1hdHRlcikge1xuICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWVQcmludENvbnRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90by5zeW1ib2xzID0gZnVuY3Rpb24gc3ltYm9scygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ltYm9scztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRPcHRpb25hbCA9IGZ1bmN0aW9uIHN0YXJ0T3B0aW9uYWwoKSB7XG4gICAgdGhpcy5fb3B0aW9uYWwrKztcbiAgfTtcblxuICBfcHJvdG8uZW5kT3B0aW9uYWwgPSBmdW5jdGlvbiBlbmRPcHRpb25hbCgpIHtcbiAgICB0aGlzLl9vcHRpb25hbC0tO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZVF1ZXJ5ID0gZnVuY3Rpb24gZ2V0VmFsdWVRdWVyeShxdWVyeSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLl90ZW1wb3JhbC5xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgdGhpcy5fb3B0aW9uYWwgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBleHRyYWN0IHZhbHVlOiBcIiArIHRoaXMuX3RlbXBvcmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGZpZWxkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl90ZW1wb3JhbC5nZXRMb25nKGZpZWxkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRGF0ZVRpbWVFeGNlcHRpb24gJiYgdGhpcy5fb3B0aW9uYWwgPiAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRlbXBvcmFsID0gZnVuY3Rpb24gdGVtcG9yYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RlbXBvcmFsO1xuICB9O1xuXG4gIF9wcm90by5sb2NhbGUgPSBmdW5jdGlvbiBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgfTtcblxuICBfcHJvdG8uc2V0RGF0ZVRpbWUgPSBmdW5jdGlvbiBzZXREYXRlVGltZSh0ZW1wb3JhbCkge1xuICAgIHRoaXMuX3RlbXBvcmFsID0gdGVtcG9yYWw7XG4gIH07XG5cbiAgX3Byb3RvLnNldExvY2FsZSA9IGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIERhdGVUaW1lUHJpbnRDb250ZXh0O1xufSgpO1xuXG52YXIgSXNvRmllbGRzID0ge307XG52YXIgUVVBUlRFUl9EQVlTID0gWzAsIDkwLCAxODEsIDI3MywgMCwgOTEsIDE4MiwgMjc0XTtcblxudmFyIEZpZWxkID0gZnVuY3Rpb24gKF9UZW1wb3JhbEZpZWxkKSB7XG4gIF9pbmhlcml0c0xvb3NlKEZpZWxkLCBfVGVtcG9yYWxGaWVsZCk7XG5cbiAgZnVuY3Rpb24gRmllbGQoKSB7XG4gICAgcmV0dXJuIF9UZW1wb3JhbEZpZWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGaWVsZC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzRGF0ZUJhc2VkID0gZnVuY3Rpb24gaXNEYXRlQmFzZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5faXNJc28gPSBmdW5jdGlvbiBfaXNJc28oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgRmllbGQuX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlID0gZnVuY3Rpb24gX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlKGRhdGUpIHtcbiAgICB2YXIgd2J5ID0gRmllbGQuX2dldFdlZWtCYXNlZFllYXIoZGF0ZSk7XG5cbiAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCBGaWVsZC5fZ2V0V2Vla1JhbmdlQnlZZWFyKHdieSkpO1xuICB9O1xuXG4gIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeVllYXIgPSBmdW5jdGlvbiBfZ2V0V2Vla1JhbmdlQnlZZWFyKHdieSkge1xuICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLm9mKHdieSwgMSwgMSk7XG5cbiAgICBpZiAoZGF0ZS5kYXlPZldlZWsoKSA9PT0gRGF5T2ZXZWVrLlRIVVJTREFZIHx8IGRhdGUuZGF5T2ZXZWVrKCkgPT09IERheU9mV2Vlay5XRURORVNEQVkgJiYgZGF0ZS5pc0xlYXBZZWFyKCkpIHtcbiAgICAgIHJldHVybiA1MztcbiAgICB9XG5cbiAgICByZXR1cm4gNTI7XG4gIH07XG5cbiAgRmllbGQuX2dldFdlZWsgPSBmdW5jdGlvbiBfZ2V0V2VlayhkYXRlKSB7XG4gICAgdmFyIGRvdzAgPSBkYXRlLmRheU9mV2VlaygpLm9yZGluYWwoKTtcbiAgICB2YXIgZG95MCA9IGRhdGUuZGF5T2ZZZWFyKCkgLSAxO1xuICAgIHZhciBkb3lUaHUwID0gZG95MCArICgzIC0gZG93MCk7XG4gICAgdmFyIGFsaWduZWRXZWVrID0gTWF0aFV0aWwuaW50RGl2KGRveVRodTAsIDcpO1xuICAgIHZhciBmaXJzdFRodURveTAgPSBkb3lUaHUwIC0gYWxpZ25lZFdlZWsgKiA3O1xuICAgIHZhciBmaXJzdE1vbkRveTAgPSBmaXJzdFRodURveTAgLSAzO1xuXG4gICAgaWYgKGZpcnN0TW9uRG95MCA8IC0zKSB7XG4gICAgICBmaXJzdE1vbkRveTAgKz0gNztcbiAgICB9XG5cbiAgICBpZiAoZG95MCA8IGZpcnN0TW9uRG95MCkge1xuICAgICAgcmV0dXJuIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeUxvY2FsRGF0ZShkYXRlLndpdGhEYXlPZlllYXIoMTgwKS5taW51c1llYXJzKDEpKS5tYXhpbXVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHdlZWsgPSBNYXRoVXRpbC5pbnREaXYoZG95MCAtIGZpcnN0TW9uRG95MCwgNykgKyAxO1xuXG4gICAgaWYgKHdlZWsgPT09IDUzKSB7XG4gICAgICBpZiAoKGZpcnN0TW9uRG95MCA9PT0gLTMgfHwgZmlyc3RNb25Eb3kwID09PSAtMiAmJiBkYXRlLmlzTGVhcFllYXIoKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHdlZWsgPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3ZWVrO1xuICB9O1xuXG4gIEZpZWxkLl9nZXRXZWVrQmFzZWRZZWFyID0gZnVuY3Rpb24gX2dldFdlZWtCYXNlZFllYXIoZGF0ZSkge1xuICAgIHZhciB5ZWFyID0gZGF0ZS55ZWFyKCk7XG4gICAgdmFyIGRveSA9IGRhdGUuZGF5T2ZZZWFyKCk7XG5cbiAgICBpZiAoZG95IDw9IDMpIHtcbiAgICAgIHZhciBkb3cgPSBkYXRlLmRheU9mV2VlaygpLm9yZGluYWwoKTtcblxuICAgICAgaWYgKGRveSAtIGRvdyA8IC0yKSB7XG4gICAgICAgIHllYXItLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRveSA+PSAzNjMpIHtcbiAgICAgIHZhciBfZG93ID0gZGF0ZS5kYXlPZldlZWsoKS5vcmRpbmFsKCk7XG5cbiAgICAgIGRveSA9IGRveSAtIDM2MyAtIChkYXRlLmlzTGVhcFllYXIoKSA/IDEgOiAwKTtcblxuICAgICAgaWYgKGRveSAtIF9kb3cgPj0gMCkge1xuICAgICAgICB5ZWFyKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHllYXI7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEZpZWxkO1xufShUZW1wb3JhbEZpZWxkKTtcblxudmFyIERBWV9PRl9RVUFSVEVSX0ZJRUxEID0gZnVuY3Rpb24gKF9GaWVsZCkge1xuICBfaW5oZXJpdHNMb29zZShEQVlfT0ZfUVVBUlRFUl9GSUVMRCwgX0ZpZWxkKTtcblxuICBmdW5jdGlvbiBEQVlfT0ZfUVVBUlRFUl9GSUVMRCgpIHtcbiAgICByZXR1cm4gX0ZpZWxkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gREFZX09GX1FVQVJURVJfRklFTEQucHJvdG90eXBlO1xuXG4gIF9wcm90bzIudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ0RheU9mUXVhcnRlcic7XG4gIH07XG5cbiAgX3Byb3RvMi5iYXNlVW5pdCA9IGZ1bmN0aW9uIGJhc2VVbml0KCkge1xuICAgIHJldHVybiBDaHJvbm9Vbml0LkRBWVM7XG4gIH07XG5cbiAgX3Byb3RvMi5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIFFVQVJURVJfWUVBUlM7XG4gIH07XG5cbiAgX3Byb3RvMi5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDkwLCA5Mik7XG4gIH07XG5cbiAgX3Byb3RvMi5pc1N1cHBvcnRlZEJ5ID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUikgJiYgdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikgJiYgdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuWUVBUikgJiYgdGhpcy5faXNJc28odGVtcG9yYWwpO1xuICB9O1xuXG4gIF9wcm90bzIucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IERheU9mUXVhcnRlcicpO1xuICAgIH1cblxuICAgIHZhciBxb3kgPSB0ZW1wb3JhbC5nZXRMb25nKFFVQVJURVJfT0ZfWUVBUik7XG5cbiAgICBpZiAocW95ID09PSAxKSB7XG4gICAgICB2YXIgeWVhciA9IHRlbXBvcmFsLmdldExvbmcoQ2hyb25vRmllbGQuWUVBUik7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHllYXIpID8gVmFsdWVSYW5nZS5vZigxLCA5MSkgOiBWYWx1ZVJhbmdlLm9mKDEsIDkwKTtcbiAgICB9IGVsc2UgaWYgKHFveSA9PT0gMikge1xuICAgICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgOTEpO1xuICAgIH0gZWxzZSBpZiAocW95ID09PSAzIHx8IHFveSA9PT0gNCkge1xuICAgICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgOTIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJhbmdlKCk7XG4gIH07XG5cbiAgX3Byb3RvMi5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IERheU9mUXVhcnRlcicpO1xuICAgIH1cblxuICAgIHZhciBkb3kgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpO1xuICAgIHZhciBtb3kgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUik7XG4gICAgdmFyIHllYXIgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLllFQVIpO1xuICAgIHJldHVybiBkb3kgLSBRVUFSVEVSX0RBWVNbTWF0aFV0aWwuaW50RGl2KG1veSAtIDEsIDMpICsgKElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKSA/IDQgOiAwKV07XG4gIH07XG5cbiAgX3Byb3RvMi5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCwgbmV3VmFsdWUpIHtcbiAgICB2YXIgY3VyVmFsdWUgPSB0aGlzLmdldEZyb20odGVtcG9yYWwpO1xuICAgIHRoaXMucmFuZ2UoKS5jaGVja1ZhbGlkVmFsdWUobmV3VmFsdWUsIHRoaXMpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLCB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSKSArIChuZXdWYWx1ZSAtIGN1clZhbHVlKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmaWVsZFZhbHVlcywgcGFydGlhbFRlbXBvcmFsLCByZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIHllYXJMb25nID0gZmllbGRWYWx1ZXMuZ2V0KENocm9ub0ZpZWxkLllFQVIpO1xuICAgIHZhciBxb3lMb25nID0gZmllbGRWYWx1ZXMuZ2V0KFFVQVJURVJfT0ZfWUVBUik7XG5cbiAgICBpZiAoeWVhckxvbmcgPT0gbnVsbCB8fCBxb3lMb25nID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB5ID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoeWVhckxvbmcpO1xuICAgIHZhciBkb3EgPSBmaWVsZFZhbHVlcy5nZXQoREFZX09GX1FVQVJURVIpO1xuICAgIHZhciBkYXRlO1xuXG4gICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgdmFyIHFveSA9IHFveUxvbmc7XG4gICAgICBkYXRlID0gTG9jYWxEYXRlLm9mKHksIDEsIDEpO1xuICAgICAgZGF0ZSA9IGRhdGUucGx1c01vbnRocyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KHFveSwgMSksIDMpKTtcbiAgICAgIGRhdGUgPSBkYXRlLnBsdXNEYXlzKE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChkb3EsIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9xb3kgPSBRVUFSVEVSX09GX1lFQVIucmFuZ2UoKS5jaGVja1ZhbGlkSW50VmFsdWUocW95TG9uZywgUVVBUlRFUl9PRl9ZRUFSKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU1RSSUNUKSB7XG4gICAgICAgIHZhciBtYXggPSA5MjtcblxuICAgICAgICBpZiAoX3FveSA9PT0gMSkge1xuICAgICAgICAgIG1heCA9IElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5KSA/IDkxIDogOTA7XG4gICAgICAgIH0gZWxzZSBpZiAoX3FveSA9PT0gMikge1xuICAgICAgICAgIG1heCA9IDkxO1xuICAgICAgICB9XG5cbiAgICAgICAgVmFsdWVSYW5nZS5vZigxLCBtYXgpLmNoZWNrVmFsaWRWYWx1ZShkb3EsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZShkb3EsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBkYXRlID0gTG9jYWxEYXRlLm9mKHksIChfcW95IC0gMSkgKiAzICsgMSwgMSkucGx1c0RheXMoZG9xIC0gMSk7XG4gICAgfVxuXG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKHRoaXMpO1xuICAgIGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKTtcbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUoUVVBUlRFUl9PRl9ZRUFSKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcblxuICByZXR1cm4gREFZX09GX1FVQVJURVJfRklFTEQ7XG59KEZpZWxkKTtcblxudmFyIFFVQVJURVJfT0ZfWUVBUl9GSUVMRCA9IGZ1bmN0aW9uIChfRmllbGQyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFFVQVJURVJfT0ZfWUVBUl9GSUVMRCwgX0ZpZWxkMik7XG5cbiAgZnVuY3Rpb24gUVVBUlRFUl9PRl9ZRUFSX0ZJRUxEKCkge1xuICAgIHJldHVybiBfRmllbGQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gUVVBUlRFUl9PRl9ZRUFSX0ZJRUxELnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdRdWFydGVyT2ZZZWFyJztcbiAgfTtcblxuICBfcHJvdG8zLmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIFFVQVJURVJfWUVBUlM7XG4gIH07XG5cbiAgX3Byb3RvMy5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuWUVBUlM7XG4gIH07XG5cbiAgX3Byb3RvMy5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKCkge1xuICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIDQpO1xuICB9O1xuXG4gIF9wcm90bzMuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUikgJiYgdGhpcy5faXNJc28odGVtcG9yYWwpO1xuICB9O1xuXG4gIF9wcm90bzMucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKCk7XG4gIH07XG5cbiAgX3Byb3RvMy5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IFF1YXJ0ZXJPZlllYXInKTtcbiAgICB9XG5cbiAgICB2YXIgbW95ID0gdGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKTtcbiAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KG1veSArIDIsIDMpO1xuICB9O1xuXG4gIF9wcm90bzMuYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgdmFyIGN1clZhbHVlID0gdGhpcy5nZXRGcm9tKHRlbXBvcmFsKTtcbiAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlLCB0aGlzKTtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpICsgKG5ld1ZhbHVlIC0gY3VyVmFsdWUpICogMyk7XG4gIH07XG5cbiAgcmV0dXJuIFFVQVJURVJfT0ZfWUVBUl9GSUVMRDtcbn0oRmllbGQpO1xuXG52YXIgV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQgPSBmdW5jdGlvbiAoX0ZpZWxkMykge1xuICBfaW5oZXJpdHNMb29zZShXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRCwgX0ZpZWxkMyk7XG5cbiAgZnVuY3Rpb24gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQoKSB7XG4gICAgcmV0dXJuIF9GaWVsZDMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzQgPSBXRUVLX09GX1dFRUtfQkFTRURfWUVBUl9GSUVMRC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnV2Vla09mV2Vla0Jhc2VkWWVhcic7XG4gIH07XG5cbiAgX3Byb3RvNC5iYXNlVW5pdCA9IGZ1bmN0aW9uIGJhc2VVbml0KCkge1xuICAgIHJldHVybiBDaHJvbm9Vbml0LldFRUtTO1xuICB9O1xuXG4gIF9wcm90bzQucmFuZ2VVbml0ID0gZnVuY3Rpb24gcmFuZ2VVbml0KCkge1xuICAgIHJldHVybiBXRUVLX0JBU0VEX1lFQVJTO1xuICB9O1xuXG4gIF9wcm90bzQucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSgpIHtcbiAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCA1MiwgNTMpO1xuICB9O1xuXG4gIF9wcm90bzQuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSAmJiB0aGlzLl9pc0lzbyh0ZW1wb3JhbCk7XG4gIH07XG5cbiAgX3Byb3RvNC5yYW5nZVJlZmluZWRCeSA9IGZ1bmN0aW9uIHJhbmdlUmVmaW5lZEJ5KHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla09mV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cblxuICAgIHJldHVybiBGaWVsZC5fZ2V0V2Vla1JhbmdlQnlMb2NhbERhdGUoTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpKTtcbiAgfTtcblxuICBfcHJvdG80LmdldEZyb20gPSBmdW5jdGlvbiBnZXRGcm9tKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla09mV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cblxuICAgIHJldHVybiBGaWVsZC5fZ2V0V2VlayhMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCkpO1xuICB9O1xuXG4gIF9wcm90bzQuYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwsIG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5yYW5nZSgpLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnBsdXMoTWF0aFV0aWwuc2FmZVN1YnRyYWN0KG5ld1ZhbHVlLCB0aGlzLmdldEZyb20odGVtcG9yYWwpKSwgQ2hyb25vVW5pdC5XRUVLUyk7XG4gIH07XG5cbiAgX3Byb3RvNC5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShmaWVsZFZhbHVlcywgcGFydGlhbFRlbXBvcmFsLCByZXNvbHZlclN0eWxlKSB7XG4gICAgdmFyIHdieUxvbmcgPSBmaWVsZFZhbHVlcy5nZXQoV0VFS19CQVNFRF9ZRUFSKTtcbiAgICB2YXIgZG93TG9uZyA9IGZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG5cbiAgICBpZiAod2J5TG9uZyA9PSBudWxsIHx8IGRvd0xvbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdieSA9IFdFRUtfQkFTRURfWUVBUi5yYW5nZSgpLmNoZWNrVmFsaWRJbnRWYWx1ZSh3YnlMb25nLCBXRUVLX0JBU0VEX1lFQVIpO1xuICAgIHZhciB3b3dieSA9IGZpZWxkVmFsdWVzLmdldChXRUVLX09GX1dFRUtfQkFTRURfWUVBUik7XG4gICAgdmFyIGRhdGU7XG5cbiAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICB2YXIgZG93ID0gZG93TG9uZztcbiAgICAgIHZhciB3ZWVrcyA9IDA7XG5cbiAgICAgIGlmIChkb3cgPiA3KSB7XG4gICAgICAgIHdlZWtzID0gTWF0aFV0aWwuaW50RGl2KGRvdyAtIDEsIDcpO1xuICAgICAgICBkb3cgPSBNYXRoVXRpbC5pbnRNb2QoZG93IC0gMSwgNykgKyAxO1xuICAgICAgfSBlbHNlIGlmIChkb3cgPCAxKSB7XG4gICAgICAgIHdlZWtzID0gTWF0aFV0aWwuaW50RGl2KGRvdywgNykgLSAxO1xuICAgICAgICBkb3cgPSBNYXRoVXRpbC5pbnRNb2QoZG93LCA3KSArIDc7XG4gICAgICB9XG5cbiAgICAgIGRhdGUgPSBMb2NhbERhdGUub2Yod2J5LCAxLCA0KS5wbHVzV2Vla3Mod293YnkgLSAxKS5wbHVzV2Vla3Mod2Vla3MpLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1dFRUssIGRvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZG93MiA9IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLmNoZWNrVmFsaWRJbnRWYWx1ZShkb3dMb25nKTtcblxuICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuU1RSSUNUKSB7XG4gICAgICAgIHZhciB0ZW1wID0gTG9jYWxEYXRlLm9mKHdieSwgMSwgNCk7XG5cbiAgICAgICAgdmFyIHJhbmdlID0gRmllbGQuX2dldFdlZWtSYW5nZUJ5TG9jYWxEYXRlKHRlbXApO1xuXG4gICAgICAgIHJhbmdlLmNoZWNrVmFsaWRWYWx1ZSh3b3dieSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZFZhbHVlKHdvd2J5LCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgZGF0ZSA9IExvY2FsRGF0ZS5vZih3YnksIDEsIDQpLnBsdXNXZWVrcyh3b3dieSAtIDEpLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1dFRUssIF9kb3cyKTtcbiAgICB9XG5cbiAgICBmaWVsZFZhbHVlcy5yZW1vdmUodGhpcyk7XG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKFdFRUtfQkFTRURfWUVBUik7XG4gICAgZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcblxuICBfcHJvdG80LmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gZGlzcGxheU5hbWUoKSB7XG4gICAgcmV0dXJuICdXZWVrJztcbiAgfTtcblxuICByZXR1cm4gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQ7XG59KEZpZWxkKTtcblxudmFyIFdFRUtfQkFTRURfWUVBUl9GSUVMRCA9IGZ1bmN0aW9uIChfRmllbGQ0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFdFRUtfQkFTRURfWUVBUl9GSUVMRCwgX0ZpZWxkNCk7XG5cbiAgZnVuY3Rpb24gV0VFS19CQVNFRF9ZRUFSX0ZJRUxEKCkge1xuICAgIHJldHVybiBfRmllbGQ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG81ID0gV0VFS19CQVNFRF9ZRUFSX0ZJRUxELnByb3RvdHlwZTtcblxuICBfcHJvdG81LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdXZWVrQmFzZWRZZWFyJztcbiAgfTtcblxuICBfcHJvdG81LmJhc2VVbml0ID0gZnVuY3Rpb24gYmFzZVVuaXQoKSB7XG4gICAgcmV0dXJuIFdFRUtfQkFTRURfWUVBUlM7XG4gIH07XG5cbiAgX3Byb3RvNS5yYW5nZVVuaXQgPSBmdW5jdGlvbiByYW5nZVVuaXQoKSB7XG4gICAgcmV0dXJuIENocm9ub1VuaXQuRk9SRVZFUjtcbiAgfTtcblxuICBfcHJvdG81LnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoKSB7XG4gICAgcmV0dXJuIENocm9ub0ZpZWxkLllFQVIucmFuZ2UoKTtcbiAgfTtcblxuICBfcHJvdG81LmlzU3VwcG9ydGVkQnkgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEJ5KHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLkVQT0NIX0RBWSkgJiYgdGhpcy5faXNJc28odGVtcG9yYWwpO1xuICB9O1xuXG4gIF9wcm90bzUucmFuZ2VSZWZpbmVkQnkgPSBmdW5jdGlvbiByYW5nZVJlZmluZWRCeSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBDaHJvbm9GaWVsZC5ZRUFSLnJhbmdlKCk7XG4gIH07XG5cbiAgX3Byb3RvNS5nZXRGcm9tID0gZnVuY3Rpb24gZ2V0RnJvbSh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbignVW5zdXBwb3J0ZWQgZmllbGQ6IFdlZWtCYXNlZFllYXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRmllbGQuX2dldFdlZWtCYXNlZFllYXIoTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpKTtcbiAgfTtcblxuICBfcHJvdG81LmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsLCBuZXdWYWx1ZSkge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQnkodGVtcG9yYWwpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBmaWVsZDogV2Vla0Jhc2VkWWVhcicpO1xuICAgIH1cblxuICAgIHZhciBuZXdXYnkgPSB0aGlzLnJhbmdlKCkuY2hlY2tWYWxpZEludFZhbHVlKG5ld1ZhbHVlLCBXRUVLX0JBU0VEX1lFQVIpO1xuICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLmZyb20odGVtcG9yYWwpO1xuICAgIHZhciBkb3cgPSBkYXRlLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG5cbiAgICB2YXIgd2VlayA9IEZpZWxkLl9nZXRXZWVrKGRhdGUpO1xuXG4gICAgaWYgKHdlZWsgPT09IDUzICYmIEZpZWxkLl9nZXRXZWVrUmFuZ2VCeVllYXIobmV3V2J5KSA9PT0gNTIpIHtcbiAgICAgIHdlZWsgPSA1MjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWQgPSBMb2NhbERhdGUub2YobmV3V2J5LCAxLCA0KTtcbiAgICB2YXIgZGF5cyA9IGRvdyAtIHJlc29sdmVkLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSykgKyAod2VlayAtIDEpICogNztcbiAgICByZXNvbHZlZCA9IHJlc29sdmVkLnBsdXNEYXlzKGRheXMpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKHJlc29sdmVkKTtcbiAgfTtcblxuICByZXR1cm4gV0VFS19CQVNFRF9ZRUFSX0ZJRUxEO1xufShGaWVsZCk7XG5cbnZhciBVbml0ID0gZnVuY3Rpb24gKF9UZW1wb3JhbFVuaXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVW5pdCwgX1RlbXBvcmFsVW5pdCk7XG5cbiAgZnVuY3Rpb24gVW5pdChuYW1lLCBlc3RpbWF0ZWREdXJhdGlvbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsVW5pdC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX25hbWUgPSBuYW1lO1xuICAgIF90aGlzLl9kdXJhdGlvbiA9IGVzdGltYXRlZER1cmF0aW9uO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG82ID0gVW5pdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNi5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgfTtcblxuICBfcHJvdG82LmlzRHVyYXRpb25Fc3RpbWF0ZWQgPSBmdW5jdGlvbiBpc0R1cmF0aW9uRXN0aW1hdGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90bzYuaXNEYXRlQmFzZWQgPSBmdW5jdGlvbiBpc0RhdGVCYXNlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG82LmlzVGltZUJhc2VkID0gZnVuY3Rpb24gaXNUaW1lQmFzZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzYuaXNTdXBwb3J0ZWRCeSA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkQnkodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuRVBPQ0hfREFZKTtcbiAgfTtcblxuICBfcHJvdG82LmFkZFRvID0gZnVuY3Rpb24gYWRkVG8odGVtcG9yYWwsIHBlcmlvZFRvQWRkKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFdFRUtfQkFTRURfWUVBUlM6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYWRkZWQgPSBNYXRoVXRpbC5zYWZlQWRkKHRlbXBvcmFsLmdldChXRUVLX0JBU0VEX1lFQVIpLCBwZXJpb2RUb0FkZCk7XG4gICAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoV0VFS19CQVNFRF9ZRUFSLCBhZGRlZCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBRVUFSVEVSX1lFQVJTOlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwucGx1cyhNYXRoVXRpbC5pbnREaXYocGVyaW9kVG9BZGQsIDI1NiksIENocm9ub1VuaXQuWUVBUlMpLnBsdXMoTWF0aFV0aWwuaW50TW9kKHBlcmlvZFRvQWRkLCAyNTYpICogMywgQ2hyb25vVW5pdC5NT05USFMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdVbnJlYWNoYWJsZScpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG82LmJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHRlbXBvcmFsMSwgdGVtcG9yYWwyKSB7XG4gICAgc3dpdGNoICh0aGlzKSB7XG4gICAgICBjYXNlIFdFRUtfQkFTRURfWUVBUlM6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlU3VidHJhY3QodGVtcG9yYWwyLmdldExvbmcoV0VFS19CQVNFRF9ZRUFSKSwgdGVtcG9yYWwxLmdldExvbmcoV0VFS19CQVNFRF9ZRUFSKSk7XG5cbiAgICAgIGNhc2UgUVVBUlRFUl9ZRUFSUzpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0ZW1wb3JhbDEudW50aWwodGVtcG9yYWwyLCBDaHJvbm9Vbml0Lk1PTlRIUyksIDMpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdVbnJlYWNoYWJsZScpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG82LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgcmV0dXJuIFVuaXQ7XG59KFRlbXBvcmFsVW5pdCk7XG5cbnZhciBEQVlfT0ZfUVVBUlRFUiA9IG51bGw7XG52YXIgUVVBUlRFUl9PRl9ZRUFSID0gbnVsbDtcbnZhciBXRUVLX09GX1dFRUtfQkFTRURfWUVBUiA9IG51bGw7XG52YXIgV0VFS19CQVNFRF9ZRUFSID0gbnVsbDtcbnZhciBXRUVLX0JBU0VEX1lFQVJTID0gbnVsbDtcbnZhciBRVUFSVEVSX1lFQVJTID0gbnVsbDtcbmZ1bmN0aW9uIF9pbml0JGYoKSB7XG4gIERBWV9PRl9RVUFSVEVSID0gbmV3IERBWV9PRl9RVUFSVEVSX0ZJRUxEKCk7XG4gIFFVQVJURVJfT0ZfWUVBUiA9IG5ldyBRVUFSVEVSX09GX1lFQVJfRklFTEQoKTtcbiAgV0VFS19PRl9XRUVLX0JBU0VEX1lFQVIgPSBuZXcgV0VFS19PRl9XRUVLX0JBU0VEX1lFQVJfRklFTEQoKTtcbiAgV0VFS19CQVNFRF9ZRUFSID0gbmV3IFdFRUtfQkFTRURfWUVBUl9GSUVMRCgpO1xuICBXRUVLX0JBU0VEX1lFQVJTID0gbmV3IFVuaXQoJ1dlZWtCYXNlZFllYXJzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyKSk7XG4gIFFVQVJURVJfWUVBUlMgPSBuZXcgVW5pdCgnUXVhcnRlclllYXJzJywgRHVyYXRpb24ub2ZTZWNvbmRzKDMxNTU2OTUyIC8gNCkpO1xuICBJc29GaWVsZHMuREFZX09GX1FVQVJURVIgPSBEQVlfT0ZfUVVBUlRFUjtcbiAgSXNvRmllbGRzLlFVQVJURVJfT0ZfWUVBUiA9IFFVQVJURVJfT0ZfWUVBUjtcbiAgSXNvRmllbGRzLldFRUtfT0ZfV0VFS19CQVNFRF9ZRUFSID0gV0VFS19PRl9XRUVLX0JBU0VEX1lFQVI7XG4gIElzb0ZpZWxkcy5XRUVLX0JBU0VEX1lFQVIgPSBXRUVLX0JBU0VEX1lFQVI7XG4gIElzb0ZpZWxkcy5XRUVLX0JBU0VEX1lFQVJTID0gV0VFS19CQVNFRF9ZRUFSUztcbiAgSXNvRmllbGRzLlFVQVJURVJfWUVBUlMgPSBRVUFSVEVSX1lFQVJTO1xuXG4gIExvY2FsRGF0ZS5wcm90b3R5cGUuaXNvV2Vla09mV2Vla3llYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KElzb0ZpZWxkcy5XRUVLX09GX1dFRUtfQkFTRURfWUVBUik7XG4gIH07XG5cbiAgTG9jYWxEYXRlLnByb3RvdHlwZS5pc29XZWVreWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoSXNvRmllbGRzLldFRUtfQkFTRURfWUVBUik7XG4gIH07XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBEZWNpbWFsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlY2ltYWxTdHlsZSh6ZXJvQ2hhciwgcG9zaXRpdmVTaWduQ2hhciwgbmVnYXRpdmVTaWduQ2hhciwgZGVjaW1hbFBvaW50Q2hhcikge1xuICAgIHRoaXMuX3plcm9EaWdpdCA9IHplcm9DaGFyO1xuICAgIHRoaXMuX3plcm9EaWdpdENoYXJDb2RlID0gemVyb0NoYXIuY2hhckNvZGVBdCgwKTtcbiAgICB0aGlzLl9wb3NpdGl2ZVNpZ24gPSBwb3NpdGl2ZVNpZ25DaGFyO1xuICAgIHRoaXMuX25lZ2F0aXZlU2lnbiA9IG5lZ2F0aXZlU2lnbkNoYXI7XG4gICAgdGhpcy5fZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxQb2ludENoYXI7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRGVjaW1hbFN0eWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucG9zaXRpdmVTaWduID0gZnVuY3Rpb24gcG9zaXRpdmVTaWduKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGl2ZVNpZ247XG4gIH07XG5cbiAgX3Byb3RvLndpdGhQb3NpdGl2ZVNpZ24gPSBmdW5jdGlvbiB3aXRoUG9zaXRpdmVTaWduKHBvc2l0aXZlU2lnbikge1xuICAgIGlmIChwb3NpdGl2ZVNpZ24gPT09IHRoaXMuX3Bvc2l0aXZlU2lnbikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsU3R5bGUodGhpcy5femVyb0RpZ2l0LCBwb3NpdGl2ZVNpZ24sIHRoaXMuX25lZ2F0aXZlU2lnbiwgdGhpcy5fZGVjaW1hbFNlcGFyYXRvcik7XG4gIH07XG5cbiAgX3Byb3RvLm5lZ2F0aXZlU2lnbiA9IGZ1bmN0aW9uIG5lZ2F0aXZlU2lnbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbmVnYXRpdmVTaWduO1xuICB9O1xuXG4gIF9wcm90by53aXRoTmVnYXRpdmVTaWduID0gZnVuY3Rpb24gd2l0aE5lZ2F0aXZlU2lnbihuZWdhdGl2ZVNpZ24pIHtcbiAgICBpZiAobmVnYXRpdmVTaWduID09PSB0aGlzLl9uZWdhdGl2ZVNpZ24pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGVjaW1hbFN0eWxlKHRoaXMuX3plcm9EaWdpdCwgdGhpcy5fcG9zaXRpdmVTaWduLCBuZWdhdGl2ZVNpZ24sIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IpO1xuICB9O1xuXG4gIF9wcm90by56ZXJvRGlnaXQgPSBmdW5jdGlvbiB6ZXJvRGlnaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3plcm9EaWdpdDtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFplcm9EaWdpdCA9IGZ1bmN0aW9uIHdpdGhaZXJvRGlnaXQoemVyb0RpZ2l0KSB7XG4gICAgaWYgKHplcm9EaWdpdCA9PT0gdGhpcy5femVyb0RpZ2l0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERlY2ltYWxTdHlsZSh6ZXJvRGlnaXQsIHRoaXMuX3Bvc2l0aXZlU2lnbiwgdGhpcy5fbmVnYXRpdmVTaWduLCB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yKTtcbiAgfTtcblxuICBfcHJvdG8uZGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uIGRlY2ltYWxTZXBhcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3I7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEZWNpbWFsU2VwYXJhdG9yID0gZnVuY3Rpb24gd2l0aERlY2ltYWxTZXBhcmF0b3IoZGVjaW1hbFNlcGFyYXRvcikge1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yID09PSB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERlY2ltYWxTdHlsZSh0aGlzLl96ZXJvRGlnaXQsIHRoaXMuX3Bvc2l0aXZlU2lnbiwgdGhpcy5fbmVnYXRpdmVTaWduLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgfTtcblxuICBfcHJvdG8uY29udmVydFRvRGlnaXQgPSBmdW5jdGlvbiBjb252ZXJ0VG9EaWdpdChjaGFyKSB7XG4gICAgdmFyIHZhbCA9IGNoYXIuY2hhckNvZGVBdCgwKSAtIHRoaXMuX3plcm9EaWdpdENoYXJDb2RlO1xuXG4gICAgcmV0dXJuIHZhbCA+PSAwICYmIHZhbCA8PSA5ID8gdmFsIDogLTE7XG4gIH07XG5cbiAgX3Byb3RvLmNvbnZlcnROdW1iZXJUb0kxOE4gPSBmdW5jdGlvbiBjb252ZXJ0TnVtYmVyVG9JMThOKG51bWVyaWNUZXh0KSB7XG4gICAgaWYgKHRoaXMuX3plcm9EaWdpdCA9PT0gJzAnKSB7XG4gICAgICByZXR1cm4gbnVtZXJpY1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSB0aGlzLl96ZXJvRGlnaXRDaGFyQ29kZSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBjb252ZXJ0ZWRUZXh0ID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bWVyaWNUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb252ZXJ0ZWRUZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobnVtZXJpY1RleHQuY2hhckNvZGVBdChpKSArIGRpZmYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJ0ZWRUZXh0O1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIERlY2ltYWxTdHlsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3plcm9EaWdpdCA9PT0gb3RoZXIuX3plcm9EaWdpdCAmJiB0aGlzLl9wb3NpdGl2ZVNpZ24gPT09IG90aGVyLl9wb3NpdGl2ZVNpZ24gJiYgdGhpcy5fbmVnYXRpdmVTaWduID09PSBvdGhlci5fbmVnYXRpdmVTaWduICYmIHRoaXMuX2RlY2ltYWxTZXBhcmF0b3IgPT09IG90aGVyLl9kZWNpbWFsU2VwYXJhdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5femVyb0RpZ2l0ICsgdGhpcy5fcG9zaXRpdmVTaWduICsgdGhpcy5fbmVnYXRpdmVTaWduICsgdGhpcy5fZGVjaW1hbFNlcGFyYXRvcjtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJEZWNpbWFsU3R5bGVbXCIgKyB0aGlzLl96ZXJvRGlnaXQgKyB0aGlzLl9wb3NpdGl2ZVNpZ24gKyB0aGlzLl9uZWdhdGl2ZVNpZ24gKyB0aGlzLl9kZWNpbWFsU2VwYXJhdG9yICsgXCJdXCI7XG4gIH07XG5cbiAgRGVjaW1hbFN0eWxlLm9mID0gZnVuY3Rpb24gb2YoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgeWV0IHN1cHBvcnRlZCcpO1xuICB9O1xuXG4gIERlY2ltYWxTdHlsZS5hdmFpbGFibGVMb2NhbGVzID0gZnVuY3Rpb24gYXZhaWxhYmxlTG9jYWxlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gIH07XG5cbiAgcmV0dXJuIERlY2ltYWxTdHlsZTtcbn0oKTtcbkRlY2ltYWxTdHlsZS5TVEFOREFSRCA9IG5ldyBEZWNpbWFsU3R5bGUoJzAnLCAnKycsICctJywgJy4nKTtcblxudmFyIFNpZ25TdHlsZSA9IGZ1bmN0aW9uIChfRW51bSkge1xuICBfaW5oZXJpdHNMb29zZShTaWduU3R5bGUsIF9FbnVtKTtcblxuICBmdW5jdGlvbiBTaWduU3R5bGUoKSB7XG4gICAgcmV0dXJuIF9FbnVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaWduU3R5bGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHBvc2l0aXZlLCBzdHJpY3QsIGZpeGVkV2lkdGgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgU2lnblN0eWxlLk5PUk1BTDpcbiAgICAgICAgcmV0dXJuICFwb3NpdGl2ZSB8fCAhc3RyaWN0O1xuXG4gICAgICBjYXNlIFNpZ25TdHlsZS5BTFdBWVM6XG4gICAgICBjYXNlIFNpZ25TdHlsZS5FWENFRURTX1BBRDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAhc3RyaWN0ICYmICFmaXhlZFdpZHRoO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU2lnblN0eWxlO1xufShFbnVtKTtcblNpZ25TdHlsZS5OT1JNQUwgPSBuZXcgU2lnblN0eWxlKCdOT1JNQUwnKTtcblNpZ25TdHlsZS5ORVZFUiA9IG5ldyBTaWduU3R5bGUoJ05FVkVSJyk7XG5TaWduU3R5bGUuQUxXQVlTID0gbmV3IFNpZ25TdHlsZSgnQUxXQVlTJyk7XG5TaWduU3R5bGUuRVhDRUVEU19QQUQgPSBuZXcgU2lnblN0eWxlKCdFWENFRURTX1BBRCcpO1xuU2lnblN0eWxlLk5PVF9ORUdBVElWRSA9IG5ldyBTaWduU3R5bGUoJ05PVF9ORUdBVElWRScpO1xuXG52YXIgVGV4dFN0eWxlID0gZnVuY3Rpb24gKF9FbnVtKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRleHRTdHlsZSwgX0VudW0pO1xuXG4gIGZ1bmN0aW9uIFRleHRTdHlsZSgpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRleHRTdHlsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uIGlzU3RhbmRhbG9uZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORTpcbiAgICAgIGNhc2UgVGV4dFN0eWxlLlNIT1JUX1NUQU5EQUxPTkU6XG4gICAgICBjYXNlIFRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uIGFzU3RhbmRhbG9uZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLkZVTEw6XG4gICAgICAgIHJldHVybiBUZXh0U3R5bGUuRlVMTF9TVEFOREFMT05FO1xuXG4gICAgICBjYXNlIFRleHRTdHlsZS5TSE9SVDpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FO1xuXG4gICAgICBjYXNlIFRleHRTdHlsZS5OQVJST1c6XG4gICAgICAgIHJldHVybiBUZXh0U3R5bGUuTkFSUk9XX1NUQU5EQUxPTkU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYXNOb3JtYWwgPSBmdW5jdGlvbiBhc05vcm1hbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMpIHtcbiAgICAgIGNhc2UgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5GVUxMO1xuXG4gICAgICBjYXNlIFRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FOlxuICAgICAgICByZXR1cm4gVGV4dFN0eWxlLlNIT1JUO1xuXG4gICAgICBjYXNlIFRleHRTdHlsZS5OQVJST1dfU1RBTkRBTE9ORTpcbiAgICAgICAgcmV0dXJuIFRleHRTdHlsZS5OQVJST1c7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGV4dFN0eWxlO1xufShFbnVtKTtcblRleHRTdHlsZS5GVUxMID0gbmV3IFRleHRTdHlsZSgnRlVMTCcpO1xuVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORSA9IG5ldyBUZXh0U3R5bGUoJ0ZVTExfU1RBTkRBTE9ORScpO1xuVGV4dFN0eWxlLlNIT1JUID0gbmV3IFRleHRTdHlsZSgnU0hPUlQnKTtcblRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FID0gbmV3IFRleHRTdHlsZSgnU0hPUlRfU1RBTkRBTE9ORScpO1xuVGV4dFN0eWxlLk5BUlJPVyA9IG5ldyBUZXh0U3R5bGUoJ05BUlJPVycpO1xuVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FID0gbmV3IFRleHRTdHlsZSgnTkFSUk9XX1NUQU5EQUxPTkUnKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIENoYXJMaXRlcmFsUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyKGxpdGVyYWwpIHtcbiAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiaW52YWxpZCBsaXRlcmFsLCB0b28gbG9uZzogXFxcIlwiICsgbGl0ZXJhbCArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9saXRlcmFsID0gbGl0ZXJhbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaGFyTGl0ZXJhbFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIGJ1Zi5hcHBlbmQodGhpcy5fbGl0ZXJhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3NpdGlvbik7XG5cbiAgICBpZiAoY29udGV4dC5jaGFyRXF1YWxzKHRoaXMuX2xpdGVyYWwsIGNoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fbGl0ZXJhbC5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMuX2xpdGVyYWwgPT09ICdcXCcnKSB7XG4gICAgICByZXR1cm4gXCInJ1wiO1xuICAgIH1cblxuICAgIHJldHVybiBcIidcIiArIHRoaXMuX2xpdGVyYWwgKyBcIidcIjtcbiAgfTtcblxuICByZXR1cm4gQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyO1xufSgpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgQ29tcG9zaXRlUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9zaXRlUHJpbnRlclBhcnNlcihwcmludGVyUGFyc2Vycywgb3B0aW9uYWwpIHtcbiAgICB0aGlzLl9wcmludGVyUGFyc2VycyA9IHByaW50ZXJQYXJzZXJzO1xuICAgIHRoaXMuX29wdGlvbmFsID0gb3B0aW9uYWw7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ29tcG9zaXRlUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLndpdGhPcHRpb25hbCA9IGZ1bmN0aW9uIHdpdGhPcHRpb25hbChvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCA9PT0gdGhpcy5fb3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29tcG9zaXRlUHJpbnRlclBhcnNlcih0aGlzLl9wcmludGVyUGFyc2Vycywgb3B0aW9uYWwpO1xuICB9O1xuXG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciBsZW5ndGggPSBidWYubGVuZ3RoKCk7XG5cbiAgICBpZiAodGhpcy5fb3B0aW9uYWwpIHtcbiAgICAgIGNvbnRleHQuc3RhcnRPcHRpb25hbCgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcCA9IHRoaXMuX3ByaW50ZXJQYXJzZXJzW2ldO1xuXG4gICAgICAgIGlmIChwcC5wcmludChjb250ZXh0LCBidWYpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJ1Zi5zZXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9uYWwpIHtcbiAgICAgICAgY29udGV4dC5lbmRPcHRpb25hbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbmFsKSB7XG4gICAgICBjb250ZXh0LnN0YXJ0T3B0aW9uYWwoKTtcbiAgICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcmludGVyUGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHAgPSB0aGlzLl9wcmludGVyUGFyc2Vyc1tpXTtcbiAgICAgICAgcG9zID0gcHAucGFyc2UoY29udGV4dCwgdGV4dCwgcG9zKTtcblxuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIGNvbnRleHQuZW5kT3B0aW9uYWwoZmFsc2UpO1xuICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmVuZE9wdGlvbmFsKHRydWUpO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX3BwID0gdGhpcy5fcHJpbnRlclBhcnNlcnNbX2ldO1xuICAgICAgICBwb3NpdGlvbiA9IF9wcC5wYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuXG4gICAgaWYgKHRoaXMuX3ByaW50ZXJQYXJzZXJzICE9IG51bGwpIHtcbiAgICAgIGJ1ZiArPSB0aGlzLl9vcHRpb25hbCA/ICdbJyA6ICcoJztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wcmludGVyUGFyc2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHAgPSB0aGlzLl9wcmludGVyUGFyc2Vyc1tpXTtcbiAgICAgICAgYnVmICs9IHBwLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiArPSB0aGlzLl9vcHRpb25hbCA/ICddJyA6ICcpJztcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9O1xuXG4gIHJldHVybiBDb21wb3NpdGVQcmludGVyUGFyc2VyO1xufSgpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgRnJhY3Rpb25QcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcmFjdGlvblByaW50ZXJQYXJzZXIoZmllbGQsIG1pbldpZHRoLCBtYXhXaWR0aCwgZGVjaW1hbFBvaW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkLnJhbmdlKCkuaXNGaXhlZCgpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkZpZWxkIG11c3QgaGF2ZSBhIGZpeGVkIHNldCBvZiB2YWx1ZXM6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIGlmIChtaW5XaWR0aCA8IDAgfHwgbWluV2lkdGggPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTWluaW11bSB3aWR0aCBtdXN0IGJlIGZyb20gMCB0byA5IGluY2x1c2l2ZSBidXQgd2FzIFwiICsgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChtYXhXaWR0aCA8IDEgfHwgbWF4V2lkdGggPiA5KSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTWF4aW11bSB3aWR0aCBtdXN0IGJlIGZyb20gMSB0byA5IGluY2x1c2l2ZSBidXQgd2FzIFwiICsgbWF4V2lkdGgpO1xuICAgIH1cblxuICAgIGlmIChtYXhXaWR0aCA8IG1pbldpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiTWF4aW11bSB3aWR0aCBtdXN0IGV4Y2VlZCBvciBlcXVhbCB0aGUgbWluaW11bSB3aWR0aCBidXQgXCIgKyBtYXhXaWR0aCArIFwiIDwgXCIgKyBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgIHRoaXMubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5kZWNpbWFsUG9pbnQgPSBkZWNpbWFsUG9pbnQ7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRnJhY3Rpb25QcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0LmdldFZhbHVlKHRoaXMuZmllbGQpO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHN5bWJvbHMgPSBjb250ZXh0LnN5bWJvbHMoKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLmRlY2ltYWxQb2ludCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5kZWNpbWFsU2VwYXJhdG9yKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1pbldpZHRoOyBpKyspIHtcbiAgICAgICAgICBidWYuYXBwZW5kKHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmcmFjdGlvbiA9IHRoaXMuY29udmVydFRvRnJhY3Rpb24odmFsdWUsIHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgICAgdmFyIG91dHB1dFNjYWxlID0gTWF0aC5taW4oTWF0aC5tYXgoZnJhY3Rpb24ubGVuZ3RoLCB0aGlzLm1pbldpZHRoKSwgdGhpcy5tYXhXaWR0aCk7XG4gICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cigwLCBvdXRwdXRTY2FsZSk7XG5cbiAgICAgIGlmIChmcmFjdGlvbiAqIDEgPiAwKSB7XG4gICAgICAgIHdoaWxlIChmcmFjdGlvbi5sZW5ndGggPiB0aGlzLm1pbldpZHRoICYmIGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSAnMCcpIHtcbiAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cigwLCBmcmFjdGlvbi5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyID0gZnJhY3Rpb247XG4gICAgICBzdHIgPSBzeW1ib2xzLmNvbnZlcnROdW1iZXJUb0kxOE4oc3RyKTtcblxuICAgICAgaWYgKHRoaXMuZGVjaW1hbFBvaW50KSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5kZWNpbWFsU2VwYXJhdG9yKCkpO1xuICAgICAgfVxuXG4gICAgICBidWYuYXBwZW5kKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoY29udGV4dCwgdGV4dCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWZmZWN0aXZlTWluID0gY29udGV4dC5pc1N0cmljdCgpID8gdGhpcy5taW5XaWR0aCA6IDA7XG4gICAgdmFyIGVmZmVjdGl2ZU1heCA9IGNvbnRleHQuaXNTdHJpY3QoKSA/IHRoaXMubWF4V2lkdGggOiA5O1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZWZmZWN0aXZlTWluID4gMCA/IH5wb3NpdGlvbiA6IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRlY2ltYWxQb2ludCkge1xuICAgICAgaWYgKHRleHRbcG9zaXRpb25dICE9PSBjb250ZXh0LnN5bWJvbHMoKS5kZWNpbWFsU2VwYXJhdG9yKCkpIHtcbiAgICAgICAgcmV0dXJuIGVmZmVjdGl2ZU1pbiA+IDAgPyB+cG9zaXRpb24gOiBwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24rKztcbiAgICB9XG5cbiAgICB2YXIgbWluRW5kUG9zID0gcG9zaXRpb24gKyBlZmZlY3RpdmVNaW47XG5cbiAgICBpZiAobWluRW5kUG9zID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciBtYXhFbmRQb3MgPSBNYXRoLm1pbihwb3NpdGlvbiArIGVmZmVjdGl2ZU1heCwgbGVuZ3RoKTtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcblxuICAgIHdoaWxlIChwb3MgPCBtYXhFbmRQb3MpIHtcbiAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KHBvcysrKTtcbiAgICAgIHZhciBkaWdpdCA9IGNvbnRleHQuc3ltYm9scygpLmNvbnZlcnRUb0RpZ2l0KGNoKTtcblxuICAgICAgaWYgKGRpZ2l0IDwgMCkge1xuICAgICAgICBpZiAocG9zIDwgbWluRW5kUG9zKSB7XG4gICAgICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcy0tO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdG90YWwgPSB0b3RhbCAqIDEwICsgZGlnaXQ7XG4gICAgfVxuXG4gICAgdmFyIG1vdmVMZWZ0ID0gcG9zIC0gcG9zaXRpb247XG4gICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMTAsIG1vdmVMZWZ0KTtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmNvbnZlcnRGcm9tRnJhY3Rpb24odG90YWwsIHNjYWxlKTtcbiAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZCh0aGlzLmZpZWxkLCB2YWx1ZSwgcG9zaXRpb24sIHBvcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbnZlcnRUb0ZyYWN0aW9uID0gZnVuY3Rpb24gY29udmVydFRvRnJhY3Rpb24odmFsdWUsIHplcm9EaWdpdCkge1xuICAgIHZhciByYW5nZSA9IHRoaXMuZmllbGQucmFuZ2UoKTtcbiAgICByYW5nZS5jaGVja1ZhbGlkVmFsdWUodmFsdWUsIHRoaXMuZmllbGQpO1xuXG4gICAgdmFyIF9taW4gPSByYW5nZS5taW5pbXVtKCk7XG5cbiAgICB2YXIgX3JhbmdlID0gcmFuZ2UubWF4aW11bSgpIC0gX21pbiArIDE7XG5cbiAgICB2YXIgX3ZhbHVlID0gdmFsdWUgLSBfbWluO1xuXG4gICAgdmFyIF9zY2FsZWQgPSBNYXRoVXRpbC5pbnREaXYoX3ZhbHVlICogMTAwMDAwMDAwMCwgX3JhbmdlKTtcblxuICAgIHZhciBmcmFjdGlvbiA9IFwiXCIgKyBfc2NhbGVkO1xuXG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDkpIHtcbiAgICAgIGZyYWN0aW9uID0gemVyb0RpZ2l0ICsgZnJhY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWN0aW9uO1xuICB9O1xuXG4gIF9wcm90by5jb252ZXJ0RnJvbUZyYWN0aW9uID0gZnVuY3Rpb24gY29udmVydEZyb21GcmFjdGlvbih0b3RhbCwgc2NhbGUpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLmZpZWxkLnJhbmdlKCk7XG5cbiAgICB2YXIgX21pbiA9IHJhbmdlLm1pbmltdW0oKTtcblxuICAgIHZhciBfcmFuZ2UgPSByYW5nZS5tYXhpbXVtKCkgLSBfbWluICsgMTtcblxuICAgIHZhciBfdmFsdWUgPSBNYXRoVXRpbC5pbnREaXYodG90YWwgKiBfcmFuZ2UsIHNjYWxlKTtcblxuICAgIHJldHVybiBfdmFsdWU7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGRlY2ltYWwgPSB0aGlzLmRlY2ltYWxQb2ludCA/ICcsRGVjaW1hbFBvaW50JyA6ICcnO1xuICAgIHJldHVybiBcIkZyYWN0aW9uKFwiICsgdGhpcy5maWVsZCArIFwiLFwiICsgdGhpcy5taW5XaWR0aCArIFwiLFwiICsgdGhpcy5tYXhXaWR0aCArIGRlY2ltYWwgKyBcIilcIjtcbiAgfTtcblxuICByZXR1cm4gRnJhY3Rpb25QcmludGVyUGFyc2VyO1xufSgpO1xuXG52YXIgTUFYX1dJRFRIJDEgPSAxNTtcbnZhciBFWENFRURfUE9JTlRTID0gWzAsIDEwLCAxMDAsIDEwMDAsIDEwMDAwLCAxMDAwMDAsIDEwMDAwMDAsIDEwMDAwMDAwLCAxMDAwMDAwMDAsIDEwMDAwMDAwMDBdO1xudmFyIE51bWJlclByaW50ZXJQYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE51bWJlclByaW50ZXJQYXJzZXIoZmllbGQsIG1pbldpZHRoLCBtYXhXaWR0aCwgc2lnblN0eWxlLCBzdWJzZXF1ZW50V2lkdGgpIHtcbiAgICBpZiAoc3Vic2VxdWVudFdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgIHN1YnNlcXVlbnRXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fZmllbGQgPSBmaWVsZDtcbiAgICB0aGlzLl9taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIHRoaXMuX21heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5fc2lnblN0eWxlID0gc2lnblN0eWxlO1xuICAgIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9IHN1YnNlcXVlbnRXaWR0aDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBOdW1iZXJQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZmllbGQgPSBmdW5jdGlvbiBmaWVsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmllbGQ7XG4gIH07XG5cbiAgX3Byb3RvLm1pbldpZHRoID0gZnVuY3Rpb24gbWluV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbldpZHRoO1xuICB9O1xuXG4gIF9wcm90by5tYXhXaWR0aCA9IGZ1bmN0aW9uIG1heFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgfTtcblxuICBfcHJvdG8uc2lnblN0eWxlID0gZnVuY3Rpb24gc2lnblN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zaWduU3R5bGU7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhGaXhlZFdpZHRoID0gZnVuY3Rpb24gd2l0aEZpeGVkV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTnVtYmVyUHJpbnRlclBhcnNlcih0aGlzLl9maWVsZCwgdGhpcy5fbWluV2lkdGgsIHRoaXMuX21heFdpZHRoLCB0aGlzLl9zaWduU3R5bGUsIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFN1YnNlcXVlbnRXaWR0aCA9IGZ1bmN0aW9uIHdpdGhTdWJzZXF1ZW50V2lkdGgoc3Vic2VxdWVudFdpZHRoKSB7XG4gICAgcmV0dXJuIG5ldyBOdW1iZXJQcmludGVyUGFyc2VyKHRoaXMuX2ZpZWxkLCB0aGlzLl9taW5XaWR0aCwgdGhpcy5fbWF4V2lkdGgsIHRoaXMuX3NpZ25TdHlsZSwgdGhpcy5fc3Vic2VxdWVudFdpZHRoICsgc3Vic2VxdWVudFdpZHRoKTtcbiAgfTtcblxuICBfcHJvdG8uX2lzRml4ZWRXaWR0aCA9IGZ1bmN0aW9uIF9pc0ZpeGVkV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9PT0gLTEgfHwgdGhpcy5fc3Vic2VxdWVudFdpZHRoID4gMCAmJiB0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGggJiYgdGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFO1xuICB9O1xuXG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciBjb250ZXh0VmFsdWUgPSBjb250ZXh0LmdldFZhbHVlKHRoaXMuX2ZpZWxkKTtcblxuICAgIGlmIChjb250ZXh0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldFZhbHVlKGNvbnRleHQsIGNvbnRleHRWYWx1ZSk7XG5cbiAgICB2YXIgc3ltYm9scyA9IGNvbnRleHQuc3ltYm9scygpO1xuICAgIHZhciBzdHIgPSBcIlwiICsgTWF0aC5hYnModmFsdWUpO1xuXG4gICAgaWYgKHN0ci5sZW5ndGggPiB0aGlzLl9tYXhXaWR0aCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiRmllbGQgXCIgKyB0aGlzLl9maWVsZCArIFwiIGNhbm5vdCBiZSBwcmludGVkIGFzIHRoZSB2YWx1ZSBcIiArIHZhbHVlICsgXCIgZXhjZWVkcyB0aGUgbWF4aW11bSBwcmludCB3aWR0aCBvZiBcIiArIHRoaXMuX21heFdpZHRoKTtcbiAgICB9XG5cbiAgICBzdHIgPSBzeW1ib2xzLmNvbnZlcnROdW1iZXJUb0kxOE4oc3RyKTtcblxuICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3NpZ25TdHlsZSkge1xuICAgICAgICBjYXNlIFNpZ25TdHlsZS5FWENFRURTX1BBRDpcbiAgICAgICAgICBpZiAodGhpcy5fbWluV2lkdGggPCBNQVhfV0lEVEgkMSAmJiB2YWx1ZSA+PSBFWENFRURfUE9JTlRTW3RoaXMuX21pbldpZHRoXSkge1xuICAgICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnBvc2l0aXZlU2lnbigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFNpZ25TdHlsZS5BTFdBWVM6XG4gICAgICAgICAgYnVmLmFwcGVuZChzeW1ib2xzLnBvc2l0aXZlU2lnbigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLl9zaWduU3R5bGUpIHtcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuTk9STUFMOlxuICAgICAgICBjYXNlIFNpZ25TdHlsZS5FWENFRURTX1BBRDpcbiAgICAgICAgY2FzZSBTaWduU3R5bGUuQUxXQVlTOlxuICAgICAgICAgIGJ1Zi5hcHBlbmQoc3ltYm9scy5uZWdhdGl2ZVNpZ24oKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTaWduU3R5bGUuTk9UX05FR0FUSVZFOlxuICAgICAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIkZpZWxkIFwiICsgdGhpcy5fZmllbGQgKyBcIiBjYW5ub3QgYmUgcHJpbnRlZCBhcyB0aGUgdmFsdWUgXCIgKyB2YWx1ZSArIFwiIGNhbm5vdCBiZSBuZWdhdGl2ZSBhY2NvcmRpbmcgdG8gdGhlIFNpZ25TdHlsZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21pbldpZHRoIC0gc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWYuYXBwZW5kKHN5bWJvbHMuemVyb0RpZ2l0KCkpO1xuICAgIH1cblxuICAgIGJ1Zi5hcHBlbmQoc3RyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIGFzc2VydChwb3NpdGlvbiA+PSAwICYmIHBvc2l0aW9uIDwgbGVuZ3RoKTtcbiAgICB2YXIgc2lnbiA9IHRleHQuY2hhckF0KHBvc2l0aW9uKTtcbiAgICB2YXIgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICB2YXIgcG9zaXRpdmUgPSBmYWxzZTtcblxuICAgIGlmIChzaWduID09PSBjb250ZXh0LnN5bWJvbHMoKS5wb3NpdGl2ZVNpZ24oKSkge1xuICAgICAgaWYgKHRoaXMuX3NpZ25TdHlsZS5wYXJzZSh0cnVlLCBjb250ZXh0LmlzU3RyaWN0KCksIHRoaXMuX21pbldpZHRoID09PSB0aGlzLl9tYXhXaWR0aCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aXZlID0gdHJ1ZTtcbiAgICAgIHBvc2l0aW9uKys7XG4gICAgfSBlbHNlIGlmIChzaWduID09PSBjb250ZXh0LnN5bWJvbHMoKS5uZWdhdGl2ZVNpZ24oKSkge1xuICAgICAgaWYgKHRoaXMuX3NpZ25TdHlsZS5wYXJzZShmYWxzZSwgY29udGV4dC5pc1N0cmljdCgpLCB0aGlzLl9taW5XaWR0aCA9PT0gdGhpcy5fbWF4V2lkdGgpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICBwb3NpdGlvbisrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuQUxXQVlTICYmIGNvbnRleHQuaXNTdHJpY3QoKSkge1xuICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZmZNaW5XaWR0aCA9IGNvbnRleHQuaXNTdHJpY3QoKSB8fCB0aGlzLl9pc0ZpeGVkV2lkdGgoKSA/IHRoaXMuX21pbldpZHRoIDogMTtcbiAgICB2YXIgbWluRW5kUG9zID0gcG9zaXRpb24gKyBlZmZNaW5XaWR0aDtcblxuICAgIGlmIChtaW5FbmRQb3MgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIGVmZk1heFdpZHRoID0gKGNvbnRleHQuaXNTdHJpY3QoKSB8fCB0aGlzLl9pc0ZpeGVkV2lkdGgoKSA/IHRoaXMuX21heFdpZHRoIDogOSkgKyBNYXRoLm1heCh0aGlzLl9zdWJzZXF1ZW50V2lkdGgsIDApO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uO1xuXG4gICAgZm9yICh2YXIgcGFzcyA9IDA7IHBhc3MgPCAyOyBwYXNzKyspIHtcbiAgICAgIHZhciBtYXhFbmRQb3MgPSBNYXRoLm1pbihwb3MgKyBlZmZNYXhXaWR0aCwgbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKHBvcyA8IG1heEVuZFBvcykge1xuICAgICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChwb3MrKyk7XG4gICAgICAgIHZhciBkaWdpdCA9IGNvbnRleHQuc3ltYm9scygpLmNvbnZlcnRUb0RpZ2l0KGNoKTtcblxuICAgICAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICAgICAgcG9zLS07XG5cbiAgICAgICAgICBpZiAocG9zIDwgbWluRW5kUG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcyAtIHBvc2l0aW9uID4gTUFYX1dJRFRIJDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXJpdGhtZXRpY0V4Y2VwdGlvbignbnVtYmVyIHRleHQgZXhjZWVkcyBsZW5ndGgnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbCA9IHRvdGFsICogMTAgKyBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3Vic2VxdWVudFdpZHRoID4gMCAmJiBwYXNzID09PSAwKSB7XG4gICAgICAgIHZhciBwYXJzZUxlbiA9IHBvcyAtIHBvc2l0aW9uO1xuICAgICAgICBlZmZNYXhXaWR0aCA9IE1hdGgubWF4KGVmZk1pbldpZHRoLCBwYXJzZUxlbiAtIHRoaXMuX3N1YnNlcXVlbnRXaWR0aCk7XG4gICAgICAgIHBvcyA9IHBvc2l0aW9uO1xuICAgICAgICB0b3RhbCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgIGlmICh0b3RhbCA9PT0gMCAmJiBjb250ZXh0LmlzU3RyaWN0KCkpIHtcbiAgICAgICAgcmV0dXJuIH4ocG9zaXRpb24gLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdGFsICE9PSAwKSB7XG4gICAgICAgIHRvdGFsID0gLXRvdGFsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuRVhDRUVEU19QQUQgJiYgY29udGV4dC5pc1N0cmljdCgpKSB7XG4gICAgICB2YXIgX3BhcnNlTGVuID0gcG9zIC0gcG9zaXRpb247XG5cbiAgICAgIGlmIChwb3NpdGl2ZSkge1xuICAgICAgICBpZiAoX3BhcnNlTGVuIDw9IHRoaXMuX21pbldpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIH4ocG9zaXRpb24gLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9wYXJzZUxlbiA+IHRoaXMuX21pbldpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zZXRWYWx1ZShjb250ZXh0LCB0b3RhbCwgcG9zaXRpb24sIHBvcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uIF9nZXRWYWx1ZShjb250ZXh0LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uX3NldFZhbHVlID0gZnVuY3Rpb24gX3NldFZhbHVlKGNvbnRleHQsIHZhbHVlLCBlcnJvclBvcywgc3VjY2Vzc1Bvcykge1xuICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKHRoaXMuX2ZpZWxkLCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLl9taW5XaWR0aCA9PT0gMSAmJiB0aGlzLl9tYXhXaWR0aCA9PT0gTUFYX1dJRFRIJDEgJiYgdGhpcy5fc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9STUFMKSB7XG4gICAgICByZXR1cm4gXCJWYWx1ZShcIiArIHRoaXMuX2ZpZWxkICsgXCIpXCI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21pbldpZHRoID09PSB0aGlzLl9tYXhXaWR0aCAmJiB0aGlzLl9zaWduU3R5bGUgPT09IFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpIHtcbiAgICAgIHJldHVybiBcIlZhbHVlKFwiICsgdGhpcy5fZmllbGQgKyBcIixcIiArIHRoaXMuX21pbldpZHRoICsgXCIpXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiVmFsdWUoXCIgKyB0aGlzLl9maWVsZCArIFwiLFwiICsgdGhpcy5fbWluV2lkdGggKyBcIixcIiArIHRoaXMuX21heFdpZHRoICsgXCIsXCIgKyB0aGlzLl9zaWduU3R5bGUgKyBcIilcIjtcbiAgfTtcblxuICByZXR1cm4gTnVtYmVyUHJpbnRlclBhcnNlcjtcbn0oKTtcbnZhciBSZWR1Y2VkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIChfTnVtYmVyUHJpbnRlclBhcnNlcikge1xuICBfaW5oZXJpdHNMb29zZShSZWR1Y2VkUHJpbnRlclBhcnNlciwgX051bWJlclByaW50ZXJQYXJzZXIpO1xuXG4gIGZ1bmN0aW9uIFJlZHVjZWRQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIGJhc2VWYWx1ZSwgYmFzZURhdGUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9OdW1iZXJQcmludGVyUGFyc2VyLmNhbGwodGhpcywgZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgU2lnblN0eWxlLk5PVF9ORUdBVElWRSkgfHwgdGhpcztcblxuICAgIGlmICh3aWR0aCA8IDEgfHwgd2lkdGggPiAxMCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSB3aWR0aCBtdXN0IGJlIGZyb20gMSB0byAxMCBpbmNsdXNpdmUgYnV0IHdhcyBcIiArIHdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAobWF4V2lkdGggPCAxIHx8IG1heFdpZHRoID4gMTApIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgbWF4V2lkdGggbXVzdCBiZSBmcm9tIDEgdG8gMTAgaW5jbHVzaXZlIGJ1dCB3YXMgXCIgKyBtYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoZSBtYXhXaWR0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgd2lkdGgnKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZURhdGUgPT09IG51bGwpIHtcbiAgICAgIGlmIChmaWVsZC5yYW5nZSgpLmlzVmFsaWRWYWx1ZShiYXNlVmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUaGUgYmFzZSB2YWx1ZSBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIGZpZWxkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlVmFsdWUgKyBFWENFRURfUE9JTlRTW3dpZHRoXSA+IE1hdGhVdGlsLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdVbmFibGUgdG8gYWRkIHByaW50ZXItcGFyc2VyIGFzIHRoZSByYW5nZSBleGNlZWRzIHRoZSBjYXBhY2l0eSBvZiBhbiBpbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5fYmFzZVZhbHVlID0gYmFzZVZhbHVlO1xuICAgIF90aGlzLl9iYXNlRGF0ZSA9IGJhc2VEYXRlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gUmVkdWNlZFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuX2dldFZhbHVlID0gZnVuY3Rpb24gX2dldFZhbHVlKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgdmFyIGFic1ZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuICAgIHZhciBiYXNlVmFsdWUgPSB0aGlzLl9iYXNlVmFsdWU7XG5cbiAgICBpZiAodGhpcy5fYmFzZURhdGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnRleHQudGVtcG9yYWwoKTtcbiAgICAgIHZhciBjaHJvbm8gPSBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgICAgYmFzZVZhbHVlID0gY2hyb25vLmRhdGUodGhpcy5fYmFzZURhdGUpLmdldCh0aGlzLl9maWVsZCk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID49IGJhc2VWYWx1ZSAmJiB2YWx1ZSA8IGJhc2VWYWx1ZSArIEVYQ0VFRF9QT0lOVFNbdGhpcy5fbWluV2lkdGhdKSB7XG4gICAgICByZXR1cm4gYWJzVmFsdWUgJSBFWENFRURfUE9JTlRTW3RoaXMuX21pbldpZHRoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWJzVmFsdWUgJSBFWENFRURfUE9JTlRTW3RoaXMuX21heFdpZHRoXTtcbiAgfTtcblxuICBfcHJvdG8yLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uIF9zZXRWYWx1ZShjb250ZXh0LCB2YWx1ZSwgZXJyb3JQb3MsIHN1Y2Nlc3NQb3MpIHtcbiAgICB2YXIgYmFzZVZhbHVlID0gdGhpcy5fYmFzZVZhbHVlO1xuXG4gICAgaWYgKHRoaXMuX2Jhc2VEYXRlICE9IG51bGwpIHtcbiAgICAgIHZhciBjaHJvbm8gPSBjb250ZXh0LmdldEVmZmVjdGl2ZUNocm9ub2xvZ3koKTtcbiAgICAgIGJhc2VWYWx1ZSA9IGNocm9uby5kYXRlKHRoaXMuX2Jhc2VEYXRlKS5nZXQodGhpcy5fZmllbGQpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZUxlbiA9IHN1Y2Nlc3NQb3MgLSBlcnJvclBvcztcblxuICAgIGlmIChwYXJzZUxlbiA9PT0gdGhpcy5fbWluV2lkdGggJiYgdmFsdWUgPj0gMCkge1xuICAgICAgdmFyIHJhbmdlID0gRVhDRUVEX1BPSU5UU1t0aGlzLl9taW5XaWR0aF07XG4gICAgICB2YXIgbGFzdFBhcnQgPSBiYXNlVmFsdWUgJSByYW5nZTtcbiAgICAgIHZhciBiYXNlUGFydCA9IGJhc2VWYWx1ZSAtIGxhc3RQYXJ0O1xuXG4gICAgICBpZiAoYmFzZVZhbHVlID4gMCkge1xuICAgICAgICB2YWx1ZSA9IGJhc2VQYXJ0ICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGJhc2VQYXJ0IC0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA8IGJhc2VWYWx1ZSkge1xuICAgICAgICB2YWx1ZSArPSByYW5nZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZCh0aGlzLl9maWVsZCwgdmFsdWUsIGVycm9yUG9zLCBzdWNjZXNzUG9zKTtcbiAgfTtcblxuICBfcHJvdG8yLndpdGhGaXhlZFdpZHRoID0gZnVuY3Rpb24gd2l0aEZpeGVkV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuX3N1YnNlcXVlbnRXaWR0aCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVkdWNlZFByaW50ZXJQYXJzZXIodGhpcy5fZmllbGQsIHRoaXMuX21pbldpZHRoLCB0aGlzLl9tYXhXaWR0aCwgdGhpcy5fYmFzZVZhbHVlLCB0aGlzLl9iYXNlRGF0ZSwgLTEpO1xuICB9O1xuXG4gIF9wcm90bzIud2l0aFN1YnNlcXVlbnRXaWR0aCA9IGZ1bmN0aW9uIHdpdGhTdWJzZXF1ZW50V2lkdGgoc3Vic2VxdWVudFdpZHRoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWR1Y2VkUHJpbnRlclBhcnNlcih0aGlzLl9maWVsZCwgdGhpcy5fbWluV2lkdGgsIHRoaXMuX21heFdpZHRoLCB0aGlzLl9iYXNlVmFsdWUsIHRoaXMuX2Jhc2VEYXRlLCB0aGlzLl9zdWJzZXF1ZW50V2lkdGggKyBzdWJzZXF1ZW50V2lkdGgpO1xuICB9O1xuXG4gIF9wcm90bzIuaXNGaXhlZFdpZHRoID0gZnVuY3Rpb24gaXNGaXhlZFdpZHRoKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5pc1N0cmljdCgpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBfTnVtYmVyUHJpbnRlclBhcnNlci5wcm90b3R5cGUuaXNGaXhlZFdpZHRoLmNhbGwodGhpcywgY29udGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlJlZHVjZWRWYWx1ZShcIiArIHRoaXMuX2ZpZWxkICsgXCIsXCIgKyB0aGlzLl9taW5XaWR0aCArIFwiLFwiICsgdGhpcy5fbWF4V2lkdGggKyBcIixcIiArICh0aGlzLl9iYXNlRGF0ZSAhPSBudWxsID8gdGhpcy5fYmFzZURhdGUgOiB0aGlzLl9iYXNlVmFsdWUpICsgXCIpXCI7XG4gIH07XG5cbiAgcmV0dXJuIFJlZHVjZWRQcmludGVyUGFyc2VyO1xufShOdW1iZXJQcmludGVyUGFyc2VyKTtcblxuLyoqXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xudmFyIFBBVFRFUk5TID0gWycrSEgnLCAnK0hIbW0nLCAnK0hIOm1tJywgJytISE1NJywgJytISDpNTScsICcrSEhNTXNzJywgJytISDpNTTpzcycsICcrSEhNTVNTJywgJytISDpNTTpTUyddO1xudmFyIE9mZnNldElkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2Zmc2V0SWRQcmludGVyUGFyc2VyKG5vT2Zmc2V0VGV4dCwgcGF0dGVybikge1xuICAgIHJlcXVpcmVOb25OdWxsKG5vT2Zmc2V0VGV4dCwgJ25vT2Zmc2V0VGV4dCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHBhdHRlcm4sICdwYXR0ZXJuJyk7XG4gICAgdGhpcy5ub09mZnNldFRleHQgPSBub09mZnNldFRleHQ7XG4gICAgdGhpcy50eXBlID0gdGhpcy5fY2hlY2tQYXR0ZXJuKHBhdHRlcm4pO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9mZnNldElkUHJpbnRlclBhcnNlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9jaGVja1BhdHRlcm4gPSBmdW5jdGlvbiBfY2hlY2tQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBBVFRFUk5TLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoUEFUVEVSTlNbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkludmFsaWQgem9uZSBvZmZzZXQgcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcbiAgfTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgb2Zmc2V0U2VjcyA9IGNvbnRleHQuZ2V0VmFsdWUoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpO1xuXG4gICAgaWYgKG9mZnNldFNlY3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0b3RhbFNlY3MgPSBNYXRoVXRpbC5zYWZlVG9JbnQob2Zmc2V0U2Vjcyk7XG5cbiAgICBpZiAodG90YWxTZWNzID09PSAwKSB7XG4gICAgICBidWYuYXBwZW5kKHRoaXMubm9PZmZzZXRUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFic0hvdXJzID0gTWF0aC5hYnMoTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdih0b3RhbFNlY3MsIDM2MDApLCAxMDApKTtcbiAgICAgIHZhciBhYnNNaW51dGVzID0gTWF0aC5hYnMoTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludERpdih0b3RhbFNlY3MsIDYwKSwgNjApKTtcbiAgICAgIHZhciBhYnNTZWNvbmRzID0gTWF0aC5hYnMoTWF0aFV0aWwuaW50TW9kKHRvdGFsU2VjcywgNjApKTtcbiAgICAgIHZhciBidWZQb3MgPSBidWYubGVuZ3RoKCk7XG4gICAgICB2YXIgb3V0cHV0ID0gYWJzSG91cnM7XG4gICAgICBidWYuYXBwZW5kKHRvdGFsU2VjcyA8IDAgPyAnLScgOiAnKycpLmFwcGVuZENoYXIoTWF0aFV0aWwuaW50RGl2KGFic0hvdXJzLCAxMCkgKyBcIjBcIikuYXBwZW5kQ2hhcihNYXRoVXRpbC5pbnRNb2QoYWJzSG91cnMsIDEwKSArIFwiMFwiKTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA+PSAzIHx8IHRoaXMudHlwZSA+PSAxICYmIGFic01pbnV0ZXMgPiAwKSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQodGhpcy50eXBlICUgMiA9PT0gMCA/ICc6JyA6ICcnKS5hcHBlbmRDaGFyKE1hdGhVdGlsLmludERpdihhYnNNaW51dGVzLCAxMCkgKyBcIjBcIikuYXBwZW5kQ2hhcihhYnNNaW51dGVzICUgMTAgKyBcIjBcIik7XG4gICAgICAgIG91dHB1dCArPSBhYnNNaW51dGVzO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPj0gNyB8fCB0aGlzLnR5cGUgPj0gNSAmJiBhYnNTZWNvbmRzID4gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQodGhpcy50eXBlICUgMiA9PT0gMCA/ICc6JyA6ICcnKS5hcHBlbmRDaGFyKE1hdGhVdGlsLmludERpdihhYnNTZWNvbmRzLCAxMCkgKyBcIjBcIikuYXBwZW5kQ2hhcihhYnNTZWNvbmRzICUgMTAgKyBcIjBcIik7XG4gICAgICAgICAgb3V0cHV0ICs9IGFic1NlY29uZHM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dCA9PT0gMCkge1xuICAgICAgICBidWYuc2V0TGVuZ3RoKGJ1ZlBvcyk7XG4gICAgICAgIGJ1Zi5hcHBlbmQodGhpcy5ub09mZnNldFRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIHZhciBub09mZnNldExlbiA9IHRoaXMubm9PZmZzZXRUZXh0Lmxlbmd0aDtcblxuICAgIGlmIChub09mZnNldExlbiA9PT0gMCkge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIDAsIHBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0LnN1YlNlcXVlbmNlRXF1YWxzKHRleHQsIHBvc2l0aW9uLCB0aGlzLm5vT2Zmc2V0VGV4dCwgMCwgbm9PZmZzZXRMZW4pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCAwLCBwb3NpdGlvbiwgcG9zaXRpb24gKyBub09mZnNldExlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpZ24gPSB0ZXh0W3Bvc2l0aW9uXTtcblxuICAgIGlmIChzaWduID09PSAnKycgfHwgc2lnbiA9PT0gJy0nKSB7XG4gICAgICB2YXIgbmVnYXRpdmUgPSBzaWduID09PSAnLScgPyAtMSA6IDE7XG4gICAgICB2YXIgYXJyYXkgPSBbMCwgMCwgMCwgMF07XG4gICAgICBhcnJheVswXSA9IHBvc2l0aW9uICsgMTtcblxuICAgICAgaWYgKCh0aGlzLl9wYXJzZU51bWJlcihhcnJheSwgMSwgdGV4dCwgdHJ1ZSkgfHwgdGhpcy5fcGFyc2VOdW1iZXIoYXJyYXksIDIsIHRleHQsIHRoaXMudHlwZSA+PSAzKSB8fCB0aGlzLl9wYXJzZU51bWJlcihhcnJheSwgMywgdGV4dCwgZmFsc2UpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIG9mZnNldFNlY3MgPSBNYXRoVXRpbC5zYWZlWmVybyhuZWdhdGl2ZSAqIChhcnJheVsxXSAqIDM2MDAgKyBhcnJheVsyXSAqIDYwICsgYXJyYXlbM10pKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIG9mZnNldFNlY3MsIHBvc2l0aW9uLCBhcnJheVswXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vT2Zmc2V0TGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5zZXRQYXJzZWRGaWVsZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUywgMCwgcG9zaXRpb24sIHBvc2l0aW9uICsgbm9PZmZzZXRMZW4pO1xuICAgIH1cblxuICAgIHJldHVybiB+cG9zaXRpb247XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZU51bWJlciA9IGZ1bmN0aW9uIF9wYXJzZU51bWJlcihhcnJheSwgYXJyYXlJbmRleCwgcGFyc2VUZXh0LCByZXF1aXJlZCkge1xuICAgIGlmICgodGhpcy50eXBlICsgMykgLyAyIDwgYXJyYXlJbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBhcnJheVswXTtcblxuICAgIGlmICh0aGlzLnR5cGUgJSAyID09PSAwICYmIGFycmF5SW5kZXggPiAxKSB7XG4gICAgICBpZiAocG9zICsgMSA+IHBhcnNlVGV4dC5sZW5ndGggfHwgcGFyc2VUZXh0W3Bvc10gIT09ICc6Jykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIGlmIChwb3MgKyAyID4gcGFyc2VUZXh0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkO1xuICAgIH1cblxuICAgIHZhciBjaDEgPSBwYXJzZVRleHRbcG9zKytdO1xuICAgIHZhciBjaDIgPSBwYXJzZVRleHRbcG9zKytdO1xuXG4gICAgaWYgKGNoMSA8ICcwJyB8fCBjaDEgPiAnOScgfHwgY2gyIDwgJzAnIHx8IGNoMiA+ICc5Jykge1xuICAgICAgcmV0dXJuIHJlcXVpcmVkO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IChjaDEuY2hhckNvZGVBdCgwKSAtIDQ4KSAqIDEwICsgKGNoMi5jaGFyQ29kZUF0KDApIC0gNDgpO1xuXG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDU5KSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQ7XG4gICAgfVxuXG4gICAgYXJyYXlbYXJyYXlJbmRleF0gPSB2YWx1ZTtcbiAgICBhcnJheVswXSA9IHBvcztcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHRoaXMubm9PZmZzZXRUZXh0LnJlcGxhY2UoJ1xcJycsICdcXCdcXCcnKTtcbiAgICByZXR1cm4gXCJPZmZzZXQoXCIgKyBQQVRURVJOU1t0aGlzLnR5cGVdICsgXCIsJ1wiICsgY29udmVydGVkICsgXCInKVwiO1xuICB9O1xuXG4gIHJldHVybiBPZmZzZXRJZFByaW50ZXJQYXJzZXI7XG59KCk7XG5PZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQgPSBuZXcgT2Zmc2V0SWRQcmludGVyUGFyc2VyKCdaJywgJytISDpNTTpzcycpO1xuT2Zmc2V0SWRQcmludGVyUGFyc2VyLlBBVFRFUk5TID0gUEFUVEVSTlM7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yKHByaW50ZXJQYXJzZXIsIHBhZFdpZHRoLCBwYWRDaGFyKSB7XG4gICAgdGhpcy5fcHJpbnRlclBhcnNlciA9IHByaW50ZXJQYXJzZXI7XG4gICAgdGhpcy5fcGFkV2lkdGggPSBwYWRXaWR0aDtcbiAgICB0aGlzLl9wYWRDaGFyID0gcGFkQ2hhcjtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgcHJlTGVuID0gYnVmLmxlbmd0aCgpO1xuXG4gICAgaWYgKHRoaXMuX3ByaW50ZXJQYXJzZXIucHJpbnQoY29udGV4dCwgYnVmKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aCgpIC0gcHJlTGVuO1xuXG4gICAgaWYgKGxlbiA+IHRoaXMuX3BhZFdpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJDYW5ub3QgcHJpbnQgYXMgb3V0cHV0IG9mIFwiICsgbGVuICsgXCIgY2hhcmFjdGVycyBleGNlZWRzIHBhZCB3aWR0aCBvZiBcIiArIHRoaXMuX3BhZFdpZHRoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BhZFdpZHRoIC0gbGVuOyBpKyspIHtcbiAgICAgIGJ1Zi5pbnNlcnQocHJlTGVuLCB0aGlzLl9wYWRDaGFyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBzdHJpY3QgPSBjb250ZXh0LmlzU3RyaWN0KCk7XG4gICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LmlzQ2FzZVNlbnNpdGl2ZSgpO1xuICAgIGFzc2VydCghKHBvc2l0aW9uID4gdGV4dC5sZW5ndGgpKTtcbiAgICBhc3NlcnQocG9zaXRpb24gPj0gMCk7XG5cbiAgICBpZiAocG9zaXRpb24gPT09IHRleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gfnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHZhciBlbmRQb3MgPSBwb3NpdGlvbiArIHRoaXMuX3BhZFdpZHRoO1xuXG4gICAgaWYgKGVuZFBvcyA+IHRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGVuZFBvcyA9IHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSBwb3NpdGlvbjtcblxuICAgIHdoaWxlIChwb3MgPCBlbmRQb3MgJiYgKGNhc2VTZW5zaXRpdmUgPyB0ZXh0W3Bvc10gPT09IHRoaXMuX3BhZENoYXIgOiBjb250ZXh0LmNoYXJFcXVhbHModGV4dFtwb3NdLCB0aGlzLl9wYWRDaGFyKSkpIHtcbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBlbmRQb3MpO1xuXG4gICAgdmFyIHJlc3VsdFBvcyA9IHRoaXMuX3ByaW50ZXJQYXJzZXIucGFyc2UoY29udGV4dCwgdGV4dCwgcG9zKTtcblxuICAgIGlmIChyZXN1bHRQb3MgIT09IGVuZFBvcyAmJiBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB+KHBvc2l0aW9uICsgcG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0UG9zO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlBhZChcIiArIHRoaXMuX3ByaW50ZXJQYXJzZXIgKyBcIixcIiArIHRoaXMuX3BhZFdpZHRoICsgKHRoaXMuX3BhZENoYXIgPT09ICcgJyA/ICcpJyA6IFwiLCdcIiArIHRoaXMuX3BhZENoYXIgKyBcIicpXCIpO1xuICB9O1xuXG4gIHJldHVybiBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yO1xufSgpO1xuXG52YXIgU2V0dGluZ3NQYXJzZXIgPSBmdW5jdGlvbiAoX0VudW0pIHtcbiAgX2luaGVyaXRzTG9vc2UoU2V0dGluZ3NQYXJzZXIsIF9FbnVtKTtcblxuICBmdW5jdGlvbiBTZXR0aW5nc1BhcnNlcigpIHtcbiAgICByZXR1cm4gX0VudW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNldHRpbmdzUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkU6XG4gICAgICAgIGNvbnRleHQuc2V0Q2FzZVNlbnNpdGl2ZSh0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU2V0dGluZ3NQYXJzZXIuSU5TRU5TSVRJVkU6XG4gICAgICAgIGNvbnRleHQuc2V0Q2FzZVNlbnNpdGl2ZShmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLlNUUklDVDpcbiAgICAgICAgY29udGV4dC5zZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLkxFTklFTlQ6XG4gICAgICAgIGNvbnRleHQuc2V0U3RyaWN0KGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHN3aXRjaCAodGhpcykge1xuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkU6XG4gICAgICAgIHJldHVybiAnUGFyc2VDYXNlU2Vuc2l0aXZlKHRydWUpJztcblxuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRTpcbiAgICAgICAgcmV0dXJuICdQYXJzZUNhc2VTZW5zaXRpdmUoZmFsc2UpJztcblxuICAgICAgY2FzZSBTZXR0aW5nc1BhcnNlci5TVFJJQ1Q6XG4gICAgICAgIHJldHVybiAnUGFyc2VTdHJpY3QodHJ1ZSknO1xuXG4gICAgICBjYXNlIFNldHRpbmdzUGFyc2VyLkxFTklFTlQ6XG4gICAgICAgIHJldHVybiAnUGFyc2VTdHJpY3QoZmFsc2UpJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNldHRpbmdzUGFyc2VyO1xufShFbnVtKTtcblNldHRpbmdzUGFyc2VyLlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignU0VOU0lUSVZFJyk7XG5TZXR0aW5nc1BhcnNlci5JTlNFTlNJVElWRSA9IG5ldyBTZXR0aW5nc1BhcnNlcignSU5TRU5TSVRJVkUnKTtcblNldHRpbmdzUGFyc2VyLlNUUklDVCA9IG5ldyBTZXR0aW5nc1BhcnNlcignU1RSSUNUJyk7XG5TZXR0aW5nc1BhcnNlci5MRU5JRU5UID0gbmV3IFNldHRpbmdzUGFyc2VyKCdMRU5JRU5UJyk7XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXIobGl0ZXJhbCkge1xuICAgIHRoaXMuX2xpdGVyYWwgPSBsaXRlcmFsO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICBidWYuYXBwZW5kKHRoaXMuX2xpdGVyYWwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRleHQsIHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGFzc2VydCghKHBvc2l0aW9uID4gbGVuZ3RoIHx8IHBvc2l0aW9uIDwgMCkpO1xuXG4gICAgaWYgKGNvbnRleHQuc3ViU2VxdWVuY2VFcXVhbHModGV4dCwgcG9zaXRpb24sIHRoaXMuX2xpdGVyYWwsIDAsIHRoaXMuX2xpdGVyYWwubGVuZ3RoKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fbGl0ZXJhbC5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGNvbnZlcnRlZCA9IHRoaXMuX2xpdGVyYWwucmVwbGFjZShcIidcIiwgXCInJ1wiKTtcblxuICAgIHJldHVybiBcIidcIiArIGNvbnZlcnRlZCArIFwiJ1wiO1xuICB9O1xuXG4gIHJldHVybiBTdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlcjtcbn0oKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciwgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBab25lUnVsZXNQcm92aWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZVJ1bGVzUHJvdmlkZXIoKSB7fVxuXG4gIFpvbmVSdWxlc1Byb3ZpZGVyLmdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoem9uZUlkKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwidW5zdXBwb3J0ZWQgWm9uZUlkOlwiICsgem9uZUlkKTtcbiAgfTtcblxuICBab25lUnVsZXNQcm92aWRlci5nZXRBdmFpbGFibGVab25lSWRzID0gZnVuY3Rpb24gZ2V0QXZhaWxhYmxlWm9uZUlkcygpIHtcbiAgICByZXR1cm4gW107XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVSdWxlc1Byb3ZpZGVyO1xufSgpO1xuXG52YXIgWm9uZVJlZ2lvbiA9IGZ1bmN0aW9uIChfWm9uZUlkKSB7XG4gIF9pbmhlcml0c0xvb3NlKFpvbmVSZWdpb24sIF9ab25lSWQpO1xuXG4gIFpvbmVSZWdpb24ub2ZJZCA9IGZ1bmN0aW9uIG9mSWQoem9uZUlkKSB7XG4gICAgdmFyIHJ1bGVzID0gWm9uZVJ1bGVzUHJvdmlkZXIuZ2V0UnVsZXMoem9uZUlkKTtcbiAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24oem9uZUlkLCBydWxlcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gWm9uZVJlZ2lvbihpZCwgcnVsZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lSWQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9pZCA9IGlkO1xuICAgIF90aGlzLl9ydWxlcyA9IHJ1bGVzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBab25lUmVnaW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaWQgPSBmdW5jdGlvbiBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH07XG5cbiAgX3Byb3RvLnJ1bGVzID0gZnVuY3Rpb24gcnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBab25lUmVnaW9uO1xufShab25lSWQpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgWm9uZUlkUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9uZUlkUHJpbnRlclBhcnNlcihxdWVyeSwgZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFpvbmVJZFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5wcmludCA9IGZ1bmN0aW9uIHByaW50KGNvbnRleHQsIGJ1Zikge1xuICAgIHZhciB6b25lID0gY29udGV4dC5nZXRWYWx1ZVF1ZXJ5KHRoaXMucXVlcnkpO1xuXG4gICAgaWYgKHpvbmUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGJ1Zi5hcHBlbmQoem9uZS5pZCgpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChwb3NpdGlvbiA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPT09IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIH5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoYXIgPSB0ZXh0LmNoYXJBdChwb3NpdGlvbik7XG5cbiAgICBpZiAobmV4dENoYXIgPT09ICcrJyB8fCBuZXh0Q2hhciA9PT0gJy0nKSB7XG4gICAgICB2YXIgbmV3Q29udGV4dCA9IGNvbnRleHQuY29weSgpO1xuICAgICAgdmFyIGVuZFBvcyA9IE9mZnNldElkUHJpbnRlclBhcnNlci5JTlNUQU5DRV9JRC5wYXJzZShuZXdDb250ZXh0LCB0ZXh0LCBwb3NpdGlvbik7XG5cbiAgICAgIGlmIChlbmRQb3MgPCAwKSB7XG4gICAgICAgIHJldHVybiBlbmRQb3M7XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUyk7XG4gICAgICB2YXIgem9uZSA9IFpvbmVPZmZzZXQub2ZUb3RhbFNlY29uZHMob2Zmc2V0KTtcbiAgICAgIGNvbnRleHQuc2V0UGFyc2VkWm9uZSh6b25lKTtcbiAgICAgIHJldHVybiBlbmRQb3M7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPj0gcG9zaXRpb24gKyAyKSB7XG4gICAgICB2YXIgbmV4dE5leHRDaGFyID0gdGV4dC5jaGFyQXQocG9zaXRpb24gKyAxKTtcblxuICAgICAgaWYgKGNvbnRleHQuY2hhckVxdWFscyhuZXh0Q2hhciwgJ1UnKSAmJiBjb250ZXh0LmNoYXJFcXVhbHMobmV4dE5leHRDaGFyLCAnVCcpKSB7XG4gICAgICAgIGlmIChsZW5ndGggPj0gcG9zaXRpb24gKyAzICYmIGNvbnRleHQuY2hhckVxdWFscyh0ZXh0LmNoYXJBdChwb3NpdGlvbiArIDIpLCAnQycpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcG9zaXRpb24sIHBvc2l0aW9uICsgMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VQcmVmaXhlZE9mZnNldChjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbiwgcG9zaXRpb24gKyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5jaGFyRXF1YWxzKG5leHRDaGFyLCAnRycpICYmIGxlbmd0aCA+PSBwb3NpdGlvbiArIDMgJiYgY29udGV4dC5jaGFyRXF1YWxzKG5leHROZXh0Q2hhciwgJ00nKSAmJiBjb250ZXh0LmNoYXJFcXVhbHModGV4dC5jaGFyQXQocG9zaXRpb24gKyAyKSwgJ1QnKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VQcmVmaXhlZE9mZnNldChjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbiwgcG9zaXRpb24gKyAzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dC5zdWJzdHIocG9zaXRpb24sIDYpID09PSAnU1lTVEVNJykge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCkpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uICsgNjtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5jaGFyRXF1YWxzKG5leHRDaGFyLCAnWicpKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZU9mZnNldC5VVEMpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uICsgMTtcbiAgICB9XG5cbiAgICB2YXIgYXZhaWxhYmxlWm9uZUlkcyA9IFpvbmVSdWxlc1Byb3ZpZGVyLmdldEF2YWlsYWJsZVpvbmVJZHMoKTtcblxuICAgIGlmICh6b25lSWRUcmVlLnNpemUgIT09IGF2YWlsYWJsZVpvbmVJZHMubGVuZ3RoKSB7XG4gICAgICB6b25lSWRUcmVlID0gWm9uZUlkVHJlZS5jcmVhdGVUcmVlTWFwKGF2YWlsYWJsZVpvbmVJZHMpO1xuICAgIH1cblxuICAgIHZhciBtYXhQYXJzZUxlbmd0aCA9IGxlbmd0aCAtIHBvc2l0aW9uO1xuICAgIHZhciB0cmVlTWFwID0gem9uZUlkVHJlZS50cmVlTWFwO1xuICAgIHZhciBwYXJzZWRab25lSWQgPSBudWxsO1xuICAgIHZhciBwYXJzZUxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAodHJlZU1hcCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGFyc2VkU3ViWm9uZUlkID0gdGV4dC5zdWJzdHIocG9zaXRpb24sIE1hdGgubWluKHRyZWVNYXAubGVuZ3RoLCBtYXhQYXJzZUxlbmd0aCkpO1xuICAgICAgdHJlZU1hcCA9IHRyZWVNYXAuZ2V0KHBhcnNlZFN1YlpvbmVJZCk7XG5cbiAgICAgIGlmICh0cmVlTWFwICE9IG51bGwgJiYgdHJlZU1hcC5pc0xlYWYpIHtcbiAgICAgICAgcGFyc2VkWm9uZUlkID0gcGFyc2VkU3ViWm9uZUlkO1xuICAgICAgICBwYXJzZUxlbmd0aCA9IHRyZWVNYXAubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJzZWRab25lSWQgIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5zZXRQYXJzZWRab25lKFpvbmVSZWdpb24ub2ZJZChwYXJzZWRab25lSWQpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbiArIHBhcnNlTGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB+cG9zaXRpb247XG4gIH07XG5cbiAgX3Byb3RvLl9wYXJzZVByZWZpeGVkT2Zmc2V0ID0gZnVuY3Rpb24gX3BhcnNlUHJlZml4ZWRPZmZzZXQoY29udGV4dCwgdGV4dCwgcHJlZml4UG9zLCBwb3NpdGlvbikge1xuICAgIHZhciBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwcmVmaXhQb3MsIHBvc2l0aW9uKS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gY29udGV4dC5jb3B5KCk7XG5cbiAgICBpZiAocG9zaXRpb24gPCB0ZXh0Lmxlbmd0aCAmJiBjb250ZXh0LmNoYXJFcXVhbHModGV4dC5jaGFyQXQocG9zaXRpb24pLCAnWicpKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLm9mT2Zmc2V0KHByZWZpeCwgWm9uZU9mZnNldC5VVEMpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgZW5kUG9zID0gT2Zmc2V0SWRQcmludGVyUGFyc2VyLklOU1RBTkNFX0lELnBhcnNlKG5ld0NvbnRleHQsIHRleHQsIHBvc2l0aW9uKTtcblxuICAgIGlmIChlbmRQb3MgPCAwKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLm9mT2Zmc2V0KHByZWZpeCwgWm9uZU9mZnNldC5VVEMpKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0U2VjcyA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKTtcbiAgICB2YXIgb2Zmc2V0ID0gWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhvZmZzZXRTZWNzKTtcbiAgICBjb250ZXh0LnNldFBhcnNlZFpvbmUoWm9uZUlkLm9mT2Zmc2V0KHByZWZpeCwgb2Zmc2V0KSk7XG4gICAgcmV0dXJuIGVuZFBvcztcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbjtcbiAgfTtcblxuICByZXR1cm4gWm9uZUlkUHJpbnRlclBhcnNlcjtcbn0oKTtcblxudmFyIFpvbmVJZFRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gIFpvbmVJZFRyZWUuY3JlYXRlVHJlZU1hcCA9IGZ1bmN0aW9uIGNyZWF0ZVRyZWVNYXAoYXZhaWxhYmxlWm9uZUlkcykge1xuICAgIHZhciBzb3J0ZWRab25lSWRzID0gYXZhaWxhYmxlWm9uZUlkcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB9KTtcbiAgICB2YXIgdHJlZU1hcCA9IG5ldyBab25lSWRUcmVlTWFwKHNvcnRlZFpvbmVJZHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZFpvbmVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyZWVNYXAuYWRkKHNvcnRlZFpvbmVJZHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgWm9uZUlkVHJlZShzb3J0ZWRab25lSWRzLmxlbmd0aCwgdHJlZU1hcCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gWm9uZUlkVHJlZShzaXplLCB0cmVlTWFwKSB7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnRyZWVNYXAgPSB0cmVlTWFwO1xuICB9XG5cbiAgcmV0dXJuIFpvbmVJZFRyZWU7XG59KCk7XG5cbnZhciBab25lSWRUcmVlTWFwID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lSWRUcmVlTWFwKGxlbmd0aCwgaXNMZWFmKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0xlYWYgPT09IHZvaWQgMCkge1xuICAgICAgaXNMZWFmID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pc0xlYWYgPSBpc0xlYWY7XG4gICAgdGhpcy5fdHJlZU1hcCA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBab25lSWRUcmVlTWFwLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZCh6b25lSWQpIHtcbiAgICB2YXIgaWRMZW5ndGggPSB6b25lSWQubGVuZ3RoO1xuXG4gICAgaWYgKGlkTGVuZ3RoID09PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJlZU1hcFt6b25lSWRdID0gbmV3IFpvbmVJZFRyZWVNYXAoaWRMZW5ndGgsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoaWRMZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuICAgICAgdmFyIHN1YlpvbmVJZCA9IHpvbmVJZC5zdWJzdHIoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgdmFyIHN1YlRyZWVNYXAgPSB0aGlzLl90cmVlTWFwW3N1YlpvbmVJZF07XG5cbiAgICAgIGlmIChzdWJUcmVlTWFwID09IG51bGwpIHtcbiAgICAgICAgc3ViVHJlZU1hcCA9IG5ldyBab25lSWRUcmVlTWFwKGlkTGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3RyZWVNYXBbc3ViWm9uZUlkXSA9IHN1YlRyZWVNYXA7XG4gICAgICB9XG5cbiAgICAgIHN1YlRyZWVNYXAuYWRkKHpvbmVJZCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0ID0gZnVuY3Rpb24gZ2V0KHpvbmVJZCkge1xuICAgIHJldHVybiB0aGlzLl90cmVlTWFwW3pvbmVJZF07XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVJZFRyZWVNYXA7XG59KCk7XG5cbnZhciB6b25lSWRUcmVlID0gbmV3IFpvbmVJZFRyZWUoW10pO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgTUFYX1dJRFRIID0gMTU7XG52YXIgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcztcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX3ByaW50ZXJQYXJzZXJzID0gW107XG4gICAgdGhpcy5fb3B0aW9uYWwgPSBmYWxzZTtcbiAgICB0aGlzLl9wYWROZXh0V2lkdGggPSAwO1xuICAgIHRoaXMuX3BhZE5leHRDaGFyID0gbnVsbDtcbiAgICB0aGlzLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gIH1cblxuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuX29mID0gZnVuY3Rpb24gX29mKHBhcmVudCwgb3B0aW9uYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbChwYXJlbnQsICdwYXJlbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvcHRpb25hbCwgJ29wdGlvbmFsJyk7XG4gICAgdmFyIGR0Rm9ybWF0dGVyQnVpbGRlciA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKTtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX3BhcmVudCA9IHBhcmVudDtcbiAgICBkdEZvcm1hdHRlckJ1aWxkZXIuX29wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgcmV0dXJuIGR0Rm9ybWF0dGVyQnVpbGRlcjtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucGFyc2VDYXNlU2Vuc2l0aXZlID0gZnVuY3Rpb24gcGFyc2VDYXNlU2Vuc2l0aXZlKCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5TRU5TSVRJVkUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gcGFyc2VDYXNlSW5zZW5zaXRpdmUoKSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWxQcmludGVyUGFyc2VyKFNldHRpbmdzUGFyc2VyLklOU0VOU0lUSVZFKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wYXJzZVN0cmljdCA9IGZ1bmN0aW9uIHBhcnNlU3RyaWN0KCkge1xuICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihTZXR0aW5nc1BhcnNlci5TVFJJQ1QpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlTGVuaWVudCA9IGZ1bmN0aW9uIHBhcnNlTGVuaWVudCgpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIoU2V0dGluZ3NQYXJzZXIuTEVOSUVOVCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kVmFsdWUgPSBmdW5jdGlvbiBhcHBlbmRWYWx1ZSgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWU0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWUxID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlMShmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkKTtcblxuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihuZXcgTnVtYmVyUHJpbnRlclBhcnNlcihmaWVsZCwgMSwgTUFYX1dJRFRILCBTaWduU3R5bGUuTk9STUFMKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZFZhbHVlMiA9IGZ1bmN0aW9uIF9hcHBlbmRWYWx1ZTIoZmllbGQsIHdpZHRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQpO1xuXG4gICAgaWYgKHdpZHRoIDwgMSB8fCB3aWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSB3aWR0aCBtdXN0IGJlIGZyb20gMSB0byBcIiArIE1BWF9XSURUSCArIFwiIGluY2x1c2l2ZSBidXQgd2FzIFwiICsgd2lkdGgpO1xuICAgIH1cblxuICAgIHZhciBwcCA9IG5ldyBOdW1iZXJQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgd2lkdGgsIFNpZ25TdHlsZS5OT1RfTkVHQVRJVkUpO1xuXG4gICAgdGhpcy5fYXBwZW5kVmFsdWVQcmludGVyUGFyc2VyKHBwKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5fYXBwZW5kVmFsdWU0ID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlNChmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBzaWduU3R5bGUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG4gICAgcmVxdWlyZU5vbk51bGwoc2lnblN0eWxlKTtcblxuICAgIGlmIChtaW5XaWR0aCA9PT0gbWF4V2lkdGggJiYgc2lnblN0eWxlID09PSBTaWduU3R5bGUuTk9UX05FR0FUSVZFKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXBwZW5kVmFsdWUyKGZpZWxkLCBtYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1pbldpZHRoIDwgMSB8fCBtaW5XaWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSBtaW5pbXVtIHdpZHRoIG11c3QgYmUgZnJvbSAxIHRvIFwiICsgTUFYX1dJRFRIICsgXCIgaW5jbHVzaXZlIGJ1dCB3YXMgXCIgKyBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFdpZHRoIDwgMSB8fCBtYXhXaWR0aCA+IE1BWF9XSURUSCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSBtaW5pbXVtIHdpZHRoIG11c3QgYmUgZnJvbSAxIHRvIFwiICsgTUFYX1dJRFRIICsgXCIgaW5jbHVzaXZlIGJ1dCB3YXMgXCIgKyBtYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKG1heFdpZHRoIDwgbWluV2lkdGgpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgbWF4aW11bSB3aWR0aCBtdXN0IGV4Y2VlZCBvciBlcXVhbCB0aGUgbWluaW11bSB3aWR0aCBidXQgXCIgKyBtYXhXaWR0aCArIFwiIDwgXCIgKyBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdmFyIHBwID0gbmV3IE51bWJlclByaW50ZXJQYXJzZXIoZmllbGQsIG1pbldpZHRoLCBtYXhXaWR0aCwgc2lnblN0eWxlKTtcblxuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kVmFsdWVSZWR1Y2VkID0gZnVuY3Rpb24gYXBwZW5kVmFsdWVSZWR1Y2VkKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0ICYmIGFyZ3VtZW50c1szXSBpbnN0YW5jZW9mIENocm9ub0xvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VEYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRWYWx1ZVJlZHVjZWRGaWVsZFdpZHRoTWF4V2lkdGhCYXNlVmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hcHBlbmRWYWx1ZVJlZHVjZWRGaWVsZFdpZHRoTWF4V2lkdGhCYXNlVmFsdWUgPSBmdW5jdGlvbiBfYXBwZW5kVmFsdWVSZWR1Y2VkRmllbGRXaWR0aE1heFdpZHRoQmFzZVZhbHVlKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIGJhc2VWYWx1ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICB2YXIgcHAgPSBuZXcgUmVkdWNlZFByaW50ZXJQYXJzZXIoZmllbGQsIHdpZHRoLCBtYXhXaWR0aCwgYmFzZVZhbHVlLCBudWxsKTtcblxuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VEYXRlID0gZnVuY3Rpb24gX2FwcGVuZFZhbHVlUmVkdWNlZEZpZWxkV2lkdGhNYXhXaWR0aEJhc2VEYXRlKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIGJhc2VEYXRlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGJhc2VEYXRlLCAnYmFzZURhdGUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoYmFzZURhdGUsIENocm9ub0xvY2FsRGF0ZSwgJ2Jhc2VEYXRlJyk7XG4gICAgdmFyIHBwID0gbmV3IFJlZHVjZWRQcmludGVyUGFyc2VyKGZpZWxkLCB3aWR0aCwgbWF4V2lkdGgsIDAsIGJhc2VEYXRlKTtcblxuICAgIHRoaXMuX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlcihwcCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZFZhbHVlUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIF9hcHBlbmRWYWx1ZVByaW50ZXJQYXJzZXIocHApIHtcbiAgICBhc3NlcnQocHAgIT0gbnVsbCk7XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID49IDAgJiYgdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vyc1t0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXhdIGluc3RhbmNlb2YgTnVtYmVyUHJpbnRlclBhcnNlcikge1xuICAgICAgdmFyIGFjdGl2ZVZhbHVlUGFyc2VyID0gdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4O1xuICAgICAgdmFyIGJhc2VQUCA9IHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnNbYWN0aXZlVmFsdWVQYXJzZXJdO1xuXG4gICAgICBpZiAocHAubWluV2lkdGgoKSA9PT0gcHAubWF4V2lkdGgoKSAmJiBwcC5zaWduU3R5bGUoKSA9PT0gU2lnblN0eWxlLk5PVF9ORUdBVElWRSkge1xuICAgICAgICBiYXNlUFAgPSBiYXNlUFAud2l0aFN1YnNlcXVlbnRXaWR0aChwcC5tYXhXaWR0aCgpKTtcblxuICAgICAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChwcC53aXRoRml4ZWRXaWR0aCgpKTtcblxuICAgICAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSBhY3RpdmVWYWx1ZVBhcnNlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VQUCA9IGJhc2VQUC53aXRoRml4ZWRXaWR0aCgpO1xuICAgICAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSB0aGlzLl9hcHBlbmRJbnRlcm5hbChwcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnNbYWN0aXZlVmFsdWVQYXJzZXJdID0gYmFzZVBQO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSB0aGlzLl9hcHBlbmRJbnRlcm5hbChwcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZEZyYWN0aW9uID0gZnVuY3Rpb24gYXBwZW5kRnJhY3Rpb24oZmllbGQsIG1pbldpZHRoLCBtYXhXaWR0aCwgZGVjaW1hbFBvaW50KSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwobmV3IEZyYWN0aW9uUHJpbnRlclBhcnNlcihmaWVsZCwgbWluV2lkdGgsIG1heFdpZHRoLCBkZWNpbWFsUG9pbnQpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRJbnN0YW50ID0gZnVuY3Rpb24gYXBwZW5kSW5zdGFudChmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgaWYgKGZyYWN0aW9uYWxEaWdpdHMgPT09IHZvaWQgMCkge1xuICAgICAgZnJhY3Rpb25hbERpZ2l0cyA9IC0yO1xuICAgIH1cblxuICAgIGlmIChmcmFjdGlvbmFsRGlnaXRzIDwgLTIgfHwgZnJhY3Rpb25hbERpZ2l0cyA+IDkpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJJbnZhbGlkIGZyYWN0aW9uYWwgZGlnaXRzOiBcIiArIGZyYWN0aW9uYWxEaWdpdHMpO1xuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZEludGVybmFsKG5ldyBJbnN0YW50UHJpbnRlclBhcnNlcihmcmFjdGlvbmFsRGlnaXRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kT2Zmc2V0SWQgPSBmdW5jdGlvbiBhcHBlbmRPZmZzZXRJZCgpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChPZmZzZXRJZFByaW50ZXJQYXJzZXIuSU5TVEFOQ0VfSUQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZE9mZnNldCA9IGZ1bmN0aW9uIGFwcGVuZE9mZnNldChwYXR0ZXJuLCBub09mZnNldFRleHQpIHtcbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIobmV3IE9mZnNldElkUHJpbnRlclBhcnNlcihub09mZnNldFRleHQsIHBhdHRlcm4pKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmRab25lSWQgPSBmdW5jdGlvbiBhcHBlbmRab25lSWQoKSB7XG4gICAgdGhpcy5fYXBwZW5kSW50ZXJuYWwobmV3IFpvbmVJZFByaW50ZXJQYXJzZXIoVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpLCAnWm9uZUlkKCknKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kUGF0dGVybiA9IGZ1bmN0aW9uIGFwcGVuZFBhdHRlcm4ocGF0dGVybikge1xuICAgIHJlcXVpcmVOb25OdWxsKHBhdHRlcm4sICdwYXR0ZXJuJyk7XG5cbiAgICB0aGlzLl9wYXJzZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kWm9uZVRleHQgPSBmdW5jdGlvbiBhcHBlbmRab25lVGV4dCgpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkLCB1c2UgQGpzLWpvZGEvbG9jYWxlIHBsdWdpbiEnKTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kVGV4dCA9IGZ1bmN0aW9uIGFwcGVuZFRleHQoKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUGF0dGVybiB1c2luZyAobG9jYWxpemVkKSB0ZXh0IG5vdCBpbXBsZW1lbnRlZCwgdXNlIEBqcy1qb2RhL2xvY2FsZSBwbHVnaW4hJyk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGVuZExvY2FsaXplZE9mZnNldCA9IGZ1bmN0aW9uIGFwcGVuZExvY2FsaXplZE9mZnNldCgpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQYXR0ZXJuIHVzaW5nIChsb2NhbGl6ZWQpIHRleHQgbm90IGltcGxlbWVudGVkLCB1c2UgQGpzLWpvZGEvbG9jYWxlIHBsdWdpbiEnKTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kV2Vla0ZpZWxkID0gZnVuY3Rpb24gYXBwZW5kV2Vla0ZpZWxkKCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gdXNpbmcgKGxvY2FsaXplZCkgdGV4dCBub3QgaW1wbGVtZW50ZWQsIHVzZSBAanMtam9kYS9sb2NhbGUgcGx1Z2luIScpO1xuICB9O1xuXG4gIF9wcm90by5fcGFyc2VQYXR0ZXJuID0gZnVuY3Rpb24gX3BhcnNlUGF0dGVybihwYXR0ZXJuKSB7XG4gICAgdmFyIEZJRUxEX01BUCA9IHtcbiAgICAgICdHJzogQ2hyb25vRmllbGQuRVJBLFxuICAgICAgJ3knOiBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSxcbiAgICAgICd1JzogQ2hyb25vRmllbGQuWUVBUixcbiAgICAgICdRJzogSXNvRmllbGRzLlFVQVJURVJfT0ZfWUVBUixcbiAgICAgICdxJzogSXNvRmllbGRzLlFVQVJURVJfT0ZfWUVBUixcbiAgICAgICdNJzogQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUixcbiAgICAgICdMJzogQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUixcbiAgICAgICdEJzogQ2hyb25vRmllbGQuREFZX09GX1lFQVIsXG4gICAgICAnZCc6IENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCxcbiAgICAgICdGJzogQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USCxcbiAgICAgICdFJzogQ2hyb25vRmllbGQuREFZX09GX1dFRUssXG4gICAgICAnYyc6IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLFxuICAgICAgJ2UnOiBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyxcbiAgICAgICdhJzogQ2hyb25vRmllbGQuQU1QTV9PRl9EQVksXG4gICAgICAnSCc6IENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZLFxuICAgICAgJ2snOiBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWSxcbiAgICAgICdLJzogQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNLFxuICAgICAgJ2gnOiBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE0sXG4gICAgICAnbSc6IENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSLFxuICAgICAgJ3MnOiBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLFxuICAgICAgJ1MnOiBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCxcbiAgICAgICdBJzogQ2hyb25vRmllbGQuTUlMTElfT0ZfREFZLFxuICAgICAgJ24nOiBDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCxcbiAgICAgICdOJzogQ2hyb25vRmllbGQuTkFOT19PRl9EQVlcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgcGF0dGVybi5sZW5ndGg7IHBvcysrKSB7XG4gICAgICB2YXIgY3VyID0gcGF0dGVybi5jaGFyQXQocG9zKTtcblxuICAgICAgaWYgKGN1ciA+PSAnQScgJiYgY3VyIDw9ICdaJyB8fCBjdXIgPj0gJ2EnICYmIGN1ciA8PSAneicpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zKys7XG5cbiAgICAgICAgZm9yICg7IHBvcyA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KHBvcykgPT09IGN1cjsgcG9zKyspIHtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3VudCA9IHBvcyAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChjdXIgPT09ICdwJykge1xuICAgICAgICAgIHZhciBwYWQgPSAwO1xuXG4gICAgICAgICAgaWYgKHBvcyA8IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXIgPSBwYXR0ZXJuLmNoYXJBdChwb3MpO1xuXG4gICAgICAgICAgICBpZiAoY3VyID49ICdBJyAmJiBjdXIgPD0gJ1onIHx8IGN1ciA+PSAnYScgJiYgY3VyIDw9ICd6Jykge1xuICAgICAgICAgICAgICBwYWQgPSBjb3VudDtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb3MrKztcblxuICAgICAgICAgICAgICBmb3IgKDsgcG9zIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQocG9zKSA9PT0gY3VyOyBwb3MrKykge1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY291bnQgPSBwb3MgLSBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFkID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiUGFkIGxldHRlciAncCcgbXVzdCBiZSBmb2xsb3dlZCBieSB2YWxpZCBwYWQgcGF0dGVybjogXCIgKyBwYXR0ZXJuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhZE5leHQocGFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWVsZCA9IEZJRUxEX01BUFtjdXJdO1xuXG4gICAgICAgIGlmIChmaWVsZCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VGaWVsZChjdXIsIGNvdW50LCBmaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAneicpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRab25lVGV4dChUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kWm9uZVRleHQoVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnVicpIHtcbiAgICAgICAgICBpZiAoY291bnQgIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJQYXR0ZXJuIGxldHRlciBjb3VudCBtdXN0IGJlIDI6IFwiICsgY3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFwcGVuZFpvbmVJZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1onKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRPZmZzZXQoJytISE1NJywgJyswMDAwJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRMb2NhbGl6ZWRPZmZzZXQoVGV4dFN0eWxlLkZVTEwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KCcrSEg6TU06c3MnLCAnWicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ08nKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZExvY2FsaXplZE9mZnNldChUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTG9jYWxpemVkT2Zmc2V0KFRleHRTdHlsZS5GVUxMKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlBhdHRlcm4gbGV0dGVyIGNvdW50IG11c3QgYmUgMSBvciA0OiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1gnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KE9mZnNldElkUHJpbnRlclBhcnNlci5QQVRURVJOU1tjb3VudCArIChjb3VudCA9PT0gMSA/IDAgOiAxKV0sICdaJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAneCcpIHtcbiAgICAgICAgICBpZiAoY291bnQgPiA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHplcm8gPSBjb3VudCA9PT0gMSA/ICcrMDAnIDogY291bnQgJSAyID09PSAwID8gJyswMDAwJyA6ICcrMDA6MDAnO1xuICAgICAgICAgIHRoaXMuYXBwZW5kT2Zmc2V0KE9mZnNldElkUHJpbnRlclBhcnNlci5QQVRURVJOU1tjb3VudCArIChjb3VudCA9PT0gMSA/IDAgOiAxKV0sIHplcm8pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1cnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdXJywgY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ3cnKSB7XG4gICAgICAgICAgaWYgKGNvdW50ID4gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCd3JywgY291bnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ1knKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRXZWVrRmllbGQoJ1knLCBjb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlVua25vd24gcGF0dGVybiBsZXR0ZXI6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcy0tO1xuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdcXCcnKSB7XG4gICAgICAgIHZhciBfc3RhcnQgPSBwb3MrKztcblxuICAgICAgICBmb3IgKDsgcG9zIDwgcGF0dGVybi5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4uY2hhckF0KHBvcykgPT09ICdcXCcnKSB7XG4gICAgICAgICAgICBpZiAocG9zICsgMSA8IHBhdHRlcm4ubGVuZ3RoICYmIHBhdHRlcm4uY2hhckF0KHBvcyArIDEpID09PSAnXFwnJykge1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3MgPj0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiUGF0dGVybiBlbmRzIHdpdGggYW4gaW5jb21wbGV0ZSBzdHJpbmcgbGl0ZXJhbDogXCIgKyBwYXR0ZXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHIgPSBwYXR0ZXJuLnN1YnN0cmluZyhfc3RhcnQgKyAxLCBwb3MpO1xuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRMaXRlcmFsKCdcXCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZExpdGVyYWwoc3RyLnJlcGxhY2UoJ1xcJ1xcJycsICdcXCcnKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAnWycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25hbFN0YXJ0KCk7XG4gICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gJ10nKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUuX3BhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BhdHRlcm4gaW52YWxpZCBhcyBpdCBjb250YWlucyBdIHdpdGhvdXQgcHJldmlvdXMgWycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25hbEVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICd7JyB8fCBjdXIgPT09ICd9JyB8fCBjdXIgPT09ICcjJykge1xuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiUGF0dGVybiBpbmNsdWRlcyByZXNlcnZlZCBjaGFyYWN0ZXI6ICdcIiArIGN1ciArIFwiJ1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTGl0ZXJhbChjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlRmllbGQgPSBmdW5jdGlvbiBfcGFyc2VGaWVsZChjdXIsIGNvdW50LCBmaWVsZCkge1xuICAgIHN3aXRjaCAoY3VyKSB7XG4gICAgICBjYXNlICd1JzpcbiAgICAgIGNhc2UgJ3knOlxuICAgICAgICBpZiAoY291bnQgPT09IDIpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlUmVkdWNlZChmaWVsZCwgMiwgMiwgUmVkdWNlZFByaW50ZXJQYXJzZXIuQkFTRV9EQVRFKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8IDQpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCBjb3VudCwgTUFYX1dJRFRILCBTaWduU3R5bGUuTk9STUFMKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCBjb3VudCwgTUFYX1dJRFRILCBTaWduU3R5bGUuRVhDRUVEU19QQUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOlxuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPVyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6XG4gICAgICBjYXNlICdxJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuU0hPUlRfU1RBTkRBTE9ORSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLkZVTExfU1RBTkRBTE9ORSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPV19TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFdlZWtGaWVsZCgnZScsIGNvdW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuU0hPUlQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5GVUxMKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuTkFSUk9XKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2Vla0ZpZWxkKCdjJywgY291bnQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiSW52YWxpZCBudW1iZXIgb2YgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5TSE9SVF9TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTF9TVEFOREFMT05FKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuTkFSUk9XX1NUQU5EQUxPTkUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFRleHQoZmllbGQsIFRleHRTdHlsZS5TSE9SVCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgY2FzZSAnRyc6XG4gICAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLlNIT1JUKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUZXh0KGZpZWxkLCBUZXh0U3R5bGUuRlVMTCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVGV4dChmaWVsZCwgVGV4dFN0eWxlLk5BUlJPVyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiVG9vIG1hbnkgcGF0dGVybiBsZXR0ZXJzOiBcIiArIGN1cik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIHRoaXMuYXBwZW5kRnJhY3Rpb24oQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIGNvdW50LCBjb3VudCwgZmFsc2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnRic6XG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuYXBwZW5kVmFsdWUoZmllbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkJzpcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgY2FzZSAnSCc6XG4gICAgICBjYXNlICdrJzpcbiAgICAgIGNhc2UgJ0snOlxuICAgICAgY2FzZSAnbSc6XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDIpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCBjb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIlRvbyBtYW55IHBhdHRlcm4gbGV0dGVyczogXCIgKyBjdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0QnOlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRWYWx1ZShmaWVsZCwgY291bnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUb28gbWFueSBwYXR0ZXJuIGxldHRlcnM6IFwiICsgY3VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGVuZFZhbHVlKGZpZWxkLCBjb3VudCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhZE5leHQgPSBmdW5jdGlvbiBwYWROZXh0KCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFkTmV4dDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZE5leHQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcGFkTmV4dDEgPSBmdW5jdGlvbiBfcGFkTmV4dDEocGFkV2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFkTmV4dDIocGFkV2lkdGgsICcgJyk7XG4gIH07XG5cbiAgX3Byb3RvLl9wYWROZXh0MiA9IGZ1bmN0aW9uIF9wYWROZXh0MihwYWRXaWR0aCwgcGFkQ2hhcikge1xuICAgIGlmIChwYWRXaWR0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgcGFkIHdpZHRoIG11c3QgYmUgYXQgbGVhc3Qgb25lIGJ1dCB3YXMgXCIgKyBwYWRXaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGggPSBwYWRXaWR0aDtcbiAgICB0aGlzLl9hY3RpdmUuX3BhZE5leHRDaGFyID0gcGFkQ2hhcjtcbiAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ub3B0aW9uYWxTdGFydCA9IGZ1bmN0aW9uIG9wdGlvbmFsU3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gICAgdGhpcy5fYWN0aXZlID0gRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLl9vZih0aGlzLl9hY3RpdmUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vcHRpb25hbEVuZCA9IGZ1bmN0aW9uIG9wdGlvbmFsRW5kKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUuX3BhcmVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCdDYW5ub3QgY2FsbCBvcHRpb25hbEVuZCgpIGFzIHRoZXJlIHdhcyBubyBwcmV2aW91cyBjYWxsIHRvIG9wdGlvbmFsU3RhcnQoKScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBjcHAgPSBuZXcgQ29tcG9zaXRlUHJpbnRlclBhcnNlcih0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLCB0aGlzLl9hY3RpdmUuX29wdGlvbmFsKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZS5fcGFyZW50O1xuXG4gICAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChjcHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9hY3RpdmUuX3BhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZEludGVybmFsID0gZnVuY3Rpb24gX2FwcGVuZEludGVybmFsKHBwKSB7XG4gICAgYXNzZXJ0KHBwICE9IG51bGwpO1xuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoID4gMCkge1xuICAgICAgaWYgKHBwICE9IG51bGwpIHtcbiAgICAgICAgcHAgPSBuZXcgUGFkUHJpbnRlclBhcnNlckRlY29yYXRvcihwcCwgdGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGgsIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCA9IDA7XG4gICAgICB0aGlzLl9hY3RpdmUuX3BhZE5leHRDaGFyID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmUuX3ByaW50ZXJQYXJzZXJzLnB1c2gocHApO1xuXG4gICAgdGhpcy5fYWN0aXZlLl92YWx1ZVBhcnNlckluZGV4ID0gLTE7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMubGVuZ3RoIC0gMTtcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kTGl0ZXJhbCA9IGZ1bmN0aW9uIGFwcGVuZExpdGVyYWwobGl0ZXJhbCkge1xuICAgIGFzc2VydChsaXRlcmFsICE9IG51bGwpO1xuXG4gICAgaWYgKGxpdGVyYWwubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxpdGVyYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlcihuZXcgQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyKGxpdGVyYWwuY2hhckF0KDApKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIobmV3IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyKGxpdGVyYWwpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uX2FwcGVuZEludGVybmFsUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIF9hcHBlbmRJbnRlcm5hbFByaW50ZXJQYXJzZXIocHApIHtcbiAgICBhc3NlcnQocHAgIT0gbnVsbCk7XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlLl9wYWROZXh0V2lkdGggPiAwKSB7XG4gICAgICBpZiAocHAgIT0gbnVsbCkge1xuICAgICAgICBwcCA9IG5ldyBQYWRQcmludGVyUGFyc2VyRGVjb3JhdG9yKHBwLCB0aGlzLl9hY3RpdmUuX3BhZE5leHRXaWR0aCwgdGhpcy5fYWN0aXZlLl9wYWROZXh0Q2hhcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dFdpZHRoID0gMDtcbiAgICAgIHRoaXMuX2FjdGl2ZS5fcGFkTmV4dENoYXIgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZS5fcHJpbnRlclBhcnNlcnMucHVzaChwcCk7XG5cbiAgICB0aGlzLl9hY3RpdmUuX3ZhbHVlUGFyc2VySW5kZXggPSAtMTtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlLl9wcmludGVyUGFyc2Vycy5sZW5ndGggLSAxO1xuICB9O1xuXG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG5cbiAgICB0aGlzLl9hcHBlbmRJbnRlcm5hbChmb3JtYXR0ZXIuX3RvUHJpbnRlclBhcnNlcihmYWxzZSkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRvRm9ybWF0dGVyID0gZnVuY3Rpb24gdG9Gb3JtYXR0ZXIocmVzb2x2ZXJTdHlsZSkge1xuICAgIGlmIChyZXNvbHZlclN0eWxlID09PSB2b2lkIDApIHtcbiAgICAgIHJlc29sdmVyU3R5bGUgPSBSZXNvbHZlclN0eWxlLlNNQVJUO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLl9hY3RpdmUuX3BhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aGlzLm9wdGlvbmFsRW5kKCk7XG4gICAgfVxuXG4gICAgdmFyIHBwID0gbmV3IENvbXBvc2l0ZVByaW50ZXJQYXJzZXIodGhpcy5fcHJpbnRlclBhcnNlcnMsIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0dGVyKHBwLCBudWxsLCBEZWNpbWFsU3R5bGUuU1RBTkRBUkQsIHJlc29sdmVyU3R5bGUsIG51bGwsIG51bGwsIG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXI7XG59KCk7XG52YXIgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMgPSAxNDYwOTcgKiAyNSAqIDg2NDAwO1xudmFyIFNFQ09ORFNfMDAwMF9UT18xOTcwID0gKDE0NjA5NyAqIDUgLSAoMzAgKiAzNjUgKyA3KSkgKiA4NjQwMDtcblxudmFyIEluc3RhbnRQcmludGVyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnN0YW50UHJpbnRlclBhcnNlcihmcmFjdGlvbmFsRGlnaXRzKSB7XG4gICAgdGhpcy5mcmFjdGlvbmFsRGlnaXRzID0gZnJhY3Rpb25hbERpZ2l0cztcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gSW5zdGFudFByaW50ZXJQYXJzZXIucHJvdG90eXBlO1xuXG4gIF9wcm90bzIucHJpbnQgPSBmdW5jdGlvbiBwcmludChjb250ZXh0LCBidWYpIHtcbiAgICB2YXIgaW5TZWNzID0gY29udGV4dC5nZXRWYWx1ZShDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMpO1xuICAgIHZhciBpbk5hbm9zID0gMDtcblxuICAgIGlmIChjb250ZXh0LnRlbXBvcmFsKCkuaXNTdXBwb3J0ZWQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpKSB7XG4gICAgICBpbk5hbm9zID0gY29udGV4dC50ZW1wb3JhbCgpLmdldExvbmcoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgIH1cblxuICAgIGlmIChpblNlY3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpblNlYyA9IGluU2VjcztcbiAgICB2YXIgaW5OYW5vID0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZEludFZhbHVlKGluTmFub3MpO1xuXG4gICAgaWYgKGluU2VjID49IC1TRUNPTkRTXzAwMDBfVE9fMTk3MCkge1xuICAgICAgdmFyIHplcm9TZWNzID0gaW5TZWMgLSBTRUNPTkRTX1BFUl8xMDAwMF9ZRUFSUyArIFNFQ09ORFNfMDAwMF9UT18xOTcwO1xuICAgICAgdmFyIGhpID0gTWF0aFV0aWwuZmxvb3JEaXYoemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKSArIDE7XG4gICAgICB2YXIgbG8gPSBNYXRoVXRpbC5mbG9vck1vZCh6ZXJvU2VjcywgU0VDT05EU19QRVJfMTAwMDBfWUVBUlMpO1xuICAgICAgdmFyIGxkdCA9IExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChsbyAtIFNFQ09ORFNfMDAwMF9UT18xOTcwLCAwLCBab25lT2Zmc2V0LlVUQyk7XG5cbiAgICAgIGlmIChoaSA+IDApIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnKycpLmFwcGVuZChoaSk7XG4gICAgICB9XG5cbiAgICAgIGJ1Zi5hcHBlbmQobGR0LnRvU3RyaW5nKCkpO1xuXG4gICAgICBpZiAobGR0LnNlY29uZCgpID09PSAwKSB7XG4gICAgICAgIGJ1Zi5hcHBlbmQoJzowMCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3plcm9TZWNzID0gaW5TZWMgKyBTRUNPTkRTXzAwMDBfVE9fMTk3MDtcblxuICAgICAgdmFyIF9oaSA9IE1hdGhVdGlsLmludERpdihfemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcblxuICAgICAgdmFyIF9sbyA9IE1hdGhVdGlsLmludE1vZChfemVyb1NlY3MsIFNFQ09ORFNfUEVSXzEwMDAwX1lFQVJTKTtcblxuICAgICAgdmFyIF9sZHQgPSBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQoX2xvIC0gU0VDT05EU18wMDAwX1RPXzE5NzAsIDAsIFpvbmVPZmZzZXQuVVRDKTtcblxuICAgICAgdmFyIHBvcyA9IGJ1Zi5sZW5ndGgoKTtcbiAgICAgIGJ1Zi5hcHBlbmQoX2xkdC50b1N0cmluZygpKTtcblxuICAgICAgaWYgKF9sZHQuc2Vjb25kKCkgPT09IDApIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnOjAwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaGkgPCAwKSB7XG4gICAgICAgIGlmIChfbGR0LnllYXIoKSA9PT0gLTEwMDAwKSB7XG4gICAgICAgICAgYnVmLnJlcGxhY2UocG9zLCBwb3MgKyAyLCBcIlwiICsgKF9oaSAtIDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChfbG8gPT09IDApIHtcbiAgICAgICAgICBidWYuaW5zZXJ0KHBvcywgX2hpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYuaW5zZXJ0KHBvcyArIDEsIE1hdGguYWJzKF9oaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA9PT0gLTIpIHtcbiAgICAgIGlmIChpbk5hbm8gIT09IDApIHtcbiAgICAgICAgYnVmLmFwcGVuZCgnLicpO1xuXG4gICAgICAgIGlmIChNYXRoVXRpbC5pbnRNb2QoaW5OYW5vLCAxMDAwMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KGluTmFubywgMTAwMDAwMCkgKyAxMDAwKSkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoVXRpbC5pbnRNb2QoaW5OYW5vLCAxMDAwKSA9PT0gMCkge1xuICAgICAgICAgIGJ1Zi5hcHBlbmQoKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KGluTmFubywgMTAwMCkgKyAxMDAwMDAwKSkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYuYXBwZW5kKChcIlwiICsgKGluTmFubyArIDEwMDAwMDAwMDApKS5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPiAwIHx8IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA9PT0gLTEgJiYgaW5OYW5vID4gMCkge1xuICAgICAgYnVmLmFwcGVuZCgnLicpO1xuICAgICAgdmFyIGRpdiA9IDEwMDAwMDAwMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA9PT0gLTEgJiYgaW5OYW5vID4gMCB8fCBpIDwgdGhpcy5mcmFjdGlvbmFsRGlnaXRzOyBpKyspIHtcbiAgICAgICAgdmFyIGRpZ2l0ID0gTWF0aFV0aWwuaW50RGl2KGluTmFubywgZGl2KTtcbiAgICAgICAgYnVmLmFwcGVuZChkaWdpdCk7XG4gICAgICAgIGluTmFubyA9IGluTmFubyAtIGRpZ2l0ICogZGl2O1xuICAgICAgICBkaXYgPSBNYXRoVXRpbC5pbnREaXYoZGl2LCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmLmFwcGVuZCgnWicpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9wcm90bzIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb250ZXh0LCB0ZXh0LCBwb3NpdGlvbikge1xuICAgIHZhciBuZXdDb250ZXh0ID0gY29udGV4dC5jb3B5KCk7XG4gICAgdmFyIG1pbkRpZ2l0cyA9IHRoaXMuZnJhY3Rpb25hbERpZ2l0cyA8IDAgPyAwIDogdGhpcy5mcmFjdGlvbmFsRGlnaXRzO1xuICAgIHZhciBtYXhEaWdpdHMgPSB0aGlzLmZyYWN0aW9uYWxEaWdpdHMgPCAwID8gOSA6IHRoaXMuZnJhY3Rpb25hbERpZ2l0cztcblxuICAgIHZhciBwYXJzZXIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFKS5hcHBlbmRMaXRlcmFsKCdUJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIDIpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiwgMikuYXBwZW5kTGl0ZXJhbCgnOicpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUsIDIpLmFwcGVuZEZyYWN0aW9uKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBtaW5EaWdpdHMsIG1heERpZ2l0cywgdHJ1ZSkuYXBwZW5kTGl0ZXJhbCgnWicpLnRvRm9ybWF0dGVyKCkuX3RvUHJpbnRlclBhcnNlcihmYWxzZSk7XG5cbiAgICB2YXIgcG9zID0gcGFyc2VyLnBhcnNlKG5ld0NvbnRleHQsIHRleHQsIHBvc2l0aW9uKTtcblxuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIHZhciB5ZWFyUGFyc2VkID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuWUVBUik7XG4gICAgdmFyIG1vbnRoID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUik7XG4gICAgdmFyIGRheSA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCk7XG4gICAgdmFyIGhvdXIgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5IT1VSX09GX0RBWSk7XG4gICAgdmFyIG1pbiA9IG5ld0NvbnRleHQuZ2V0UGFyc2VkKENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSKTtcbiAgICB2YXIgc2VjVmFsID0gbmV3Q29udGV4dC5nZXRQYXJzZWQoQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURSk7XG4gICAgdmFyIG5hbm9WYWwgPSBuZXdDb250ZXh0LmdldFBhcnNlZChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCk7XG4gICAgdmFyIHNlYyA9IHNlY1ZhbCAhPSBudWxsID8gc2VjVmFsIDogMDtcbiAgICB2YXIgbmFubyA9IG5hbm9WYWwgIT0gbnVsbCA/IG5hbm9WYWwgOiAwO1xuICAgIHZhciB5ZWFyID0gTWF0aFV0aWwuaW50TW9kKHllYXJQYXJzZWQsIDEwMDAwKTtcbiAgICB2YXIgZGF5cyA9IDA7XG5cbiAgICBpZiAoaG91ciA9PT0gMjQgJiYgbWluID09PSAwICYmIHNlYyA9PT0gMCAmJiBuYW5vID09PSAwKSB7XG4gICAgICBob3VyID0gMDtcbiAgICAgIGRheXMgPSAxO1xuICAgIH0gZWxzZSBpZiAoaG91ciA9PT0gMjMgJiYgbWluID09PSA1OSAmJiBzZWMgPT09IDYwKSB7XG4gICAgICBjb250ZXh0LnNldFBhcnNlZExlYXBTZWNvbmQoKTtcbiAgICAgIHNlYyA9IDU5O1xuICAgIH1cblxuICAgIHZhciBpbnN0YW50U2VjcztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgbGR0ID0gTG9jYWxEYXRlVGltZS5vZih5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYywgMCkucGx1c0RheXMoZGF5cyk7XG4gICAgICBpbnN0YW50U2VjcyA9IGxkdC50b0Vwb2NoU2Vjb25kKFpvbmVPZmZzZXQuVVRDKTtcbiAgICAgIGluc3RhbnRTZWNzICs9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShNYXRoVXRpbC5pbnREaXYoeWVhclBhcnNlZCwgMTAwMDApLCBTRUNPTkRTX1BFUl8xMDAwMF9ZRUFSUyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiB+cG9zaXRpb247XG4gICAgfVxuXG4gICAgdmFyIHN1Y2Nlc3NQb3MgPSBwb3M7XG4gICAgc3VjY2Vzc1BvcyA9IGNvbnRleHQuc2V0UGFyc2VkRmllbGQoQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTLCBpbnN0YW50U2VjcywgcG9zaXRpb24sIHN1Y2Nlc3NQb3MpO1xuICAgIHJldHVybiBjb250ZXh0LnNldFBhcnNlZEZpZWxkKENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05ELCBuYW5vLCBwb3NpdGlvbiwgc3VjY2Vzc1Bvcyk7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnSW5zdGFudCgpJztcbiAgfTtcblxuICByZXR1cm4gSW5zdGFudFByaW50ZXJQYXJzZXI7XG59KCk7XG5cbmZ1bmN0aW9uIF9pbml0JGUoKSB7XG4gIFJlZHVjZWRQcmludGVyUGFyc2VyLkJBU0VfREFURSA9IExvY2FsRGF0ZS5vZigyMDAwLCAxLCAxKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyLkNvbXBvc2l0ZVByaW50ZXJQYXJzZXIgPSBDb21wb3NpdGVQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuUGFkUHJpbnRlclBhcnNlckRlY29yYXRvciA9IFBhZFByaW50ZXJQYXJzZXJEZWNvcmF0b3I7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5TZXR0aW5nc1BhcnNlciA9IFNldHRpbmdzUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyID0gU3RyaW5nTGl0ZXJhbFByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5TdHJpbmdMaXRlcmFsUHJpbnRlclBhcnNlciA9IFN0cmluZ0xpdGVyYWxQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyID0gQ2hhckxpdGVyYWxQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuTnVtYmVyUHJpbnRlclBhcnNlciA9IE51bWJlclByaW50ZXJQYXJzZXI7XG4gIERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlci5SZWR1Y2VkUHJpbnRlclBhcnNlciA9IFJlZHVjZWRQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuRnJhY3Rpb25QcmludGVyUGFyc2VyID0gRnJhY3Rpb25QcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuT2Zmc2V0SWRQcmludGVyUGFyc2VyID0gT2Zmc2V0SWRQcmludGVyUGFyc2VyO1xuICBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIuWm9uZUlkUHJpbnRlclBhcnNlciA9IFpvbmVJZFByaW50ZXJQYXJzZXI7XG59XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBTdHJpbmdCdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJpbmdCdWlsZGVyKCkge1xuICAgIHRoaXMuX3N0ciA9ICcnO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0cmluZ0J1aWxkZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyKSB7XG4gICAgdGhpcy5fc3RyICs9IHN0cjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYXBwZW5kQ2hhciA9IGZ1bmN0aW9uIGFwcGVuZENoYXIoc3RyKSB7XG4gICAgdGhpcy5fc3RyICs9IHN0clswXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0KG9mZnNldCwgc3RyKSB7XG4gICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnNsaWNlKDAsIG9mZnNldCkgKyBzdHIgKyB0aGlzLl9zdHIuc2xpY2Uob2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uoc3RhcnQsIGVuZCwgc3RyKSB7XG4gICAgdGhpcy5fc3RyID0gdGhpcy5fc3RyLnNsaWNlKDAsIHN0YXJ0KSArIHN0ciArIHRoaXMuX3N0ci5zbGljZShlbmQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ci5sZW5ndGg7XG4gIH07XG5cbiAgX3Byb3RvLnNldExlbmd0aCA9IGZ1bmN0aW9uIHNldExlbmd0aChsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHIgPSB0aGlzLl9zdHIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyO1xuICB9O1xuXG4gIHJldHVybiBTdHJpbmdCdWlsZGVyO1xufSgpO1xuXG4vKipcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgRGF0ZVRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIERhdGVUaW1lRm9ybWF0dGVyLnBhcnNlZEV4Y2Vzc0RheXMgPSBmdW5jdGlvbiBwYXJzZWRFeGNlc3NEYXlzKCkge1xuICAgIHJldHVybiBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfRVhDRVNTX0RBWVM7XG4gIH07XG5cbiAgRGF0ZVRpbWVGb3JtYXR0ZXIucGFyc2VkTGVhcFNlY29uZCA9IGZ1bmN0aW9uIHBhcnNlZExlYXBTZWNvbmQoKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyLlBBUlNFRF9MRUFQX1NFQ09ORDtcbiAgfTtcblxuICBEYXRlVGltZUZvcm1hdHRlci5vZlBhdHRlcm4gPSBmdW5jdGlvbiBvZlBhdHRlcm4ocGF0dGVybikge1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kUGF0dGVybihwYXR0ZXJuKS50b0Zvcm1hdHRlcigpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0dGVyKHByaW50ZXJQYXJzZXIsIGxvY2FsZSwgZGVjaW1hbFN0eWxlLCByZXNvbHZlclN0eWxlLCByZXNvbHZlckZpZWxkcywgY2hyb25vLCB6b25lKSB7XG4gICAgaWYgKGNocm9ubyA9PT0gdm9pZCAwKSB7XG4gICAgICBjaHJvbm8gPSBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICAgIH1cblxuICAgIGFzc2VydChwcmludGVyUGFyc2VyICE9IG51bGwpO1xuICAgIGFzc2VydChkZWNpbWFsU3R5bGUgIT0gbnVsbCk7XG4gICAgYXNzZXJ0KHJlc29sdmVyU3R5bGUgIT0gbnVsbCk7XG4gICAgdGhpcy5fcHJpbnRlclBhcnNlciA9IHByaW50ZXJQYXJzZXI7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX2RlY2ltYWxTdHlsZSA9IGRlY2ltYWxTdHlsZTtcbiAgICB0aGlzLl9yZXNvbHZlclN0eWxlID0gcmVzb2x2ZXJTdHlsZTtcbiAgICB0aGlzLl9yZXNvbHZlckZpZWxkcyA9IHJlc29sdmVyRmllbGRzO1xuICAgIHRoaXMuX2Nocm9ubyA9IGNocm9ubztcbiAgICB0aGlzLl96b25lID0gem9uZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEYXRlVGltZUZvcm1hdHRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmxvY2FsZSA9IGZ1bmN0aW9uIGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICB9O1xuXG4gIF9wcm90by5kZWNpbWFsU3R5bGUgPSBmdW5jdGlvbiBkZWNpbWFsU3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY2ltYWxTdHlsZTtcbiAgfTtcblxuICBfcHJvdG8uY2hyb25vbG9neSA9IGZ1bmN0aW9uIGNocm9ub2xvZ3koKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nocm9ubztcbiAgfTtcblxuICBfcHJvdG8ud2l0aENocm9ub2xvZ3kgPSBmdW5jdGlvbiB3aXRoQ2hyb25vbG9neShjaHJvbm8pIHtcbiAgICBpZiAodGhpcy5fY2hyb25vICE9IG51bGwgJiYgdGhpcy5fY2hyb25vLmVxdWFscyhjaHJvbm8pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0dGVyKHRoaXMuX3ByaW50ZXJQYXJzZXIsIHRoaXMuX2xvY2FsZSwgdGhpcy5fZGVjaW1hbFN0eWxlLCB0aGlzLl9yZXNvbHZlclN0eWxlLCB0aGlzLl9yZXNvbHZlckZpZWxkcywgY2hyb25vLCB0aGlzLl96b25lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aExvY2FsZSA9IGZ1bmN0aW9uIHdpdGhMb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhSZXNvbHZlclN0eWxlID0gZnVuY3Rpb24gd2l0aFJlc29sdmVyU3R5bGUocmVzb2x2ZXJTdHlsZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHJlc29sdmVyU3R5bGUsICdyZXNvbHZlclN0eWxlJyk7XG5cbiAgICBpZiAocmVzb2x2ZXJTdHlsZS5lcXVhbHModGhpcy5fcmVzb2x2ZXJTdHlsZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXIodGhpcy5fcHJpbnRlclBhcnNlciwgdGhpcy5fbG9jYWxlLCB0aGlzLl9kZWNpbWFsU3R5bGUsIHJlc29sdmVyU3R5bGUsIHRoaXMuX3Jlc29sdmVyRmllbGRzLCB0aGlzLl9jaHJvbm8sIHRoaXMuX3pvbmUpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQodGVtcG9yYWwpIHtcbiAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1aWxkZXIoMzIpO1xuXG4gICAgdGhpcy5fZm9ybWF0VG8odGVtcG9yYWwsIGJ1Zik7XG5cbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9mb3JtYXRUbyA9IGZ1bmN0aW9uIF9mb3JtYXRUbyh0ZW1wb3JhbCwgYXBwZW5kYWJsZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcbiAgICByZXF1aXJlTm9uTnVsbChhcHBlbmRhYmxlLCAnYXBwZW5kYWJsZScpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IERhdGVUaW1lUHJpbnRDb250ZXh0KHRlbXBvcmFsLCB0aGlzKTtcblxuICAgIHRoaXMuX3ByaW50ZXJQYXJzZXIucHJpbnQoY29udGV4dCwgYXBwZW5kYWJsZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgdHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZTEodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlMih0ZXh0LCB0eXBlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlMSA9IGZ1bmN0aW9uIHBhcnNlMSh0ZXh0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VUb0J1aWxkZXIodGV4dCwgbnVsbCkucmVzb2x2ZSh0aGlzLl9yZXNvbHZlclN0eWxlLCB0aGlzLl9yZXNvbHZlckZpZWxkcyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIERhdGVUaW1lUGFyc2VFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcih0ZXh0LCBleCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wYXJzZTIgPSBmdW5jdGlvbiBwYXJzZTIodGV4dCwgdHlwZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRleHQsICd0ZXh0Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwodHlwZSwgJ3R5cGUnKTtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYnVpbGRlciA9IHRoaXMuX3BhcnNlVG9CdWlsZGVyKHRleHQsIG51bGwpLnJlc29sdmUodGhpcy5fcmVzb2x2ZXJTdHlsZSwgdGhpcy5fcmVzb2x2ZXJGaWVsZHMpO1xuXG4gICAgICByZXR1cm4gYnVpbGRlci5idWlsZCh0eXBlKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKHRleHQsIGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIF9jcmVhdGVFcnJvcih0ZXh0LCBleCkge1xuICAgIHZhciBhYmJyID0gJyc7XG5cbiAgICBpZiAodGV4dC5sZW5ndGggPiA2NCkge1xuICAgICAgYWJiciA9IHRleHQuc3Vic3RyaW5nKDAsIDY0KSArIFwiLi4uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFiYnIgPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWVQYXJzZUV4Y2VwdGlvbihcIlRleHQgJ1wiICsgYWJiciArIFwiJyBjb3VsZCBub3QgYmUgcGFyc2VkOiBcIiArIGV4Lm1lc3NhZ2UsIHRleHQsIDAsIGV4KTtcbiAgfTtcblxuICBfcHJvdG8uX3BhcnNlVG9CdWlsZGVyID0gZnVuY3Rpb24gX3BhcnNlVG9CdWlsZGVyKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uICE9IG51bGwgPyBwb3NpdGlvbiA6IG5ldyBQYXJzZVBvc2l0aW9uKDApO1xuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuX3BhcnNlVW5yZXNvbHZlZDAodGV4dCwgcG9zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCBwb3MuZ2V0RXJyb3JJbmRleCgpID49IDAgfHwgcG9zaXRpb24gPT0gbnVsbCAmJiBwb3MuZ2V0SW5kZXgoKSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICB2YXIgYWJiciA9ICcnO1xuXG4gICAgICBpZiAodGV4dC5sZW5ndGggPiA2NCkge1xuICAgICAgICBhYmJyID0gdGV4dC5zdWJzdHIoMCwgNjQpLnRvU3RyaW5nKCkgKyBcIi4uLlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWJiciA9IHRleHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MuZ2V0RXJyb3JJbmRleCgpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJUZXh0ICdcIiArIGFiYnIgKyBcIicgY291bGQgbm90IGJlIHBhcnNlZCBhdCBpbmRleCBcIiArIHBvcy5nZXRFcnJvckluZGV4KCksIHRleHQsIHBvcy5nZXRFcnJvckluZGV4KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJUZXh0ICdcIiArIGFiYnIgKyBcIicgY291bGQgbm90IGJlIHBhcnNlZCwgdW5wYXJzZWQgdGV4dCBmb3VuZCBhdCBpbmRleCBcIiArIHBvcy5nZXRJbmRleCgpLCB0ZXh0LCBwb3MuZ2V0SW5kZXgoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC50b0J1aWxkZXIoKTtcbiAgfTtcblxuICBfcHJvdG8ucGFyc2VVbnJlc29sdmVkID0gZnVuY3Rpb24gcGFyc2VVbnJlc29sdmVkKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlVW5yZXNvbHZlZDAodGV4dCwgcG9zaXRpb24pO1xuICB9O1xuXG4gIF9wcm90by5fcGFyc2VVbnJlc29sdmVkMCA9IGZ1bmN0aW9uIF9wYXJzZVVucmVzb2x2ZWQwKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgYXNzZXJ0KHRleHQgIT0gbnVsbCwgJ3RleHQnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG4gICAgYXNzZXJ0KHBvc2l0aW9uICE9IG51bGwsICdwb3NpdGlvbicsIE51bGxQb2ludGVyRXhjZXB0aW9uKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBEYXRlVGltZVBhcnNlQ29udGV4dCh0aGlzKTtcbiAgICB2YXIgcG9zID0gcG9zaXRpb24uZ2V0SW5kZXgoKTtcbiAgICBwb3MgPSB0aGlzLl9wcmludGVyUGFyc2VyLnBhcnNlKGNvbnRleHQsIHRleHQsIHBvcyk7XG5cbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgcG9zaXRpb24uc2V0RXJyb3JJbmRleCh+cG9zKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHBvc2l0aW9uLnNldEluZGV4KHBvcyk7XG4gICAgcmV0dXJuIGNvbnRleHQudG9QYXJzZWQoKTtcbiAgfTtcblxuICBfcHJvdG8uX3RvUHJpbnRlclBhcnNlciA9IGZ1bmN0aW9uIF90b1ByaW50ZXJQYXJzZXIob3B0aW9uYWwpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpbnRlclBhcnNlci53aXRoT3B0aW9uYWwob3B0aW9uYWwpO1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBwYXR0ZXJuID0gdGhpcy5fcHJpbnRlclBhcnNlci50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZignWycpID09PSAwID8gcGF0dGVybiA6IHBhdHRlcm4uc3Vic3RyaW5nKDEsIHBhdHRlcm4ubGVuZ3RoIC0gMSk7XG4gIH07XG5cbiAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyO1xufSgpO1xuZnVuY3Rpb24gX2luaXQkZCgpIHtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkuYXBwZW5kTGl0ZXJhbCgnLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIDIpLmFwcGVuZExpdGVyYWwoJy0nKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX1RJTUUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuSE9VUl9PRl9EQVksIDIpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUiwgMikub3B0aW9uYWxTdGFydCgpLmFwcGVuZExpdGVyYWwoJzonKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfTUlOVVRFLCAyKS5vcHRpb25hbFN0YXJ0KCkuYXBwZW5kRnJhY3Rpb24oQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQsIDAsIDksIHRydWUpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEVfVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfREFURSkuYXBwZW5kTGl0ZXJhbCgnVCcpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRSkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fSU5TVEFOVCA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZEluc3RhbnQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfREFURV9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUUpLmFwcGVuZE9mZnNldElkKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fWk9ORURfREFURV9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fT0ZGU0VUX0RBVEVfVElNRSkub3B0aW9uYWxTdGFydCgpLmFwcGVuZExpdGVyYWwoJ1snKS5wYXJzZUNhc2VTZW5zaXRpdmUoKS5hcHBlbmRab25lSWQoKS5hcHBlbmRMaXRlcmFsKCddJykudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5CQVNJQ19JU09fREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCAyKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9EQVRFID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFKS5hcHBlbmRPZmZzZXRJZCgpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9USU1FID0gbmV3IERhdGVUaW1lRm9ybWF0dGVyQnVpbGRlcigpLnBhcnNlQ2FzZUluc2Vuc2l0aXZlKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9USU1FKS5hcHBlbmRPZmZzZXRJZCgpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKS53aXRoQ2hyb25vbG9neShJc29DaHJvbm9sb2d5LklOU1RBTkNFKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09SRElOQUxfREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1dFRUtfREFURSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctVycpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuREFZX09GX1dFRUspLnRvRm9ybWF0dGVyKFJlc29sdmVyU3R5bGUuU1RSSUNUKTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0RBVEUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkucGFyc2VDYXNlSW5zZW5zaXRpdmUoKS5hcHBlbmQoRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEUpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRPZmZzZXRJZCgpLm9wdGlvbmFsRW5kKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5JU09fVElNRSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5wYXJzZUNhc2VJbnNlbnNpdGl2ZSgpLmFwcGVuZChEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRSkub3B0aW9uYWxTdGFydCgpLmFwcGVuZE9mZnNldElkKCkub3B0aW9uYWxFbmQoKS50b0Zvcm1hdHRlcihSZXNvbHZlclN0eWxlLlNUUklDVCk7XG4gIERhdGVUaW1lRm9ybWF0dGVyLklTT19EQVRFX1RJTUUgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kKERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUUpLm9wdGlvbmFsU3RhcnQoKS5hcHBlbmRPZmZzZXRJZCgpLm9wdGlvbmFsRW5kKCkudG9Gb3JtYXR0ZXIoUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpLndpdGhDaHJvbm9sb2d5KElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0UpO1xuICBEYXRlVGltZUZvcm1hdHRlci5QQVJTRURfRVhDRVNTX0RBWVMgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdQQVJTRURfRVhDRVNTX0RBWVMnLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBEYXRlVGltZUJ1aWxkZXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC5leGNlc3NEYXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGVyaW9kLlpFUk87XG4gICAgfVxuICB9KTtcbiAgRGF0ZVRpbWVGb3JtYXR0ZXIuUEFSU0VEX0xFQVBfU0VDT05EID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnUEFSU0VEX0xFQVBfU0VDT05EJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgRGF0ZVRpbWVCdWlsZGVyKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWwubGVhcFNlY29uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBNb250aERheSA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBY2Nlc3Nvcikge1xuICBfaW5oZXJpdHNMb29zZShNb250aERheSwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIE1vbnRoRGF5Lm5vdyA9IGZ1bmN0aW9uIG5vdyh6b25lSWRPckNsb2NrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBNb250aERheS5ub3cwKCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHpvbmVJZE9yQ2xvY2sgaW5zdGFuY2VvZiBab25lSWQpIHtcbiAgICAgIHJldHVybiBNb250aERheS5ub3dab25lSWQoem9uZUlkT3JDbG9jayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNb250aERheS5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG5cbiAgTW9udGhEYXkubm93MCA9IGZ1bmN0aW9uIG5vdzAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm93Q2xvY2soQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gIH07XG5cbiAgTW9udGhEYXkubm93Wm9uZUlkID0gZnVuY3Rpb24gbm93Wm9uZUlkKHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJldHVybiB0aGlzLm5vd0Nsb2NrKENsb2NrLnN5c3RlbSh6b25lKSk7XG4gIH07XG5cbiAgTW9udGhEYXkubm93Q2xvY2sgPSBmdW5jdGlvbiBub3dDbG9jayhjbG9jaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICB2YXIgbm93ID0gTG9jYWxEYXRlLm5vdyhjbG9jayk7XG4gICAgcmV0dXJuIE1vbnRoRGF5Lm9mKG5vdy5tb250aCgpLCBub3cuZGF5T2ZNb250aCgpKTtcbiAgfTtcblxuICBNb250aERheS5vZiA9IGZ1bmN0aW9uIG9mKG1vbnRoT3JOdW1iZXIsIG51bWJlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIG1vbnRoT3JOdW1iZXIgaW5zdGFuY2VvZiBNb250aCkge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5Lm9mTW9udGhOdW1iZXIobW9udGhPck51bWJlciwgbnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5Lm9mTnVtYmVyTnVtYmVyKG1vbnRoT3JOdW1iZXIsIG51bWJlcik7XG4gICAgfVxuICB9O1xuXG4gIE1vbnRoRGF5Lm9mTW9udGhOdW1iZXIgPSBmdW5jdGlvbiBvZk1vbnRoTnVtYmVyKG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USC5jaGVja1ZhbGlkVmFsdWUoZGF5T2ZNb250aCk7XG5cbiAgICBpZiAoZGF5T2ZNb250aCA+IG1vbnRoLm1heExlbmd0aCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oXCJJbGxlZ2FsIHZhbHVlIGZvciBEYXlPZk1vbnRoIGZpZWxkLCB2YWx1ZSBcIiArIGRheU9mTW9udGggKyBcIiBpcyBub3QgdmFsaWQgZm9yIG1vbnRoIFwiICsgbW9udGgudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb250aERheShtb250aC52YWx1ZSgpLCBkYXlPZk1vbnRoKTtcbiAgfTtcblxuICBNb250aERheS5vZk51bWJlck51bWJlciA9IGZ1bmN0aW9uIG9mTnVtYmVyTnVtYmVyKG1vbnRoLCBkYXlPZk1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGgsICdtb250aCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mTW9udGgsICdkYXlPZk1vbnRoJyk7XG4gICAgcmV0dXJuIE1vbnRoRGF5Lm9mKE1vbnRoLm9mKG1vbnRoKSwgZGF5T2ZNb250aCk7XG4gIH07XG5cbiAgTW9udGhEYXkuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRlbXBvcmFsLCBUZW1wb3JhbEFjY2Vzc29yLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIE1vbnRoRGF5KSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBNb250aERheS5vZih0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiksIHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBNb250aERheSBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbCAmJiB0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIE1vbnRoRGF5LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBNb250aERheS5wYXJzZVN0cmluZyh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1vbnRoRGF5LnBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcik7XG4gICAgfVxuICB9O1xuXG4gIE1vbnRoRGF5LnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gcGFyc2VTdHJpbmcodGV4dCkge1xuICAgIHJldHVybiBNb250aERheS5wYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBQQVJTRVIkMik7XG4gIH07XG5cbiAgTW9udGhEYXkucGFyc2VTdHJpbmdGb3JtYXR0ZXIgPSBmdW5jdGlvbiBwYXJzZVN0cmluZ0Zvcm1hdHRlcih0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmb3JtYXR0ZXIsIERhdGVUaW1lRm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBNb250aERheS5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250aERheShtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsQWNjZXNzb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9tb250aCA9IE1hdGhVdGlsLnNhZmVUb0ludChtb250aCk7XG4gICAgX3RoaXMuX2RheSA9IE1hdGhVdGlsLnNhZmVUb0ludChkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTW9udGhEYXkucHJvdG90eXBlO1xuXG4gIF9wcm90by5tb250aFZhbHVlID0gZnVuY3Rpb24gbW9udGhWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9udGg7XG4gIH07XG5cbiAgX3Byb3RvLm1vbnRoID0gZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgcmV0dXJuIE1vbnRoLm9mKHRoaXMuX21vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RheTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLkRBWV9PRl9NT05USDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSB7XG4gICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpIHtcbiAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIHRoaXMubW9udGgoKS5taW5MZW5ndGgoKSwgdGhpcy5tb250aCgpLm1heExlbmd0aCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1RlbXBvcmFsQWNjZXNzb3IucHJvdG90eXBlLnJhbmdlLmNhbGwodGhpcywgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZShmaWVsZCkuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuZ2V0TG9uZyhmaWVsZCksIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGF5O1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGg7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uaXNWYWxpZFllYXIgPSBmdW5jdGlvbiBpc1ZhbGlkWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh0aGlzLl9kYXkgPT09IDI5ICYmIHRoaXMuX21vbnRoID09PSAyICYmIFllYXIuaXNMZWFwKHllYXIpID09PSBmYWxzZSkgPT09IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy53aXRoKE1vbnRoLm9mKG1vbnRoKSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGggPSBmdW5jdGlvbiBfd2l0aChtb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcblxuICAgIGlmIChtb250aC52YWx1ZSgpID09PSB0aGlzLl9tb250aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGRheSA9IE1hdGgubWluKHRoaXMuX2RheSwgbW9udGgubWF4TGVuZ3RoKCkpO1xuICAgIHJldHVybiBuZXcgTW9udGhEYXkobW9udGgudmFsdWUoKSwgZGF5KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mTW9udGggPSBmdW5jdGlvbiB3aXRoRGF5T2ZNb250aChkYXlPZk1vbnRoKSB7XG4gICAgaWYgKGRheU9mTW9udGggPT09IHRoaXMuX2RheSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1vbnRoRGF5Lm9mKHRoaXMuX21vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShfcXVlcnksIFRlbXBvcmFsUXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIElzb0Nocm9ub2xvZ3kuSU5TVEFOQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbEFjY2Vzc29yLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIF9xdWVyeSk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHRlbXBvcmFsID0gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCB0aGlzLl9tb250aCk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCBNYXRoLm1pbih0ZW1wb3JhbC5yYW5nZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgpLm1heGltdW0oKSwgdGhpcy5fZGF5KSk7XG4gIH07XG5cbiAgX3Byb3RvLmF0WWVhciA9IGZ1bmN0aW9uIGF0WWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih5ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5pc1ZhbGlkWWVhcih5ZWFyKSA/IHRoaXMuX2RheSA6IDI4KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgTW9udGhEYXksICdvdGhlcicpO1xuICAgIHZhciBjbXAgPSB0aGlzLl9tb250aCAtIG90aGVyLm1vbnRoVmFsdWUoKTtcblxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMuX2RheSAtIG90aGVyLmRheU9mTW9udGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE1vbnRoRGF5LCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID4gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE1vbnRoRGF5LCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG9iaikge1xuICAgIGlmICh0aGlzID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBNb250aERheSkge1xuICAgICAgdmFyIG90aGVyID0gb2JqO1xuICAgICAgcmV0dXJuIHRoaXMubW9udGhWYWx1ZSgpID09PSBvdGhlci5tb250aFZhbHVlKCkgJiYgdGhpcy5kYXlPZk1vbnRoKCkgPT09IG90aGVyLmRheU9mTW9udGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiLS1cIiArICh0aGlzLl9tb250aCA8IDEwID8gJzAnIDogJycpICsgdGhpcy5fbW9udGggKyAodGhpcy5fZGF5IDwgMTAgPyAnLTAnIDogJy0nKSArIHRoaXMuX2RheTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBNb250aERheTtcbn0oVGVtcG9yYWxBY2Nlc3Nvcik7XG52YXIgUEFSU0VSJDI7XG5mdW5jdGlvbiBfaW5pdCRjKCkge1xuICBQQVJTRVIkMiA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRMaXRlcmFsKCctLScpLmFwcGVuZFZhbHVlKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIsIDIpLmFwcGVuZExpdGVyYWwoJy0nKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDIpLnRvRm9ybWF0dGVyKCk7XG4gIE1vbnRoRGF5LkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdNb250aERheS5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIE1vbnRoRGF5LmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIFllYXJNb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoWWVhck1vbnRoLCBfVGVtcG9yYWwpO1xuXG4gIFllYXJNb250aC5ub3cgPSBmdW5jdGlvbiBub3coem9uZUlkT3JDbG9jaykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm5vdzAoKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgem9uZUlkT3JDbG9jayBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgcmV0dXJuIFllYXJNb250aC5ub3dab25lSWQoem9uZUlkT3JDbG9jayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgubm93Q2xvY2soem9uZUlkT3JDbG9jayk7XG4gICAgfVxuICB9O1xuXG4gIFllYXJNb250aC5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gWWVhck1vbnRoLm5vd0Nsb2NrKENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICB9O1xuXG4gIFllYXJNb250aC5ub3dab25lSWQgPSBmdW5jdGlvbiBub3dab25lSWQoem9uZSkge1xuICAgIHJldHVybiBZZWFyTW9udGgubm93Q2xvY2soQ2xvY2suc3lzdGVtKHpvbmUpKTtcbiAgfTtcblxuICBZZWFyTW9udGgubm93Q2xvY2sgPSBmdW5jdGlvbiBub3dDbG9jayhjbG9jaykge1xuICAgIHZhciBub3cgPSBMb2NhbERhdGUubm93KGNsb2NrKTtcbiAgICByZXR1cm4gWWVhck1vbnRoLm9mKG5vdy55ZWFyKCksIG5vdy5tb250aCgpKTtcbiAgfTtcblxuICBZZWFyTW9udGgub2YgPSBmdW5jdGlvbiBvZih5ZWFyLCBtb250aE9yTnVtYmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbW9udGhPck51bWJlciBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICByZXR1cm4gWWVhck1vbnRoLm9mTnVtYmVyTW9udGgoeWVhciwgbW9udGhPck51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgub2ZOdW1iZXJOdW1iZXIoeWVhciwgbW9udGhPck51bWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFllYXJNb250aC5vZk51bWJlck1vbnRoID0gZnVuY3Rpb24gb2ZOdW1iZXJNb250aCh5ZWFyLCBtb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UobW9udGgsIE1vbnRoLCAnbW9udGgnKTtcbiAgICByZXR1cm4gWWVhck1vbnRoLm9mTnVtYmVyTnVtYmVyKHllYXIsIG1vbnRoLnZhbHVlKCkpO1xuICB9O1xuXG4gIFllYXJNb250aC5vZk51bWJlck51bWJlciA9IGZ1bmN0aW9uIG9mTnVtYmVyTnVtYmVyKHllYXIsIG1vbnRoKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoeWVhciwgJ3llYXInKTtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoeWVhcik7XG4gICAgQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUi5jaGVja1ZhbGlkVmFsdWUobW9udGgpO1xuICAgIHJldHVybiBuZXcgWWVhck1vbnRoKHllYXIsIG1vbnRoKTtcbiAgfTtcblxuICBZZWFyTW9udGguZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBZZWFyTW9udGgpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFllYXJNb250aC5vZih0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuWUVBUiksIHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gWWVhck1vbnRoIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsICYmIHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhck1vbnRoLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgucGFyc2VTdHJpbmcodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBZZWFyTW9udGgucGFyc2VTdHJpbmdGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhck1vbnRoLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gcGFyc2VTdHJpbmcodGV4dCkge1xuICAgIHJldHVybiBZZWFyTW9udGgucGFyc2VTdHJpbmdGb3JtYXR0ZXIodGV4dCwgUEFSU0VSJDEpO1xuICB9O1xuXG4gIFllYXJNb250aC5wYXJzZVN0cmluZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uIHBhcnNlU3RyaW5nRm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgWWVhck1vbnRoLkZST00pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFllYXJNb250aCh5ZWFyLCBtb250aCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5feWVhciA9IE1hdGhVdGlsLnNhZmVUb0ludCh5ZWFyKTtcbiAgICBfdGhpcy5fbW9udGggPSBNYXRoVXRpbC5zYWZlVG9JbnQobW9udGgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBZZWFyTW9udGgucHJvdG90eXBlO1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgZmllbGRPclVuaXQgaW5zdGFuY2VvZiBUZW1wb3JhbEZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZEZpZWxkKGZpZWxkT3JVbml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRVbml0KGZpZWxkT3JVbml0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkRmllbGQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEZpZWxkKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUiB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIIHx8IGZpZWxkID09PSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuRVJBO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZCAhPSBudWxsICYmIGZpZWxkLmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkVW5pdCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkVW5pdCh1bml0KSB7XG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gdW5pdCA9PT0gQ2hyb25vVW5pdC5NT05USFMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5ZRUFSUyB8fCB1bml0ID09PSBDaHJvbm9Vbml0LkRFQ0FERVMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5DRU5UVVJJRVMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5NSUxMRU5OSUEgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5FUkFTO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0ICE9IG51bGwgJiYgdW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yYW5nZSA9IGZ1bmN0aW9uIHJhbmdlKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQSkge1xuICAgICAgcmV0dXJuIHRoaXMueWVhcigpIDw9IDAgPyBWYWx1ZVJhbmdlLm9mKDEsIFllYXIuTUFYX1ZBTFVFICsgMSkgOiBWYWx1ZVJhbmdlLm9mKDEsIFllYXIuTUFYX1ZBTFVFKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX1RlbXBvcmFsLnByb3RvdHlwZS5yYW5nZS5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2UoZmllbGQpLmNoZWNrVmFsaWRJbnRWYWx1ZSh0aGlzLmdldExvbmcoZmllbGQpLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9sZXB0aWNNb250aCgpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPCAxID8gMSAtIHRoaXMuX3llYXIgOiB0aGlzLl95ZWFyO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhcjtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8IDEgPyAwIDogMTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0UHJvbGVwdGljTW9udGggPSBmdW5jdGlvbiBfZ2V0UHJvbGVwdGljTW9udGgoKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoTWF0aFV0aWwuc2FmZU11bHRpcGx5KHRoaXMuX3llYXIsIDEyKSwgdGhpcy5fbW9udGggLSAxKTtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXI7XG4gIH07XG5cbiAgX3Byb3RvLm1vbnRoVmFsdWUgPSBmdW5jdGlvbiBtb250aFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb250aDtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gTW9udGgub2YodGhpcy5fbW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5pc0xlYXBZZWFyID0gZnVuY3Rpb24gaXNMZWFwWWVhcigpIHtcbiAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHRoaXMuX3llYXIpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkRGF5ID0gZnVuY3Rpb24gaXNWYWxpZERheShkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIGRheU9mTW9udGggPj0gMSAmJiBkYXlPZk1vbnRoIDw9IHRoaXMubGVuZ3RoT2ZNb250aCgpO1xuICB9O1xuXG4gIF9wcm90by5sZW5ndGhPZk1vbnRoID0gZnVuY3Rpb24gbGVuZ3RoT2ZNb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpLmxlbmd0aCh0aGlzLmlzTGVhcFllYXIoKSk7XG4gIH07XG5cbiAgX3Byb3RvLmxlbmd0aE9mWWVhciA9IGZ1bmN0aW9uIGxlbmd0aE9mWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlYXBZZWFyKCkgPyAzNjYgOiAzNjU7XG4gIH07XG5cbiAgX3Byb3RvLndpdGggPSBmdW5jdGlvbiBfd2l0aChhZGp1c3Rlck9yRmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoQWRqdXN0ZXIoYWRqdXN0ZXJPckZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhGaWVsZChhZGp1c3Rlck9yRmllbGQsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl93aXRoRmllbGQgPSBmdW5jdGlvbiBfd2l0aEZpZWxkKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZmllbGQsIFRlbXBvcmFsRmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG4gICAgICBmLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aE1vbnRoKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIodGhpcy5feWVhciA8IDEgPyAxIC0gbmV3VmFsdWUgOiBuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhZZWFyKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgPT09IG5ld1ZhbHVlID8gdGhpcyA6IHRoaXMud2l0aFllYXIoMSAtIHRoaXMuX3llYXIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWWVhciA9IGZ1bmN0aW9uIHdpdGhZZWFyKHllYXIpIHtcbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICByZXR1cm4gbmV3IFllYXJNb250aCh5ZWFyLCB0aGlzLl9tb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNb250aCA9IGZ1bmN0aW9uIHdpdGhNb250aChtb250aCkge1xuICAgIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIuY2hlY2tWYWxpZFZhbHVlKG1vbnRoKTtcbiAgICByZXR1cm4gbmV3IFllYXJNb250aCh0aGlzLl95ZWFyLCBtb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCwgJ3VuaXQnKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NT05USFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRFQ0FERVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5FUkFTOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGgoQ2hyb25vRmllbGQuRVJBLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpLCBhbW91bnRUb0FkZCkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1llYXJzID0gZnVuY3Rpb24gcGx1c1llYXJzKHllYXJzVG9BZGQpIHtcbiAgICBpZiAoeWVhcnNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld1llYXIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZSh0aGlzLl95ZWFyICsgeWVhcnNUb0FkZCk7XG4gICAgcmV0dXJuIHRoaXMud2l0aFllYXIobmV3WWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRoc1RvQWRkKSB7XG4gICAgaWYgKG1vbnRoc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbW9udGhDb3VudCA9IHRoaXMuX3llYXIgKiAxMiArICh0aGlzLl9tb250aCAtIDEpO1xuICAgIHZhciBjYWxjTW9udGhzID0gbW9udGhDb3VudCArIG1vbnRoc1RvQWRkO1xuICAgIHZhciBuZXdZZWFyID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoTWF0aFV0aWwuZmxvb3JEaXYoY2FsY01vbnRocywgMTIpKTtcbiAgICB2YXIgbmV3TW9udGggPSBNYXRoVXRpbC5mbG9vck1vZChjYWxjTW9udGhzLCAxMikgKyAxO1xuICAgIHJldHVybiBuZXcgWWVhck1vbnRoKG5ld1llYXIsIG5ld01vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHllYXJzVG9TdWJ0cmFjdCA9PT0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLk1JTl9TQUZFX0lOVEVHRVIpLnBsdXNZZWFycygxKSA6IHRoaXMucGx1c1llYXJzKC15ZWFyc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRoc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gbW9udGhzVG9TdWJ0cmFjdCA9PT0gTWF0aFV0aWwuTUlOX1NBRkVfSU5URUdFUiA/IHRoaXMucGx1c01vbnRocyhNYXRoLk1BWF9TQUZFX0lOVEVHRVIpLnBsdXNNb250aHMoMSkgOiB0aGlzLnBsdXNNb250aHMoLW1vbnRoc1RvU3VidHJhY3QpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKF9xdWVyeSwgVGVtcG9yYWxRdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5NT05USFM7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRlbXBvcmFsLCBUZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRILCB0aGlzLl9nZXRQcm9sZXB0aWNNb250aCgpKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShlbmRFeGNsdXNpdmUsIFRlbXBvcmFsLCAnZW5kRXhjbHVzaXZlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHVuaXQsIFRlbXBvcmFsVW5pdCwgJ3VuaXQnKTtcbiAgICB2YXIgZW5kID0gWWVhck1vbnRoLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgdmFyIG1vbnRoc1VudGlsID0gZW5kLl9nZXRQcm9sZXB0aWNNb250aCgpIC0gdGhpcy5fZ2V0UHJvbGVwdGljTW9udGgoKTtcblxuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NT05USFM6XG4gICAgICAgICAgcmV0dXJuIG1vbnRoc1VudGlsO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4gbW9udGhzVW50aWwgLyAxMjtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gbW9udGhzVW50aWwgLyAxMjA7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkNFTlRVUklFUzpcbiAgICAgICAgICByZXR1cm4gbW9udGhzVW50aWwgLyAxMjAwO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIG1vbnRoc1VudGlsIC8gMTIwMDA7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIGVuZC5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0RGF5ID0gZnVuY3Rpb24gYXREYXkoZGF5T2ZNb250aCkge1xuICAgIHJldHVybiBMb2NhbERhdGUub2YodGhpcy5feWVhciwgdGhpcy5fbW9udGgsIGRheU9mTW9udGgpO1xuICB9O1xuXG4gIF9wcm90by5hdEVuZE9mTW9udGggPSBmdW5jdGlvbiBhdEVuZE9mTW9udGgoKSB7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZih0aGlzLl95ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5sZW5ndGhPZk1vbnRoKCkpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyTW9udGgsICdvdGhlcicpO1xuICAgIHZhciBjbXAgPSB0aGlzLl95ZWFyIC0gb3RoZXIueWVhcigpO1xuXG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgY21wID0gdGhpcy5fbW9udGggLSBvdGhlci5tb250aFZhbHVlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID4gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKHRoaXMgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFllYXJNb250aCkge1xuICAgICAgdmFyIG90aGVyID0gb2JqO1xuICAgICAgcmV0dXJuIHRoaXMueWVhcigpID09PSBvdGhlci55ZWFyKCkgJiYgdGhpcy5tb250aFZhbHVlKCkgPT09IG90aGVyLm1vbnRoVmFsdWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFBBUlNFUiQxLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gWWVhck1vbnRoO1xufShUZW1wb3JhbCk7XG52YXIgUEFSU0VSJDE7XG5mdW5jdGlvbiBfaW5pdCRiKCkge1xuICBQQVJTRVIkMSA9IG5ldyBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIoKS5hcHBlbmRWYWx1ZShDaHJvbm9GaWVsZC5ZRUFSLCA0LCAxMCwgU2lnblN0eWxlLkVYQ0VFRFNfUEFEKS5hcHBlbmRMaXRlcmFsKCctJykuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuTU9OVEhfT0ZfWUVBUiwgMikudG9Gb3JtYXR0ZXIoKTtcbiAgWWVhck1vbnRoLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdZZWFyTW9udGguRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBZZWFyTW9udGguZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgWWVhciA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoWWVhciwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBZZWFyKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl95ZWFyID0gTWF0aFV0aWwuc2FmZVRvSW50KHZhbHVlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWWVhci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnZhbHVlID0gZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3llYXI7XG4gIH07XG5cbiAgWWVhci5ub3cgPSBmdW5jdGlvbiBub3coem9uZUlkT3JDbG9jaykge1xuICAgIGlmICh6b25lSWRPckNsb2NrID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmVJZE9yQ2xvY2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHpvbmVJZE9yQ2xvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93MCgpO1xuICAgIH0gZWxzZSBpZiAoem9uZUlkT3JDbG9jayBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgcmV0dXJuIFllYXIubm93Wm9uZUlkKHpvbmVJZE9yQ2xvY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gWWVhci5ub3dDbG9jayh6b25lSWRPckNsb2NrKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhci5ub3cwID0gZnVuY3Rpb24gbm93MCgpIHtcbiAgICByZXR1cm4gWWVhci5ub3dDbG9jayhDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpKTtcbiAgfTtcblxuICBZZWFyLm5vd1pvbmVJZCA9IGZ1bmN0aW9uIG5vd1pvbmVJZCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uoem9uZSwgWm9uZUlkLCAnem9uZScpO1xuICAgIHJldHVybiBZZWFyLm5vd0Nsb2NrKENsb2NrLnN5c3RlbSh6b25lKSk7XG4gIH07XG5cbiAgWWVhci5ub3dDbG9jayA9IGZ1bmN0aW9uIG5vd0Nsb2NrKGNsb2NrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoY2xvY2ssICdjbG9jaycpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShjbG9jaywgQ2xvY2ssICdjbG9jaycpO1xuICAgIHZhciBub3cgPSBMb2NhbERhdGUubm93KGNsb2NrKTtcbiAgICByZXR1cm4gWWVhci5vZihub3cueWVhcigpKTtcbiAgfTtcblxuICBZZWFyLm9mID0gZnVuY3Rpb24gb2YoaXNvWWVhcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGlzb1llYXIsICdpc29ZZWFyJyk7XG4gICAgQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkVmFsdWUoaXNvWWVhcik7XG4gICAgcmV0dXJuIG5ldyBZZWFyKGlzb1llYXIpO1xuICB9O1xuXG4gIFllYXIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRlbXBvcmFsLCBUZW1wb3JhbEFjY2Vzc29yLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFllYXIpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFllYXIub2YodGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLllFQVIpKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBZZWFyIGZyb20gVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsICYmIHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gIH07XG5cbiAgWWVhci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybiBZZWFyLnBhcnNlVGV4dCh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFllYXIucGFyc2VUZXh0Rm9ybWF0dGVyKHRleHQsIGZvcm1hdHRlcik7XG4gICAgfVxuICB9O1xuXG4gIFllYXIucGFyc2VUZXh0ID0gZnVuY3Rpb24gcGFyc2VUZXh0KHRleHQpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZXh0LCAndGV4dCcpO1xuICAgIHJldHVybiBZZWFyLnBhcnNlKHRleHQsIFBBUlNFUik7XG4gIH07XG5cbiAgWWVhci5wYXJzZVRleHRGb3JtYXR0ZXIgPSBmdW5jdGlvbiBwYXJzZVRleHRGb3JtYXR0ZXIodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGZvcm1hdHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBQQVJTRVI7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwodGV4dCwgJ3RleHQnKTtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgWWVhci5GUk9NKTtcbiAgfTtcblxuICBZZWFyLmlzTGVhcCA9IGZ1bmN0aW9uIGlzTGVhcCh5ZWFyKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmludE1vZCh5ZWFyLCA0KSA9PT0gMCAmJiAoTWF0aFV0aWwuaW50TW9kKHllYXIsIDEwMCkgIT09IDAgfHwgTWF0aFV0aWwuaW50TW9kKHllYXIsIDQwMCkgPT09IDApO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgZmllbGRPclVuaXQgaW5zdGFuY2VvZiBUZW1wb3JhbEZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZEZpZWxkKGZpZWxkT3JVbml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWRVbml0KGZpZWxkT3JVbml0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkRmllbGQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZEZpZWxkKGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUiB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEgfHwgZmllbGQgPT09IENocm9ub0ZpZWxkLkVSQTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQgIT0gbnVsbCAmJiBmaWVsZC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZFVuaXQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZFVuaXQodW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgcmV0dXJuIHVuaXQgPT09IENocm9ub1VuaXQuWUVBUlMgfHwgdW5pdCA9PT0gQ2hyb25vVW5pdC5ERUNBREVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuQ0VOVFVSSUVTIHx8IHVuaXQgPT09IENocm9ub1VuaXQuTUlMTEVOTklBIHx8IHVuaXQgPT09IENocm9ub1VuaXQuRVJBUztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdCAhPSBudWxsICYmIHVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkKGZpZWxkKSkge1xuICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucmFuZ2UuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlKGZpZWxkKS5jaGVja1ZhbGlkSW50VmFsdWUodGhpcy5nZXRMb25nKGZpZWxkKSwgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPCAxID8gMSAtIHRoaXMuX3llYXIgOiB0aGlzLl95ZWFyO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhcjtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8IDEgPyAwIDogMTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5pc0xlYXAgPSBmdW5jdGlvbiBpc0xlYXAoKSB7XG4gICAgcmV0dXJuIFllYXIuaXNMZWFwKHRoaXMuX3llYXIpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZpZWxkLCBUZW1wb3JhbEZpZWxkLCAnZmllbGQnKTtcblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBmaWVsZC5jaGVja1ZhbGlkVmFsdWUobmV3VmFsdWUpO1xuXG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgcmV0dXJuIFllYXIub2YodGhpcy5feWVhciA8IDEgPyAxIC0gbmV3VmFsdWUgOiBuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICAgIHJldHVybiBZZWFyLm9mKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkVSQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgPT09IG5ld1ZhbHVlID8gdGhpcyA6IFllYXIub2YoMSAtIHRoaXMuX3llYXIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnRUb0FkZCwgJ2Ftb3VudFRvQWRkJyk7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UodW5pdCwgVGVtcG9yYWxVbml0LCAndW5pdCcpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LllFQVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRFQ0FERVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTApKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIDEwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMRU5OSUE6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5FUkFTOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGgoQ2hyb25vRmllbGQuRVJBLCBNYXRoVXRpbC5zYWZlQWRkKHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpLCBhbW91bnRUb0FkZCkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1llYXJzID0gZnVuY3Rpb24gcGx1c1llYXJzKHllYXJzVG9BZGQpIHtcbiAgICBpZiAoeWVhcnNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFllYXIub2YoQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoTWF0aFV0aWwuc2FmZUFkZCh0aGlzLl95ZWFyLCB5ZWFyc1RvQWRkKSkpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1llYXJzID0gZnVuY3Rpb24gbWludXNZZWFycyh5ZWFyc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4geWVhcnNUb1N1YnRyYWN0ID09PSBNYXRoVXRpbC5NSU5fU0FGRV9JTlRFR0VSID8gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuTUFYX1NBRkVfSU5URUdFUikucGx1c1llYXJzKDEpIDogdGhpcy5wbHVzWWVhcnMoLXllYXJzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLllFQVIsIHRoaXMuX3llYXIpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkTW9udGhEYXkgPSBmdW5jdGlvbiBpc1ZhbGlkTW9udGhEYXkobW9udGhEYXkpIHtcbiAgICByZXR1cm4gbW9udGhEYXkgIT0gbnVsbCAmJiBtb250aERheS5pc1ZhbGlkWWVhcih0aGlzLl95ZWFyKTtcbiAgfTtcblxuICBfcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGVhcCgpID8gMzY2IDogMzY1O1xuICB9O1xuXG4gIF9wcm90by5hdERheSA9IGZ1bmN0aW9uIGF0RGF5KGRheU9mWWVhcikge1xuICAgIHJldHVybiBMb2NhbERhdGUub2ZZZWFyRGF5KHRoaXMuX3llYXIsIGRheU9mWWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLmF0TW9udGggPSBmdW5jdGlvbiBhdE1vbnRoKG1vbnRoT3JOdW1iZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBtb250aE9yTnVtYmVyIGluc3RhbmNlb2YgTW9udGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0TW9udGhNb250aChtb250aE9yTnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYXRNb250aE51bWJlcihtb250aE9yTnVtYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF0TW9udGhNb250aCA9IGZ1bmN0aW9uIGF0TW9udGhNb250aChtb250aCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG1vbnRoLCAnbW9udGgnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UobW9udGgsIE1vbnRoLCAnbW9udGgnKTtcbiAgICByZXR1cm4gWWVhck1vbnRoLm9mKHRoaXMuX3llYXIsIG1vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8uYXRNb250aE51bWJlciA9IGZ1bmN0aW9uIGF0TW9udGhOdW1iZXIobW9udGgpIHtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmV0dXJuIFllYXJNb250aC5vZih0aGlzLl95ZWFyLCBtb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0TW9udGhEYXkgPSBmdW5jdGlvbiBhdE1vbnRoRGF5KG1vbnRoRGF5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwobW9udGhEYXksICdtb250aERheScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShtb250aERheSwgTW9udGhEYXksICdtb250aERheScpO1xuICAgIHJldHVybiBtb250aERheS5hdFllYXIodGhpcy5feWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnkoKScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShfcXVlcnksIFRlbXBvcmFsUXVlcnksICdxdWVyeSgpJyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5ZRUFSUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsRGF0ZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5feWVhciAtIG90aGVyLl95ZWFyO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIFllYXIsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl95ZWFyID4gb3RoZXIuX3llYXI7XG4gIH07XG5cbiAgX3Byb3RvLmlzQmVmb3JlID0gZnVuY3Rpb24gaXNCZWZvcmUob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBZZWFyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5feWVhciA8IG90aGVyLl95ZWFyO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGZvcm1hdHRlciwgRGF0ZVRpbWVGb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBZZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSgpID09PSBvdGhlci52YWx1ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJcIiArIHRoaXMuX3llYXI7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBZZWFyLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgdmFyIHllYXJzVW50aWwgPSBlbmQudmFsdWUoKSAtIHRoaXMudmFsdWUoKTtcblxuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5ZRUFSUzpcbiAgICAgICAgICByZXR1cm4geWVhcnNVbnRpbDtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHllYXJzVW50aWwsIDEwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuQ0VOVFVSSUVTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYoeWVhcnNVbnRpbCwgMTAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYoeWVhcnNVbnRpbCwgMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIGVuZC5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSkgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgcmV0dXJuIFllYXI7XG59KFRlbXBvcmFsKTtcbnZhciBQQVJTRVI7XG5mdW5jdGlvbiBfaW5pdCRhKCkge1xuICBZZWFyLk1JTl9WQUxVRSA9IFllYXJDb25zdGFudHMuTUlOX1ZBTFVFO1xuICBZZWFyLk1BWF9WQUxVRSA9IFllYXJDb25zdGFudHMuTUFYX1ZBTFVFO1xuICBQQVJTRVIgPSBuZXcgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyKCkuYXBwZW5kVmFsdWUoQ2hyb25vRmllbGQuWUVBUiwgNCwgMTAsIFNpZ25TdHlsZS5FWENFRURTX1BBRCkudG9Gb3JtYXR0ZXIoKTtcbiAgWWVhci5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnWWVhci5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIFllYXIuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBUZW1wb3JhbEFkanVzdGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUZW1wb3JhbEFkanVzdGVyKCkge31cblxuICB2YXIgX3Byb3RvID0gVGVtcG9yYWxBZGp1c3Rlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgYWJzdHJhY3RNZXRob2RGYWlsKCdhZGp1c3RJbnRvJyk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsQWRqdXN0ZXI7XG59KCk7XG5cbnZhciBUZW1wb3JhbEFkanVzdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGVtcG9yYWxBZGp1c3RlcnMoKSB7fVxuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmZpcnN0RGF5T2ZNb250aCA9IGZ1bmN0aW9uIGZpcnN0RGF5T2ZNb250aCgpIHtcbiAgICByZXR1cm4gSW1wbC5GSVJTVF9EQVlfT0ZfTU9OVEg7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMubGFzdERheU9mTW9udGggPSBmdW5jdGlvbiBsYXN0RGF5T2ZNb250aCgpIHtcbiAgICByZXR1cm4gSW1wbC5MQVNUX0RBWV9PRl9NT05USDtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdERheU9mTmV4dE1vbnRoID0gZnVuY3Rpb24gZmlyc3REYXlPZk5leHRNb250aCgpIHtcbiAgICByZXR1cm4gSW1wbC5GSVJTVF9EQVlfT0ZfTkVYVF9NT05USDtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5maXJzdERheU9mWWVhciA9IGZ1bmN0aW9uIGZpcnN0RGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9ZRUFSO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmxhc3REYXlPZlllYXIgPSBmdW5jdGlvbiBsYXN0RGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiBJbXBsLkxBU1RfREFZX09GX1lFQVI7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMuZmlyc3REYXlPZk5leHRZZWFyID0gZnVuY3Rpb24gZmlyc3REYXlPZk5leHRZZWFyKCkge1xuICAgIHJldHVybiBJbXBsLkZJUlNUX0RBWV9PRl9ORVhUX1lFQVI7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMuZmlyc3RJbk1vbnRoID0gZnVuY3Rpb24gZmlyc3RJbk1vbnRoKGRheU9mV2Vlaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mV2VlaywgJ2RheU9mV2VlaycpO1xuICAgIHJldHVybiBuZXcgRGF5T2ZXZWVrSW5Nb250aCgxLCBkYXlPZldlZWspO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmxhc3RJbk1vbnRoID0gZnVuY3Rpb24gbGFzdEluTW9udGgoZGF5T2ZXZWVrKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZXZWVrLCAnZGF5T2ZXZWVrJyk7XG4gICAgcmV0dXJuIG5ldyBEYXlPZldlZWtJbk1vbnRoKC0xLCBkYXlPZldlZWspO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLmRheU9mV2Vla0luTW9udGggPSBmdW5jdGlvbiBkYXlPZldlZWtJbk1vbnRoKG9yZGluYWwsIGRheU9mV2Vlaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGRheU9mV2VlaywgJ2RheU9mV2VlaycpO1xuICAgIHJldHVybiBuZXcgRGF5T2ZXZWVrSW5Nb250aChvcmRpbmFsLCBkYXlPZldlZWspO1xuICB9O1xuXG4gIFRlbXBvcmFsQWRqdXN0ZXJzLm5leHQgPSBmdW5jdGlvbiBuZXh0KGRheU9mV2Vlaykge1xuICAgIHJldHVybiBuZXcgUmVsYXRpdmVEYXlPZldlZWsoMiwgZGF5T2ZXZWVrKTtcbiAgfTtcblxuICBUZW1wb3JhbEFkanVzdGVycy5uZXh0T3JTYW1lID0gZnVuY3Rpb24gbmV4dE9yU2FtZShkYXlPZldlZWspIHtcbiAgICByZXR1cm4gbmV3IFJlbGF0aXZlRGF5T2ZXZWVrKDAsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMucHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cyhkYXlPZldlZWspIHtcbiAgICByZXR1cm4gbmV3IFJlbGF0aXZlRGF5T2ZXZWVrKDMsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgVGVtcG9yYWxBZGp1c3RlcnMucHJldmlvdXNPclNhbWUgPSBmdW5jdGlvbiBwcmV2aW91c09yU2FtZShkYXlPZldlZWspIHtcbiAgICByZXR1cm4gbmV3IFJlbGF0aXZlRGF5T2ZXZWVrKDEsIGRheU9mV2Vlayk7XG4gIH07XG5cbiAgcmV0dXJuIFRlbXBvcmFsQWRqdXN0ZXJzO1xufSgpO1xuXG52YXIgSW1wbCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBZGp1c3Rlcikge1xuICBfaW5oZXJpdHNMb29zZShJbXBsLCBfVGVtcG9yYWxBZGp1c3Rlcik7XG5cbiAgZnVuY3Rpb24gSW1wbChvcmRpbmFsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWxBZGp1c3Rlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX29yZGluYWwgPSBvcmRpbmFsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbXBsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX29yZGluYWwpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAxKTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIHRlbXBvcmFsLnJhbmdlKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCkubWF4aW11bSgpKTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIDEpLnBsdXMoMSwgQ2hyb25vVW5pdC5NT05USFMpO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSLCAxKTtcblxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUiwgdGVtcG9yYWwucmFuZ2UoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpLm1heGltdW0oKSk7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX1lFQVIsIDEpLnBsdXMoMSwgQ2hyb25vVW5pdC5ZRUFSUyk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbignVW5yZWFjaGFibGUnKTtcbiAgfTtcblxuICByZXR1cm4gSW1wbDtcbn0oVGVtcG9yYWxBZGp1c3Rlcik7XG5cbkltcGwuRklSU1RfREFZX09GX01PTlRIID0gbmV3IEltcGwoMCk7XG5JbXBsLkxBU1RfREFZX09GX01PTlRIID0gbmV3IEltcGwoMSk7XG5JbXBsLkZJUlNUX0RBWV9PRl9ORVhUX01PTlRIID0gbmV3IEltcGwoMik7XG5JbXBsLkZJUlNUX0RBWV9PRl9ZRUFSID0gbmV3IEltcGwoMyk7XG5JbXBsLkxBU1RfREFZX09GX1lFQVIgPSBuZXcgSW1wbCg0KTtcbkltcGwuRklSU1RfREFZX09GX05FWFRfWUVBUiA9IG5ldyBJbXBsKDUpO1xuXG52YXIgRGF5T2ZXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIChfVGVtcG9yYWxBZGp1c3RlcjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRGF5T2ZXZWVrSW5Nb250aCwgX1RlbXBvcmFsQWRqdXN0ZXIyKTtcblxuICBmdW5jdGlvbiBEYXlPZldlZWtJbk1vbnRoKG9yZGluYWwsIGRvdykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfVGVtcG9yYWxBZGp1c3RlcjIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzMi5fb3JkaW5hbCA9IG9yZGluYWw7XG4gICAgX3RoaXMyLl9kb3dWYWx1ZSA9IGRvdy52YWx1ZSgpO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IERheU9mV2Vla0luTW9udGgucHJvdG90eXBlO1xuXG4gIF9wcm90bzIuYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICBpZiAodGhpcy5fb3JkaW5hbCA+PSAwKSB7XG4gICAgICB2YXIgdGVtcCA9IHRlbXBvcmFsLndpdGgoQ2hyb25vRmllbGQuREFZX09GX01PTlRILCAxKTtcbiAgICAgIHZhciBjdXJEb3cgPSB0ZW1wLmdldChDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyk7XG4gICAgICB2YXIgZG93RGlmZiA9IE1hdGhVdGlsLmludE1vZCh0aGlzLl9kb3dWYWx1ZSAtIGN1ckRvdyArIDcsIDcpO1xuICAgICAgZG93RGlmZiArPSAodGhpcy5fb3JkaW5hbCAtIDEpICogNztcbiAgICAgIHJldHVybiB0ZW1wLnBsdXMoZG93RGlmZiwgQ2hyb25vVW5pdC5EQVlTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90ZW1wID0gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEgsIHRlbXBvcmFsLnJhbmdlKENocm9ub0ZpZWxkLkRBWV9PRl9NT05USCkubWF4aW11bSgpKTtcblxuICAgICAgdmFyIF9jdXJEb3cgPSBfdGVtcC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuXG4gICAgICB2YXIgZGF5c0RpZmYgPSB0aGlzLl9kb3dWYWx1ZSAtIF9jdXJEb3c7XG4gICAgICBkYXlzRGlmZiA9IGRheXNEaWZmID09PSAwID8gMCA6IGRheXNEaWZmID4gMCA/IGRheXNEaWZmIC0gNyA6IGRheXNEaWZmO1xuICAgICAgZGF5c0RpZmYgLT0gKC10aGlzLl9vcmRpbmFsIC0gMSkgKiA3O1xuICAgICAgcmV0dXJuIF90ZW1wLnBsdXMoZGF5c0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBEYXlPZldlZWtJbk1vbnRoO1xufShUZW1wb3JhbEFkanVzdGVyKTtcblxudmFyIFJlbGF0aXZlRGF5T2ZXZWVrID0gZnVuY3Rpb24gKF9UZW1wb3JhbEFkanVzdGVyMykge1xuICBfaW5oZXJpdHNMb29zZShSZWxhdGl2ZURheU9mV2VlaywgX1RlbXBvcmFsQWRqdXN0ZXIzKTtcblxuICBmdW5jdGlvbiBSZWxhdGl2ZURheU9mV2VlayhyZWxhdGl2ZSwgZGF5T2ZXZWVrKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF90aGlzMyA9IF9UZW1wb3JhbEFkanVzdGVyMy5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZXZWVrLCAnZGF5T2ZXZWVrJyk7XG4gICAgX3RoaXMzLl9yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuICAgIF90aGlzMy5fZG93VmFsdWUgPSBkYXlPZldlZWsudmFsdWUoKTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBSZWxhdGl2ZURheU9mV2Vlay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHZhciBjYWxEb3cgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuREFZX09GX1dFRUspO1xuXG4gICAgaWYgKHRoaXMuX3JlbGF0aXZlIDwgMiAmJiBjYWxEb3cgPT09IHRoaXMuX2Rvd1ZhbHVlKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLl9yZWxhdGl2ZSAmIDEpID09PSAwKSB7XG4gICAgICB2YXIgZGF5c0RpZmYgPSBjYWxEb3cgLSB0aGlzLl9kb3dWYWx1ZTtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC5wbHVzKGRheXNEaWZmID49IDAgPyA3IC0gZGF5c0RpZmYgOiAtZGF5c0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfZGF5c0RpZmYgPSB0aGlzLl9kb3dWYWx1ZSAtIGNhbERvdztcblxuICAgICAgcmV0dXJuIHRlbXBvcmFsLm1pbnVzKF9kYXlzRGlmZiA+PSAwID8gNyAtIF9kYXlzRGlmZiA6IC1fZGF5c0RpZmYsIENocm9ub1VuaXQuREFZUyk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWxhdGl2ZURheU9mV2Vlaztcbn0oVGVtcG9yYWxBZGp1c3Rlcik7XG5cbnZhciBJc29DaHJvbm9sb2d5ID0gZnVuY3Rpb24gKF9FbnVtKSB7XG4gIF9pbmhlcml0c0xvb3NlKElzb0Nocm9ub2xvZ3ksIF9FbnVtKTtcblxuICBmdW5jdGlvbiBJc29DaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBfRW51bS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKHByb2xlcHRpY1llYXIpIHtcbiAgICByZXR1cm4gKHByb2xlcHRpY1llYXIgJiAzKSA9PT0gMCAmJiAocHJvbGVwdGljWWVhciAlIDEwMCAhPT0gMCB8fCBwcm9sZXB0aWNZZWFyICUgNDAwID09PSAwKTtcbiAgfTtcblxuICB2YXIgX3Byb3RvID0gSXNvQ2hyb25vbG9neS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl91cGRhdGVSZXNvbHZlTWFwID0gZnVuY3Rpb24gX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIGZpZWxkLCB2YWx1ZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkVmFsdWVzLCAnZmllbGRWYWx1ZXMnKTtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG4gICAgdmFyIGN1cnJlbnQgPSBmaWVsZFZhbHVlcy5nZXQoZmllbGQpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9PSB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCBzdGF0ZSwgZmllbGQ6IFwiICsgZmllbGQgKyBcIiBcIiArIGN1cnJlbnQgKyBcIiBjb25mbGljdHMgd2l0aCBcIiArIGZpZWxkICsgXCIgXCIgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZmllbGRWYWx1ZXMucHV0KGZpZWxkLCB2YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc29sdmVEYXRlID0gZnVuY3Rpb24gcmVzb2x2ZURhdGUoZmllbGRWYWx1ZXMsIHJlc29sdmVyU3R5bGUpIHtcbiAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuRVBPQ0hfREFZKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5FUE9DSF9EQVkpKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbGVwdGljTW9udGggPSBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIKTtcblxuICAgIGlmIChwcm9sZXB0aWNNb250aCAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzb2x2ZXJTdHlsZSAhPT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgIENocm9ub0ZpZWxkLlBST0xFUFRJQ19NT05USC5jaGVja1ZhbGlkVmFsdWUocHJvbGVwdGljTW9udGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLCBNYXRoVXRpbC5mbG9vck1vZChwcm9sZXB0aWNNb250aCwgMTIpICsgMSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVJlc29sdmVNYXAoZmllbGRWYWx1ZXMsIENocm9ub0ZpZWxkLllFQVIsIE1hdGhVdGlsLmZsb29yRGl2KHByb2xlcHRpY01vbnRoLCAxMikpO1xuICAgIH1cblxuICAgIHZhciB5b2VMb25nID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBKTtcblxuICAgIGlmICh5b2VMb25nICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXNvbHZlclN0eWxlICE9PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEuY2hlY2tWYWxpZFZhbHVlKHlvZUxvbmcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJhID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkVSQSk7XG5cbiAgICAgIGlmIChlcmEgPT0gbnVsbCkge1xuICAgICAgICB2YXIgeWVhciA9IGZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5ZRUFSKTtcblxuICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QpIHtcbiAgICAgICAgICBpZiAoeWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCB5ZWFyID4gMCA/IHlvZUxvbmcgOiBNYXRoVXRpbC5zYWZlU3VidHJhY3QoMSwgeW9lTG9uZykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcy5wdXQoQ2hyb25vRmllbGQuWUVBUl9PRl9FUkEsIHlvZUxvbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCB5ZWFyID09IG51bGwgfHwgeWVhciA+IDAgPyB5b2VMb25nIDogTWF0aFV0aWwuc2FmZVN1YnRyYWN0KDEsIHlvZUxvbmcpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlcmEgPT09IDEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVzb2x2ZU1hcChmaWVsZFZhbHVlcywgQ2hyb25vRmllbGQuWUVBUiwgeW9lTG9uZyk7XG4gICAgICB9IGVsc2UgaWYgKGVyYSA9PT0gMCkge1xuICAgICAgICB0aGlzLl91cGRhdGVSZXNvbHZlTWFwKGZpZWxkVmFsdWVzLCBDaHJvbm9GaWVsZC5ZRUFSLCBNYXRoVXRpbC5zYWZlU3VidHJhY3QoMSwgeW9lTG9uZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZSBmb3IgZXJhOiBcIiArIGVyYSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5FUkEpKSB7XG4gICAgICBDaHJvbm9GaWVsZC5FUkEuY2hlY2tWYWxpZFZhbHVlKGZpZWxkVmFsdWVzLmdldChDaHJvbm9GaWVsZC5FUkEpKTtcbiAgICB9XG5cbiAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuWUVBUikpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlcy5jb250YWluc0tleShDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSKSkge1xuICAgICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKSkge1xuICAgICAgICAgIHZhciB5ID0gQ2hyb25vRmllbGQuWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLllFQVIpKTtcbiAgICAgICAgICB2YXIgbW95ID0gZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIpO1xuICAgICAgICAgIHZhciBkb20gPSBmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX01PTlRIKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLkxFTklFTlQpIHtcbiAgICAgICAgICAgIHZhciBtb250aHMgPSBtb3kgLSAxO1xuICAgICAgICAgICAgdmFyIGRheXMgPSBkb20gLSAxO1xuICAgICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZih5LCAxLCAxKS5wbHVzTW9udGhzKG1vbnRocykucGx1c0RheXMoZGF5cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNNQVJUKSB7XG4gICAgICAgICAgICBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEguY2hlY2tWYWxpZFZhbHVlKGRvbSk7XG5cbiAgICAgICAgICAgIGlmIChtb3kgPT09IDQgfHwgbW95ID09PSA2IHx8IG1veSA9PT0gOSB8fCBtb3kgPT09IDExKSB7XG4gICAgICAgICAgICAgIGRvbSA9IE1hdGgubWluKGRvbSwgMzApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb3kgPT09IDIpIHtcbiAgICAgICAgICAgICAgZG9tID0gTWF0aC5taW4oZG9tLCBNb250aC5GRUJSVUFSWS5sZW5ndGgoWWVhci5pc0xlYXAoeSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZih5LCBtb3ksIGRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2YoeSwgbW95LCBkb20pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpKSB7XG4gICAgICAgIHZhciBfeSA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKSk7XG5cbiAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICAgIHZhciBfZGF5cyA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1lFQVIpLCAxKTtcblxuICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2ZZZWFyRGF5KF95LCAxKS5wbHVzRGF5cyhfZGF5cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG95ID0gQ2hyb25vRmllbGQuREFZX09GX1lFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUikpO1xuICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mWWVhckRheShfeSwgZG95KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkVmFsdWVzLmNvbnRhaW5zS2V5KENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKSkge1xuICAgICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSkge1xuICAgICAgICAgIHZhciBfeTIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuWUVBUikpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVyU3R5bGUgPT09IFJlc29sdmVyU3R5bGUuTEVOSUVOVCkge1xuICAgICAgICAgICAgdmFyIHdlZWtzID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUiksIDEpO1xuXG4gICAgICAgICAgICB2YXIgX2RheXMyID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVIpLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZihfeTIsIDEsIDEpLnBsdXNXZWVrcyh3ZWVrcykucGx1c0RheXMoX2RheXMyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYXcgPSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUi5jaGVja1ZhbGlkSW50VmFsdWUoZmllbGRWYWx1ZXMucmVtb3ZlKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKSk7XG4gICAgICAgICAgdmFyIGFkID0gQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSKSk7XG4gICAgICAgICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2YoX3kyLCAxLCAxKS5wbHVzRGF5cygoYXcgLSAxKSAqIDcgKyAoYWQgLSAxKSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5TVFJJQ1QgJiYgZGF0ZS5nZXQoQ2hyb25vRmllbGQuWUVBUikgIT09IF95Mikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdTdHJpY3QgbW9kZSByZWplY3RlZCBkYXRlIHBhcnNlZCB0byBhIGRpZmZlcmVudCB5ZWFyJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmllbGRWYWx1ZXMuY29udGFpbnNLZXkoQ2hyb25vRmllbGQuREFZX09GX1dFRUspKSB7XG4gICAgICAgICAgdmFyIF95MyA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5ZRUFSKSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZXJTdHlsZSA9PT0gUmVzb2x2ZXJTdHlsZS5MRU5JRU5UKSB7XG4gICAgICAgICAgICB2YXIgX3dlZWtzID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUiksIDEpO1xuXG4gICAgICAgICAgICB2YXIgX2RheXMzID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSyksIDEpO1xuXG4gICAgICAgICAgICByZXR1cm4gTG9jYWxEYXRlLm9mKF95MywgMSwgMSkucGx1c1dlZWtzKF93ZWVrcykucGx1c0RheXMoX2RheXMzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2F3ID0gQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVIuY2hlY2tWYWxpZEludFZhbHVlKGZpZWxkVmFsdWVzLnJlbW92ZShDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfWUVBUikpO1xuXG4gICAgICAgICAgdmFyIGRvdyA9IENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLLmNoZWNrVmFsaWRJbnRWYWx1ZShmaWVsZFZhbHVlcy5yZW1vdmUoQ2hyb25vRmllbGQuREFZX09GX1dFRUspKTtcblxuICAgICAgICAgIHZhciBfZGF0ZSA9IExvY2FsRGF0ZS5vZihfeTMsIDEsIDEpLnBsdXNXZWVrcyhfYXcgLSAxKS53aXRoKFRlbXBvcmFsQWRqdXN0ZXJzLm5leHRPclNhbWUoRGF5T2ZXZWVrLm9mKGRvdykpKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlclN0eWxlID09PSBSZXNvbHZlclN0eWxlLlNUUklDVCAmJiBfZGF0ZS5nZXQoQ2hyb25vRmllbGQuWUVBUikgIT09IF95Mykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdTdHJpY3QgbW9kZSByZWplY3RlZCBkYXRlIHBhcnNlZCB0byBhIGRpZmZlcmVudCBtb250aCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5kYXRlID0gZnVuY3Rpb24gZGF0ZSh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gIH07XG5cbiAgcmV0dXJuIElzb0Nocm9ub2xvZ3k7XG59KEVudW0pO1xuZnVuY3Rpb24gX2luaXQkOSgpIHtcbiAgSXNvQ2hyb25vbG9neS5JTlNUQU5DRSA9IG5ldyBJc29DaHJvbm9sb2d5KCdJc29DaHJvbm9sb2d5Jyk7XG59XG5cbnZhciBPZmZzZXRUaW1lID0gZnVuY3Rpb24gKF9UZW1wb3JhbCkge1xuICBfaW5oZXJpdHNMb29zZShPZmZzZXRUaW1lLCBfVGVtcG9yYWwpO1xuXG4gIE9mZnNldFRpbWUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBPZmZzZXRUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIE9mZnNldERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWwudG9PZmZzZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgICAgdmFyIG9mZnNldCA9IFpvbmVPZmZzZXQuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUodGltZSwgb2Zmc2V0KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBPZmZzZXRUaW1lIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIE9mZnNldFRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBPZmZzZXRUaW1lLl9ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICByZXR1cm4gT2Zmc2V0VGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9mZnNldFRpbWUuX25vdyhDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpKTtcbiAgICB9XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5fbm93ID0gZnVuY3Rpb24gX25vdyhjbG9jaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICB2YXIgbm93ID0gY2xvY2suaW5zdGFudCgpO1xuICAgIHJldHVybiBPZmZzZXRUaW1lLm9mSW5zdGFudChub3csIGNsb2NrLnpvbmUoKS5ydWxlcygpLm9mZnNldChub3cpKTtcbiAgfTtcblxuICBPZmZzZXRUaW1lLm9mID0gZnVuY3Rpb24gb2YoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIE9mZnNldFRpbWUub2ZUaW1lQW5kT2Zmc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPZmZzZXRUaW1lLm9mTnVtYmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICBPZmZzZXRUaW1lLm9mTnVtYmVycyA9IGZ1bmN0aW9uIG9mTnVtYmVycyhob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kLCBvZmZzZXQpIHtcbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUodGltZSwgb2Zmc2V0KTtcbiAgfTtcblxuICBPZmZzZXRUaW1lLm9mVGltZUFuZE9mZnNldCA9IGZ1bmN0aW9uIG9mVGltZUFuZE9mZnNldCh0aW1lLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IE9mZnNldFRpbWUodGltZSwgb2Zmc2V0KTtcbiAgfTtcblxuICBPZmZzZXRUaW1lLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudChpbnN0YW50LCB6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoaW5zdGFudCwgJ2luc3RhbnQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoaW5zdGFudCwgSW5zdGFudCwgJ2luc3RhbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh6b25lLCBab25lSWQsICd6b25lJyk7XG4gICAgdmFyIHJ1bGVzID0gem9uZS5ydWxlcygpO1xuICAgIHZhciBvZmZzZXQgPSBydWxlcy5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIHNlY3NPZkRheSA9IGluc3RhbnQuZXBvY2hTZWNvbmQoKSAlIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVk7XG4gICAgc2Vjc09mRGF5ID0gKHNlY3NPZkRheSArIG9mZnNldC50b3RhbFNlY29uZHMoKSkgJSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuXG4gICAgaWYgKHNlY3NPZkRheSA8IDApIHtcbiAgICAgIHNlY3NPZkRheSArPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuICAgIH1cblxuICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkoc2Vjc09mRGF5LCBpbnN0YW50Lm5hbm8oKSk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0VGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX09GRlNFVF9USU1FO1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgT2Zmc2V0VGltZS5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXF1aXJlTm9uTnVsbCh0aW1lLCAndGltZScpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh0aW1lLCBMb2NhbFRpbWUsICd0aW1lJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG9mZnNldCwgWm9uZU9mZnNldCwgJ29mZnNldCcpO1xuICAgIF90aGlzLl90aW1lID0gdGltZTtcbiAgICBfdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPZmZzZXRUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5OQU5PX09GX0RBWSwgdGhpcy5fdGltZS50b05hbm9PZkRheSgpKS53aXRoKENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTLCB0aGlzLm9mZnNldCgpLnRvdGFsU2Vjb25kcygpKTtcbiAgfTtcblxuICBfcHJvdG8uYXREYXRlID0gZnVuY3Rpb24gYXREYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YoZGF0ZSwgdGhpcy5fdGltZSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24gZm9ybWF0KGZvcm1hdHRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMsIE9mZnNldFRpbWUuRlJPTSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5nZXRMb25nKGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuZ2V0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuaG91cigpO1xuICB9O1xuXG4gIF9wcm90by5taW51dGUgPSBmdW5jdGlvbiBtaW51dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUubWludXRlKCk7XG4gIH07XG5cbiAgX3Byb3RvLnNlY29uZCA9IGZ1bmN0aW9uIHNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS5zZWNvbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUubmFubygpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMuX3RvRXBvY2hOYW5vKCkgPiBvdGhlci5fdG9FcG9jaE5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5fdG9FcG9jaE5hbm8oKSA8IG90aGVyLl90b0Vwb2NoTmFubygpO1xuICB9O1xuXG4gIF9wcm90by5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5fdG9FcG9jaE5hbm8oKSA9PT0gb3RoZXIuX3RvRXBvY2hOYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCkgfHwgZmllbGRPclVuaXQgPT09IENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTO1xuICAgIH0gZWxzZSBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNUaW1lQmFzZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRPclVuaXQgIT0gbnVsbCAmJiBmaWVsZE9yVW5pdC5pc1N1cHBvcnRlZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUubWludXNIb3Vycyhob3VycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5taW51c01pbnV0ZXMobWludXRlcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5taW51c1NlY29uZHMoc2Vjb25kcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS5taW51c05hbm9zKG5hbm9zKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uX21pbnVzQW1vdW50ID0gZnVuY3Rpb24gX21pbnVzQW1vdW50KGFtb3VudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudCk7XG4gICAgcmV0dXJuIGFtb3VudC5zdWJ0cmFjdEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9taW51c1VuaXQgPSBmdW5jdGlvbiBfbWludXNVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzKC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLl9wbHVzQW1vdW50ID0gZnVuY3Rpb24gX3BsdXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50KTtcbiAgICByZXR1cm4gYW1vdW50LmFkZFRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1cyhhbW91bnRUb0FkZCwgdW5pdCksIHRoaXMuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzSG91cnMgPSBmdW5jdGlvbiBwbHVzSG91cnMoaG91cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLnBsdXNIb3Vycyhob3VycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNaW51dGVzID0gZnVuY3Rpb24gcGx1c01pbnV0ZXMobWludXRlcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1c01pbnV0ZXMobWludXRlcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNTZWNvbmRzID0gZnVuY3Rpb24gcGx1c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1c1NlY29uZHMoc2Vjb25kcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUucGx1c05hbm9zKG5hbm9zKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5jaHJvbm9sb2d5KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5yYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsVGltZSA9IGZ1bmN0aW9uIHRvTG9jYWxUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lO1xuICB9O1xuXG4gIF9wcm90by50cnVuY2F0ZWRUbyA9IGZ1bmN0aW9uIHRydW5jYXRlZFRvKHVuaXQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLnRydW5jYXRlZFRvKHVuaXQpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgdmFyIGVuZCA9IE9mZnNldFRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgbmFub3NVbnRpbCA9IGVuZC5fdG9FcG9jaE5hbm8oKSAtIHRoaXMuX3RvRXBvY2hOYW5vKCk7XG5cbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIG5hbm9zVW50aWw7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuYW5vc1VudGlsIC8gMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExJUzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuYW5vc1VudGlsIC8gMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobmFub3NVbnRpbCAvIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuYW5vc1VudGlsIC8gTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihuYW5vc1VudGlsIC8gTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG5hbm9zVW50aWwgLyAoMTIgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhIb3VyID0gZnVuY3Rpb24gd2l0aEhvdXIoaG91cikge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aEhvdXIoaG91ciksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNaW51dGUgPSBmdW5jdGlvbiB3aXRoTWludXRlKG1pbnV0ZSkge1xuICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUud2l0aE1pbnV0ZShtaW51dGUpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLndpdGhTZWNvbmQoc2Vjb25kKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS53aXRoTmFubyhuYW5vKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE9mZnNldFNhbWVJbnN0YW50ID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVJbnN0YW50KG9mZnNldCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuXG4gICAgaWYgKG9mZnNldC5lcXVhbHModGhpcy5fb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBvZmZzZXQudG90YWxTZWNvbmRzKCkgLSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCk7XG5cbiAgICB2YXIgYWRqdXN0ZWQgPSB0aGlzLl90aW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKGFkanVzdGVkLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUxvY2FsID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVMb2NhbChvZmZzZXQpIHtcbiAgICByZXR1cm4gb2Zmc2V0ICE9IG51bGwgJiYgb2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpID8gdGhpcyA6IG5ldyBPZmZzZXRUaW1lKHRoaXMuX3RpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLl90b0Vwb2NoTmFubyA9IGZ1bmN0aW9uIF90b0Vwb2NoTmFubygpIHtcbiAgICB2YXIgbm9kID0gdGhpcy5fdGltZS50b05hbm9PZkRheSgpO1xuXG4gICAgdmFyIG9mZnNldE5hbm9zID0gdGhpcy5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIG5vZCAtIG9mZnNldE5hbm9zO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEFkanVzdGVyID0gZnVuY3Rpb24gX3dpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyLCAnYWRqdXN0ZXInKTtcblxuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQoYWRqdXN0ZXIsIHRoaXMuX29mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoTG9jYWxUaW1lT2Zmc2V0KHRoaXMuX3RpbWUsIGFkanVzdGVyKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgT2Zmc2V0VGltZSkge1xuICAgICAgcmV0dXJuIGFkanVzdGVyO1xuICAgIH1cblxuICAgIHJldHVybiBhZGp1c3Rlci5hZGp1c3RJbnRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkID09PSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aExvY2FsVGltZU9mZnNldCh0aGlzLl90aW1lLCBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKGZpZWxkLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhMb2NhbFRpbWVPZmZzZXQodGhpcy5fdGltZS53aXRoKGZpZWxkLCBuZXdWYWx1ZSksIHRoaXMuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aExvY2FsVGltZU9mZnNldCA9IGZ1bmN0aW9uIF93aXRoTG9jYWxUaW1lT2Zmc2V0KHRpbWUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLl90aW1lID09PSB0aW1lICYmIHRoaXMuX29mZnNldC5lcXVhbHMob2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXRUaW1lKHRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIE9mZnNldFRpbWUsICdvdGhlcicpO1xuXG4gICAgaWYgKHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lLmNvbXBhcmVUbyhvdGhlci5fdGltZSk7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBhcmUgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLl90b0Vwb2NoTmFubygpLCBvdGhlci5fdG9FcG9jaE5hbm8oKSk7XG5cbiAgICBpZiAoY29tcGFyZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWUuY29tcGFyZVRvKG90aGVyLl90aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGFyZTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBPZmZzZXRUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGltZS5lcXVhbHMob3RoZXIuX3RpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhhc2hDb2RlKCkgXiB0aGlzLl9vZmZzZXQuaGFzaENvZGUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZS50b1N0cmluZygpICsgdGhpcy5fb2Zmc2V0LnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIHJldHVybiBPZmZzZXRUaW1lO1xufShUZW1wb3JhbCk7XG5mdW5jdGlvbiBfaW5pdCQ4KCkge1xuICBPZmZzZXRUaW1lLk1JTiA9IE9mZnNldFRpbWUub2ZOdW1iZXJzKDAsIDAsIDAsIDAsIFpvbmVPZmZzZXQuTUFYKTtcbiAgT2Zmc2V0VGltZS5NQVggPSBPZmZzZXRUaW1lLm9mTnVtYmVycygyMywgNTksIDU5LCA5OTk5OTk5OTksIFpvbmVPZmZzZXQuTUlOKTtcbiAgT2Zmc2V0VGltZS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnT2Zmc2V0VGltZS5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIE9mZnNldFRpbWUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgQ2hyb25vWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vWm9uZWREYXRlVGltZSwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBDaHJvbm9ab25lZERhdGVUaW1lKCkge1xuICAgIHJldHVybiBfVGVtcG9yYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub1pvbmVkRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGUoKS5jaHJvbm9sb2d5KCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCkpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxUaW1lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSW5zdGFudCA9IGZ1bmN0aW9uIHRvSW5zdGFudCgpIHtcbiAgICByZXR1cm4gSW5zdGFudC5vZkVwb2NoU2Vjb25kKHRoaXMudG9FcG9jaFNlY29uZCgpLCB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQoKSB7XG4gICAgdmFyIGVwb2NoRGF5ID0gdGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKTtcbiAgICB2YXIgc2VjcyA9IGVwb2NoRGF5ICogODY0MDAgKyB0aGlzLnRvTG9jYWxUaW1lKCkudG9TZWNvbmRPZkRheSgpO1xuICAgIHNlY3MgLT0gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICByZXR1cm4gc2VjcztcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHZhciBjbXAgPSBNYXRoVXRpbC5jb21wYXJlTnVtYmVycyh0aGlzLnRvRXBvY2hTZWNvbmQoKSwgb3RoZXIudG9FcG9jaFNlY29uZCgpKTtcblxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgLSBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcblxuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBjbXAgPSB0aGlzLnRvTG9jYWxEYXRlVGltZSgpLmNvbXBhcmVUbyhvdGhlci50b0xvY2FsRGF0ZVRpbWUoKSk7XG5cbiAgICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgIGNtcCA9IHN0cmNtcCh0aGlzLnpvbmUoKS5pZCgpLCBvdGhlci56b25lKCkuaWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgdGhpc0Vwb2NoU2VjID0gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgdmFyIG90aGVyRXBvY2hTZWMgPSBvdGhlci50b0Vwb2NoU2Vjb25kKCk7XG4gICAgcmV0dXJuIHRoaXNFcG9jaFNlYyA+IG90aGVyRXBvY2hTZWMgfHwgdGhpc0Vwb2NoU2VjID09PSBvdGhlckVwb2NoU2VjICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPiBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICB2YXIgdGhpc0Vwb2NoU2VjID0gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG4gICAgdmFyIG90aGVyRXBvY2hTZWMgPSBvdGhlci50b0Vwb2NoU2Vjb25kKCk7XG4gICAgcmV0dXJuIHRoaXNFcG9jaFNlYyA8IG90aGVyRXBvY2hTZWMgfHwgdGhpc0Vwb2NoU2VjID09PSBvdGhlckVwb2NoU2VjICYmIHRoaXMudG9Mb2NhbFRpbWUoKS5uYW5vKCkgPCBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmV0dXJuIHRoaXMudG9FcG9jaFNlY29uZCgpID09PSBvdGhlci50b0Vwb2NoU2Vjb25kKCkgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA9PT0gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hyb25vWm9uZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIENocm9ub1pvbmVkRGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcblxuZnVuY3Rpb24gc3RyY21wKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxudmFyIFpvbmVkRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0Nocm9ub1pvbmVkRGF0ZVRpbWUpIHtcbiAgX2luaGVyaXRzTG9vc2UoWm9uZWREYXRlVGltZSwgX0Nocm9ub1pvbmVkRGF0ZVRpbWUpO1xuXG4gIFpvbmVkRGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgdmFyIGNsb2NrO1xuXG4gICAgaWYgKGNsb2NrT3Jab25lIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICBjbG9jayA9IENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb2NrID0gY2xvY2tPclpvbmUgPT0gbnVsbCA/IENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkgOiBjbG9ja09yWm9uZTtcbiAgICB9XG5cbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUub2Y4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUub2YzID0gZnVuY3Rpb24gb2YzKGRhdGUsIHRpbWUsIHpvbmUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZjIoTG9jYWxEYXRlVGltZS5vZihkYXRlLCB0aW1lKSwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZjIgPSBmdW5jdGlvbiBvZjIobG9jYWxEYXRlVGltZSwgem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mTG9jYWwobG9jYWxEYXRlVGltZSwgem9uZSwgbnVsbCk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZjggPSBmdW5jdGlvbiBvZjgoeWVhciwgbW9udGgsIGRheU9mTW9udGgsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQsIHpvbmUpIHtcbiAgICB2YXIgZHQgPSBMb2NhbERhdGVUaW1lLm9mKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkxvY2FsKGR0LCB6b25lLCBudWxsKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mTG9jYWwgPSBmdW5jdGlvbiBvZkxvY2FsKGxvY2FsRGF0ZVRpbWUsIHpvbmUsIHByZWZlcnJlZE9mZnNldCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGxvY2FsRGF0ZVRpbWUsICdsb2NhbERhdGVUaW1lJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcblxuICAgIGlmICh6b25lIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgcmV0dXJuIG5ldyBab25lZERhdGVUaW1lKGxvY2FsRGF0ZVRpbWUsIHpvbmUsIHpvbmUpO1xuICAgIH1cblxuICAgIHZhciBvZmZzZXQgPSBudWxsO1xuICAgIHZhciBydWxlcyA9IHpvbmUucnVsZXMoKTtcbiAgICB2YXIgdmFsaWRPZmZzZXRzID0gcnVsZXMudmFsaWRPZmZzZXRzKGxvY2FsRGF0ZVRpbWUpO1xuXG4gICAgaWYgKHZhbGlkT2Zmc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IHZhbGlkT2Zmc2V0c1swXTtcbiAgICB9IGVsc2UgaWYgKHZhbGlkT2Zmc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciB0cmFucyA9IHJ1bGVzLnRyYW5zaXRpb24obG9jYWxEYXRlVGltZSk7XG4gICAgICBsb2NhbERhdGVUaW1lID0gbG9jYWxEYXRlVGltZS5wbHVzU2Vjb25kcyh0cmFucy5kdXJhdGlvbigpLnNlY29uZHMoKSk7XG4gICAgICBvZmZzZXQgPSB0cmFucy5vZmZzZXRBZnRlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJlZmVycmVkT2Zmc2V0ICE9IG51bGwgJiYgdmFsaWRPZmZzZXRzLnNvbWUoZnVuY3Rpb24gKHZhbGlkT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZE9mZnNldC5lcXVhbHMocHJlZmVycmVkT2Zmc2V0KTtcbiAgICAgIH0pKSB7XG4gICAgICAgIG9mZnNldCA9IHByZWZlcnJlZE9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IHJlcXVpcmVOb25OdWxsKHZhbGlkT2Zmc2V0c1swXSwgJ29mZnNldCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZShsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mSW5zdGFudDMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZkluc3RhbnQyID0gZnVuY3Rpb24gb2ZJbnN0YW50MihpbnN0YW50LCB6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoaW5zdGFudCwgJ2luc3RhbnQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUoaW5zdGFudC5lcG9jaFNlY29uZCgpLCBpbnN0YW50Lm5hbm8oKSwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5vZkluc3RhbnQzID0gZnVuY3Rpb24gb2ZJbnN0YW50Myhsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChsb2NhbERhdGVUaW1lLCAnbG9jYWxEYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgcmV0dXJuIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZShsb2NhbERhdGVUaW1lLnRvRXBvY2hTZWNvbmQob2Zmc2V0KSwgbG9jYWxEYXRlVGltZS5uYW5vKCksIHpvbmUpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUuX2NyZWF0ZSA9IGZ1bmN0aW9uIF9jcmVhdGUoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgem9uZSkge1xuICAgIHZhciBydWxlcyA9IHpvbmUucnVsZXMoKTtcbiAgICB2YXIgaW5zdGFudCA9IEluc3RhbnQub2ZFcG9jaFNlY29uZChlcG9jaFNlY29uZCwgbmFub09mU2Vjb25kKTtcbiAgICB2YXIgb2Zmc2V0ID0gcnVsZXMub2Zmc2V0KGluc3RhbnQpO1xuICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLm9mRXBvY2hTZWNvbmQoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobGR0LCBvZmZzZXQsIHpvbmUpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUub2ZTdHJpY3QgPSBmdW5jdGlvbiBvZlN0cmljdChsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChsb2NhbERhdGVUaW1lLCAnbG9jYWxEYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIHJ1bGVzID0gem9uZS5ydWxlcygpO1xuXG4gICAgaWYgKHJ1bGVzLmlzVmFsaWRPZmZzZXQobG9jYWxEYXRlVGltZSwgb2Zmc2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciB0cmFucyA9IHJ1bGVzLnRyYW5zaXRpb24obG9jYWxEYXRlVGltZSk7XG5cbiAgICAgIGlmICh0cmFucyAhPSBudWxsICYmIHRyYW5zLmlzR2FwKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiTG9jYWxEYXRlVGltZSBcIiArIGxvY2FsRGF0ZVRpbWUgKyBcIiBkb2VzIG5vdCBleGlzdCBpbiB6b25lIFwiICsgem9uZSArIFwiIGR1ZSB0byBhIGdhcCBpbiB0aGUgbG9jYWwgdGltZS1saW5lLCB0eXBpY2FsbHkgY2F1c2VkIGJ5IGRheWxpZ2h0IHNhdmluZ3NcIik7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlpvbmVPZmZzZXQgXFxcIlwiICsgb2Zmc2V0ICsgXCJcXFwiIGlzIG5vdCB2YWxpZCBmb3IgTG9jYWxEYXRlVGltZSBcXFwiXCIgKyBsb2NhbERhdGVUaW1lICsgXCJcXFwiIGluIHpvbmUgXFxcIlwiICsgem9uZSArIFwiXFxcIlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLm9mTGVuaWVudCA9IGZ1bmN0aW9uIG9mTGVuaWVudChsb2NhbERhdGVUaW1lLCBvZmZzZXQsIHpvbmUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChsb2NhbERhdGVUaW1lLCAnbG9jYWxEYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG5cbiAgICBpZiAoem9uZSBpbnN0YW5jZW9mIFpvbmVPZmZzZXQgJiYgb2Zmc2V0LmVxdWFscyh6b25lKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1pvbmVJZCBtdXN0IG1hdGNoIFpvbmVPZmZzZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUobG9jYWxEYXRlVGltZSwgb2Zmc2V0LCB6b25lKTtcbiAgfTtcblxuICBab25lZERhdGVUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuXG4gICAgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRlbXBvcmFsO1xuICAgIH1cblxuICAgIHZhciB6b25lID0gWm9uZUlkLmZyb20odGVtcG9yYWwpO1xuXG4gICAgaWYgKHRlbXBvcmFsLmlzU3VwcG9ydGVkKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUykpIHtcbiAgICAgIHZhciB6ZHQgPSBab25lZERhdGVUaW1lLl9mcm9tKHRlbXBvcmFsLCB6b25lKTtcblxuICAgICAgaWYgKHpkdCAhPSBudWxsKSByZXR1cm4gemR0O1xuICAgIH1cblxuICAgIHZhciBsZHQgPSBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mMihsZHQsIHpvbmUpO1xuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUuX2Zyb20gPSBmdW5jdGlvbiBfZnJvbSh0ZW1wb3JhbCwgem9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gWm9uZWREYXRlVGltZS5fX2Zyb20odGVtcG9yYWwsIHpvbmUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoIShleCBpbnN0YW5jZW9mIERhdGVUaW1lRXhjZXB0aW9uKSkgdGhyb3cgZXg7XG4gICAgfVxuICB9O1xuXG4gIFpvbmVkRGF0ZVRpbWUuX19mcm9tID0gZnVuY3Rpb24gX19mcm9tKHRlbXBvcmFsLCB6b25lKSB7XG4gICAgdmFyIGVwb2NoU2Vjb25kID0gdGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFMpO1xuICAgIHZhciBuYW5vT2ZTZWNvbmQgPSB0ZW1wb3JhbC5nZXQoQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQpO1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgem9uZSk7XG4gIH07XG5cbiAgWm9uZWREYXRlVGltZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX1pPTkVEX0RBVEVfVElNRTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIFpvbmVkRGF0ZVRpbWUuRlJPTSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gWm9uZWREYXRlVGltZShkYXRlVGltZSwgb2Zmc2V0LCB6b25lKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgcmVxdWlyZU5vbk51bGwoZGF0ZVRpbWUsICdkYXRlVGltZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgX3RoaXMgPSBfQ2hyb25vWm9uZWREYXRlVGltZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2RhdGVUaW1lID0gZGF0ZVRpbWU7XG4gICAgX3RoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICBfdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFpvbmVkRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5fcmVzb2x2ZUxvY2FsID0gZnVuY3Rpb24gX3Jlc29sdmVMb2NhbChuZXdEYXRlVGltZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKG5ld0RhdGVUaW1lLCAnbmV3RGF0ZVRpbWUnKTtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkxvY2FsKG5ld0RhdGVUaW1lLCB0aGlzLl96b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5fcmVzb2x2ZUluc3RhbnQgPSBmdW5jdGlvbiBfcmVzb2x2ZUluc3RhbnQobmV3RGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkluc3RhbnQzKG5ld0RhdGVUaW1lLCB0aGlzLl9vZmZzZXQsIHRoaXMuX3pvbmUpO1xuICB9O1xuXG4gIF9wcm90by5fcmVzb2x2ZU9mZnNldCA9IGZ1bmN0aW9uIF9yZXNvbHZlT2Zmc2V0KG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlICYmIHRoaXMuX3pvbmUucnVsZXMoKS5pc1ZhbGlkT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5fZGF0ZVRpbWUsIG9mZnNldCwgdGhpcy5fem9uZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEVhcmxpZXJPZmZzZXRBdE92ZXJsYXAgPSBmdW5jdGlvbiB3aXRoRWFybGllck9mZnNldEF0T3ZlcmxhcCgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl96b25lLnJ1bGVzKCkudHJhbnNpdGlvbih0aGlzLl9kYXRlVGltZSk7XG5cbiAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc092ZXJsYXAoKSkge1xuICAgICAgdmFyIGVhcmxpZXJPZmZzZXQgPSB0cmFucy5vZmZzZXRCZWZvcmUoKTtcblxuICAgICAgaWYgKGVhcmxpZXJPZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLl9kYXRlVGltZSwgZWFybGllck9mZnNldCwgdGhpcy5fem9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCA9IGZ1bmN0aW9uIHdpdGhMYXRlck9mZnNldEF0T3ZlcmxhcCgpIHtcbiAgICB2YXIgdHJhbnMgPSB0aGlzLl96b25lLnJ1bGVzKCkudHJhbnNpdGlvbih0aGlzLnRvTG9jYWxEYXRlVGltZSgpKTtcblxuICAgIGlmICh0cmFucyAhPSBudWxsKSB7XG4gICAgICB2YXIgbGF0ZXJPZmZzZXQgPSB0cmFucy5vZmZzZXRBZnRlcigpO1xuXG4gICAgICBpZiAobGF0ZXJPZmZzZXQuZXF1YWxzKHRoaXMuX29mZnNldCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZWREYXRlVGltZSh0aGlzLl9kYXRlVGltZSwgbGF0ZXJPZmZzZXQsIHRoaXMuX3pvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFpvbmVTYW1lTG9jYWwgPSBmdW5jdGlvbiB3aXRoWm9uZVNhbWVMb2NhbCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMoem9uZSkgPyB0aGlzIDogWm9uZWREYXRlVGltZS5vZkxvY2FsKHRoaXMuX2RhdGVUaW1lLCB6b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWm9uZVNhbWVJbnN0YW50ID0gZnVuY3Rpb24gd2l0aFpvbmVTYW1lSW5zdGFudCh6b25lKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMoem9uZSkgPyB0aGlzIDogWm9uZWREYXRlVGltZS5fY3JlYXRlKHRoaXMuX2RhdGVUaW1lLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0KSwgdGhpcy5fZGF0ZVRpbWUubmFubygpLCB6b25lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aEZpeGVkT2Zmc2V0Wm9uZSA9IGZ1bmN0aW9uIHdpdGhGaXhlZE9mZnNldFpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3pvbmUuZXF1YWxzKHRoaXMuX29mZnNldCkgPyB0aGlzIDogbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5fZGF0ZVRpbWUsIHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoVmFsdWUoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZlllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZldlZWsoKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5taW51dGUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5zZWNvbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIF93aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwoTG9jYWxEYXRlVGltZS5vZihhZGp1c3RlciwgdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbFRpbWUoKSkpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwoTG9jYWxEYXRlVGltZS5vZih0aGlzLl9kYXRlVGltZS50b0xvY2FsRGF0ZSgpLCBhZGp1c3RlcikpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKGFkanVzdGVyKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgSW5zdGFudCkge1xuICAgICAgdmFyIGluc3RhbnQgPSBhZGp1c3RlcjtcbiAgICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUoaW5zdGFudC5lcG9jaFNlY29uZCgpLCBpbnN0YW50Lm5hbm8oKSwgdGhpcy5fem9uZSk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlT2Zmc2V0KGFkanVzdGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0Nocm9ub1pvbmVkRGF0ZVRpbWUucHJvdG90eXBlLl93aXRoQWRqdXN0ZXIuY2FsbCh0aGlzLCBhZGp1c3Rlcik7XG4gIH07XG5cbiAgX3Byb3RvLl93aXRoRmllbGQgPSBmdW5jdGlvbiBfd2l0aEZpZWxkKGZpZWxkLCBuZXdWYWx1ZSkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiBab25lZERhdGVUaW1lLl9jcmVhdGUobmV3VmFsdWUsIHRoaXMubmFubygpLCB0aGlzLl96b25lKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk9GRlNFVF9TRUNPTkRTOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKGZpZWxkLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aChmaWVsZCwgbmV3VmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUud2l0aFllYXIoeWVhcikpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhNb250aChtb250aCkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikpO1xuICB9O1xuXG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhIb3VyKGhvdXIpKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE1pbnV0ZSA9IGZ1bmN0aW9uIHdpdGhNaW51dGUobWludXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoTWludXRlKG1pbnV0ZSkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLndpdGhTZWNvbmQoc2Vjb25kKSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpKTtcbiAgfTtcblxuICBfcHJvdG8udHJ1bmNhdGVkVG8gPSBmdW5jdGlvbiB0cnVuY2F0ZWRUbyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS50cnVuY2F0ZWRUbyh1bml0KSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgaWYgKHVuaXQuaXNEYXRlQmFzZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUxvY2FsKHRoaXMuX2RhdGVUaW1lLnBsdXMoYW1vdW50VG9BZGQsIHVuaXQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzKGFtb3VudFRvQWRkLCB1bml0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c1llYXJzKHllYXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlTG9jYWwodGhpcy5fZGF0ZVRpbWUucGx1c01vbnRocyhtb250aHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1dlZWtzID0gZnVuY3Rpb24gcGx1c1dlZWtzKHdlZWtzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS5wbHVzV2Vla3Mod2Vla3MpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVMb2NhbCh0aGlzLl9kYXRlVGltZS5wbHVzRGF5cyhkYXlzKSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlSW5zdGFudCh0aGlzLl9kYXRlVGltZS5wbHVzSG91cnMoaG91cnMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNNaW51dGVzKG1pbnV0ZXMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKHNlY29uZHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVJbnN0YW50KHRoaXMuX2RhdGVUaW1lLnBsdXNOYW5vcyhuYW5vcykpO1xuICB9O1xuXG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKC0xICogeWVhcnMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoLTEgKiBtb250aHMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcygtMSAqIHdlZWtzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cygtMSAqIGRheXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIGhvdXJzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNNaW51dGVzID0gZnVuY3Rpb24gbWludXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcygtMSAqIG1pbnV0ZXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1NlY29uZHMgPSBmdW5jdGlvbiBtaW51c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKC0xICogc2Vjb25kcyk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKC0xICogbmFub3MpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGUoKTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuICAgIHJldHVybiBfQ2hyb25vWm9uZWREYXRlVGltZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBab25lZERhdGVUaW1lLmZyb20oZW5kRXhjbHVzaXZlKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgZW5kID0gZW5kLndpdGhab25lU2FtZUluc3RhbnQodGhpcy5fem9uZSk7XG5cbiAgICAgIGlmICh1bml0LmlzRGF0ZUJhc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnVudGlsKGVuZC5fZGF0ZVRpbWUsIHVuaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSB0aGlzLl9vZmZzZXQudG90YWxTZWNvbmRzKCkgLSBlbmQuX29mZnNldC50b3RhbFNlY29uZHMoKTtcblxuICAgICAgICB2YXIgYWRqdXN0ZWRFbmQgPSBlbmQuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS51bnRpbChhZGp1c3RlZEVuZCwgdW5pdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIHRvTG9jYWxEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0xvY2FsRGF0ZSgpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsVGltZSA9IGZ1bmN0aW9uIHRvTG9jYWxUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0xvY2FsVGltZSgpO1xuICB9O1xuXG4gIF9wcm90by50b09mZnNldERhdGVUaW1lID0gZnVuY3Rpb24gdG9PZmZzZXREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YodGhpcy5fZGF0ZVRpbWUsIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmVxdWFscyhvdGhlci5fZGF0ZVRpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCkgJiYgdGhpcy5fem9uZS5lcXVhbHMob3RoZXIuX3pvbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gTWF0aFV0aWwuaGFzaENvZGUodGhpcy5fZGF0ZVRpbWUuaGFzaENvZGUoKSwgdGhpcy5fb2Zmc2V0Lmhhc2hDb2RlKCksIHRoaXMuX3pvbmUuaGFzaENvZGUoKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHN0ciA9IHRoaXMuX2RhdGVUaW1lLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLl9vZmZzZXQgIT09IHRoaXMuX3pvbmUpIHtcbiAgICAgIHN0ciArPSBcIltcIiArIHRoaXMuX3pvbmUudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmV0dXJuIF9DaHJvbm9ab25lZERhdGVUaW1lLnByb3RvdHlwZS5mb3JtYXQuY2FsbCh0aGlzLCBmb3JtYXR0ZXIpO1xuICB9O1xuXG4gIHJldHVybiBab25lZERhdGVUaW1lO1xufShDaHJvbm9ab25lZERhdGVUaW1lKTtcbmZ1bmN0aW9uIF9pbml0JDcoKSB7XG4gIFpvbmVkRGF0ZVRpbWUuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ1pvbmVkRGF0ZVRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIE9mZnNldERhdGVUaW1lID0gZnVuY3Rpb24gKF9UZW1wb3JhbCkge1xuICBfaW5oZXJpdHNMb29zZShPZmZzZXREYXRlVGltZSwgX1RlbXBvcmFsKTtcblxuICBPZmZzZXREYXRlVGltZS5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHRlbXBvcmFsLCAndGVtcG9yYWwnKTtcblxuICAgIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIE9mZnNldERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0LmZyb20odGVtcG9yYWwpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGR0ID0gTG9jYWxEYXRlVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mKGxkdCwgb2Zmc2V0KTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgdmFyIGluc3RhbnQgPSBJbnN0YW50LmZyb20odGVtcG9yYWwpO1xuICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KGluc3RhbnQsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gT2Zmc2V0RGF0ZVRpbWUgVGVtcG9yYWxBY2Nlc3NvcjogXCIgKyB0ZW1wb3JhbCArIFwiLCB0eXBlIFwiICsgKHRlbXBvcmFsLmNvbnN0cnVjdG9yICE9IG51bGwgPyB0ZW1wb3JhbC5jb25zdHJ1Y3Rvci5uYW1lIDogJycpKTtcbiAgICB9XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrT3Jab25lLCAnY2xvY2tPclpvbmUnKTtcblxuICAgICAgaWYgKGNsb2NrT3Jab25lIGluc3RhbmNlb2YgWm9uZUlkKSB7XG4gICAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5ub3coQ2xvY2suc3lzdGVtKGNsb2NrT3Jab25lKSk7XG4gICAgICB9IGVsc2UgaWYgKGNsb2NrT3Jab25lIGluc3RhbmNlb2YgQ2xvY2spIHtcbiAgICAgICAgdmFyIG5vdyA9IGNsb2NrT3Jab25lLmluc3RhbnQoKTtcbiAgICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mSW5zdGFudChub3csIGNsb2NrT3Jab25lLnpvbmUoKS5ydWxlcygpLm9mZnNldChub3cpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2Nsb2NrT3Jab25lIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgWm9uZUlkIG9yIENsb2NrJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9mZnNldERhdGVUaW1lLm9mID0gZnVuY3Rpb24gb2YoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikge1xuICAgICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mRGF0ZVRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkRhdGVBbmRUaW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZk51bWJlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUub2ZEYXRlVGltZSA9IGZ1bmN0aW9uIG9mRGF0ZVRpbWUoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgT2Zmc2V0RGF0ZVRpbWUoZGF0ZVRpbWUsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUub2ZEYXRlQW5kVGltZSA9IGZ1bmN0aW9uIG9mRGF0ZUFuZFRpbWUoZGF0ZSwgdGltZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGR0ID0gTG9jYWxEYXRlVGltZS5vZihkYXRlLCB0aW1lKTtcbiAgICByZXR1cm4gbmV3IE9mZnNldERhdGVUaW1lKGR0LCBvZmZzZXQpO1xuICB9O1xuXG4gIE9mZnNldERhdGVUaW1lLm9mTnVtYmVycyA9IGZ1bmN0aW9uIG9mTnVtYmVycyh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCwgb2Zmc2V0KSB7XG4gICAgaWYgKGhvdXIgPT09IHZvaWQgMCkge1xuICAgICAgaG91ciA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGR0ID0gTG9jYWxEYXRlVGltZS5vZih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShkdCwgb2Zmc2V0KTtcbiAgfTtcblxuICBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQgPSBmdW5jdGlvbiBvZkluc3RhbnQoaW5zdGFudCwgem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKGluc3RhbnQsICdpbnN0YW50Jyk7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZSwgJ3pvbmUnKTtcbiAgICB2YXIgcnVsZXMgPSB6b25lLnJ1bGVzKCk7XG4gICAgdmFyIG9mZnNldCA9IHJ1bGVzLm9mZnNldChpbnN0YW50KTtcbiAgICB2YXIgbGR0ID0gTG9jYWxEYXRlVGltZS5vZkVwb2NoU2Vjb25kKGluc3RhbnQuZXBvY2hTZWNvbmQoKSwgaW5zdGFudC5uYW5vKCksIG9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShsZHQsIG9mZnNldCk7XG4gIH07XG5cbiAgT2Zmc2V0RGF0ZVRpbWUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICBpZiAoZm9ybWF0dGVyID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdHRlciA9IERhdGVUaW1lRm9ybWF0dGVyLklTT19PRkZTRVRfREFURV9USU1FO1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgT2Zmc2V0RGF0ZVRpbWUuRlJPTSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gT2Zmc2V0RGF0ZVRpbWUoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICByZXF1aXJlTm9uTnVsbChkYXRlVGltZSwgJ2RhdGVUaW1lJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKGRhdGVUaW1lLCBMb2NhbERhdGVUaW1lLCAnZGF0ZVRpbWUnKTtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob2Zmc2V0LCBab25lT2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgX3RoaXMuX2RhdGVUaW1lID0gZGF0ZVRpbWU7XG4gICAgX3RoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gT2Zmc2V0RGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLkVQT0NIX0RBWSwgdGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKSkud2l0aChDaHJvbm9GaWVsZC5OQU5PX09GX0RBWSwgdGhpcy50b0xvY2FsVGltZSgpLnRvTmFub09mRGF5KCkpLndpdGgoQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMsIHRoaXMub2Zmc2V0KCkudG90YWxTZWNvbmRzKCkpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBPZmZzZXREYXRlVGltZS5mcm9tKGVuZEV4Y2x1c2l2ZSk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIGVuZCA9IGVuZC53aXRoT2Zmc2V0U2FtZUluc3RhbnQodGhpcy5fb2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS51bnRpbChlbmQuX2RhdGVUaW1lLCB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5iZXR3ZWVuKHRoaXMsIGVuZCk7XG4gIH07XG5cbiAgX3Byb3RvLmF0Wm9uZVNhbWVJbnN0YW50ID0gZnVuY3Rpb24gYXRab25lU2FtZUluc3RhbnQoem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mSW5zdGFudCh0aGlzLl9kYXRlVGltZSwgdGhpcy5fb2Zmc2V0LCB6b25lKTtcbiAgfTtcblxuICBfcHJvdG8uYXRab25lU2ltaWxhckxvY2FsID0gZnVuY3Rpb24gYXRab25lU2ltaWxhckxvY2FsKHpvbmUpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZkxvY2FsKHRoaXMuX2RhdGVUaW1lLCB6b25lLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gSXNvQ2hyb25vbG9neS5JTlNUQU5DRTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLm9mZnNldCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGUoKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0xvY2FsVGltZSgpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFM6XG4gICAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiRmllbGQgdG9vIGxhcmdlIGZvciBhbiBpbnQ6IFwiICsgZmllbGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCkudG90YWxTZWNvbmRzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5nZXQoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKS50b3RhbFNlY29uZHMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmdldExvbmcoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgfTtcblxuICBfcHJvdG8ueWVhciA9IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm1vbnRoVmFsdWUoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGggPSBmdW5jdGlvbiBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUubW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZNb250aCA9IGZ1bmN0aW9uIGRheU9mTW9udGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZlllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZXZWVrID0gZnVuY3Rpb24gZGF5T2ZXZWVrKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5kYXlPZldlZWsoKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5taW51dGUoKTtcbiAgfTtcblxuICBfcHJvdG8uc2Vjb25kID0gZnVuY3Rpb24gc2Vjb25kKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5zZWNvbmQoKTtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbERhdGVUaW1lID0gZnVuY3Rpb24gdG9Mb2NhbERhdGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbERhdGUgPSBmdW5jdGlvbiB0b0xvY2FsRGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbERhdGUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9Mb2NhbFRpbWUgPSBmdW5jdGlvbiB0b0xvY2FsVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZVRpbWUudG9Mb2NhbFRpbWUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9PZmZzZXRUaW1lID0gZnVuY3Rpb24gdG9PZmZzZXRUaW1lKCkge1xuICAgIHJldHVybiBPZmZzZXRUaW1lLm9mKHRoaXMuX2RhdGVUaW1lLnRvTG9jYWxUaW1lKCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uIHRvWm9uZWREYXRlVGltZSgpIHtcbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZih0aGlzLl9kYXRlVGltZSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udG9JbnN0YW50ID0gZnVuY3Rpb24gdG9JbnN0YW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS50b0luc3RhbnQodGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvRXBvY2hTZWNvbmQodGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQuaXNEYXRlQmFzZWQoKSB8fCBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cblxuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICBpZiAoZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLnJhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEFkanVzdGVyID0gZnVuY3Rpb24gX3dpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyKTtcblxuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSB8fCBhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsVGltZSB8fCBhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aChhZGp1c3RlciksIHRoaXMuX29mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIEluc3RhbnQpIHtcbiAgICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZkluc3RhbnQoYWRqdXN0ZXIsIHRoaXMuX29mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUsIGFkanVzdGVyKTtcbiAgICB9IGVsc2UgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgT2Zmc2V0RGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiBhZGp1c3RlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRqdXN0ZXIuYWRqdXN0SW50byh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG5cbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2ZJbnN0YW50KEluc3RhbnQub2ZFcG9jaFNlY29uZChuZXdWYWx1ZSwgdGhpcy5uYW5vKCkpLCB0aGlzLl9vZmZzZXQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuT0ZGU0VUX1NFQ09ORFM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZSwgWm9uZU9mZnNldC5vZlRvdGFsU2Vjb25kcyhmLmNoZWNrVmFsaWRJbnRWYWx1ZShuZXdWYWx1ZSkpKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aChmaWVsZCwgbmV3VmFsdWUpLCB0aGlzLl9vZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5hZGp1c3RJbnRvKHRoaXMsIG5ld1ZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhEYXRlVGltZU9mZnNldCA9IGZ1bmN0aW9uIF93aXRoRGF0ZVRpbWVPZmZzZXQoZGF0ZVRpbWUsIG9mZnNldCkge1xuICAgIGlmICh0aGlzLl9kYXRlVGltZSA9PT0gZGF0ZVRpbWUgJiYgdGhpcy5fb2Zmc2V0LmVxdWFscyhvZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9mZnNldERhdGVUaW1lKGRhdGVUaW1lLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoWWVhciA9IGZ1bmN0aW9uIHdpdGhZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhZZWFyKHllYXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTW9udGggPSBmdW5jdGlvbiB3aXRoTW9udGgobW9udGgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhNb250aChtb250aCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEYXlPZk1vbnRoID0gZnVuY3Rpb24gd2l0aERheU9mTW9udGgoZGF5T2ZNb250aCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aERheU9mTW9udGgoZGF5T2ZNb250aCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhEYXlPZlllYXIgPSBmdW5jdGlvbiB3aXRoRGF5T2ZZZWFyKGRheU9mWWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUud2l0aERheU9mWWVhcihkYXlPZlllYXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhIb3VyKGhvdXIpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLndpdGhNaW51dGUobWludXRlKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFNlY29uZCA9IGZ1bmN0aW9uIHdpdGhTZWNvbmQoc2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoU2Vjb25kKHNlY29uZCksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhOYW5vID0gZnVuY3Rpb24gd2l0aE5hbm8obmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS53aXRoTmFubyhuYW5vT2ZTZWNvbmQpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUxvY2FsID0gZnVuY3Rpb24gd2l0aE9mZnNldFNhbWVMb2NhbChvZmZzZXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by53aXRoT2Zmc2V0U2FtZUluc3RhbnQgPSBmdW5jdGlvbiB3aXRoT2Zmc2V0U2FtZUluc3RhbnQob2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG5cbiAgICBpZiAob2Zmc2V0LmVxdWFscyh0aGlzLl9vZmZzZXQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW5jZSA9IG9mZnNldC50b3RhbFNlY29uZHMoKSAtIHRoaXMuX29mZnNldC50b3RhbFNlY29uZHMoKTtcblxuICAgIHZhciBhZGp1c3RlZCA9IHRoaXMuX2RhdGVUaW1lLnBsdXNTZWNvbmRzKGRpZmZlcmVuY2UpO1xuXG4gICAgcmV0dXJuIG5ldyBPZmZzZXREYXRlVGltZShhZGp1c3RlZCwgb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8udHJ1bmNhdGVkVG8gPSBmdW5jdGlvbiB0cnVuY2F0ZWRUbyh1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS50cnVuY2F0ZWRUbyh1bml0KSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXNBbW91bnQgPSBmdW5jdGlvbiBfcGx1c0Ftb3VudChhbW91bnQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnQsICdhbW91bnQnKTtcbiAgICByZXR1cm4gYW1vdW50LmFkZFRvKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fcGx1c1VuaXQgPSBmdW5jdGlvbiBfcGx1c1VuaXQoYW1vdW50VG9BZGQsIHVuaXQpIHtcbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1cyhhbW91bnRUb0FkZCwgdW5pdCksIHRoaXMuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNZZWFycyh5ZWFycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNb250aHMgPSBmdW5jdGlvbiBwbHVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c01vbnRocyhtb250aHMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzV2Vla3MgPSBmdW5jdGlvbiBwbHVzV2Vla3Mod2Vla3MpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLnBsdXNXZWVrcyh3ZWVrcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNEYXlzID0gZnVuY3Rpb24gcGx1c0RheXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c0RheXMoZGF5cyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUucGx1c0hvdXJzKGhvdXJzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01pbnV0ZXMgPSBmdW5jdGlvbiBwbHVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzTWludXRlcyhtaW51dGVzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzU2Vjb25kcyhzZWNvbmRzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c05hbm9zID0gZnVuY3Rpb24gcGx1c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5wbHVzTmFub3MobmFub3MpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5fbWludXNBbW91bnQgPSBmdW5jdGlvbiBfbWludXNBbW91bnQoYW1vdW50KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50KTtcbiAgICByZXR1cm4gYW1vdW50LnN1YnRyYWN0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXMoLTEgKiBhbW91bnRUb1N1YnRyYWN0LCB1bml0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNZZWFycyA9IGZ1bmN0aW9uIG1pbnVzWWVhcnMoeWVhcnMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzWWVhcnMoeWVhcnMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNNb250aHMobW9udGhzKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNXZWVrcyA9IGZ1bmN0aW9uIG1pbnVzV2Vla3Mod2Vla3MpIHtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lT2Zmc2V0KHRoaXMuX2RhdGVUaW1lLm1pbnVzV2Vla3Mod2Vla3MpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0RheXMgPSBmdW5jdGlvbiBtaW51c0RheXMoZGF5cykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNEYXlzKGRheXMpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWVPZmZzZXQodGhpcy5fZGF0ZVRpbWUubWludXNIb3Vycyhob3VycyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c01pbnV0ZXMobWludXRlcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c1NlY29uZHMoc2Vjb25kcyksIHRoaXMuX29mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZU9mZnNldCh0aGlzLl9kYXRlVGltZS5taW51c05hbm9zKG5hbm9zKSwgdGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlciwgT2Zmc2V0RGF0ZVRpbWUsICdvdGhlcicpO1xuXG4gICAgaWYgKHRoaXMub2Zmc2V0KCkuZXF1YWxzKG90aGVyLm9mZnNldCgpKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9Mb2NhbERhdGVUaW1lKCkuY29tcGFyZVRvKG90aGVyLnRvTG9jYWxEYXRlVGltZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy50b0Vwb2NoU2Vjb25kKCksIG90aGVyLnRvRXBvY2hTZWNvbmQoKSk7XG5cbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpIC0gb3RoZXIudG9Mb2NhbFRpbWUoKS5uYW5vKCk7XG5cbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgY21wID0gdGhpcy50b0xvY2FsRGF0ZVRpbWUoKS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbERhdGVUaW1lKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXA7XG4gIH07XG5cbiAgX3Byb3RvLmlzQWZ0ZXIgPSBmdW5jdGlvbiBpc0FmdGVyKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHZhciB0aGlzRXBvY2hTZWMgPSB0aGlzLnRvRXBvY2hTZWNvbmQoKTtcbiAgICB2YXIgb3RoZXJFcG9jaFNlYyA9IG90aGVyLnRvRXBvY2hTZWNvbmQoKTtcbiAgICByZXR1cm4gdGhpc0Vwb2NoU2VjID4gb3RoZXJFcG9jaFNlYyB8fCB0aGlzRXBvY2hTZWMgPT09IG90aGVyRXBvY2hTZWMgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA+IG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwob3RoZXIsICdvdGhlcicpO1xuICAgIHZhciB0aGlzRXBvY2hTZWMgPSB0aGlzLnRvRXBvY2hTZWNvbmQoKTtcbiAgICB2YXIgb3RoZXJFcG9jaFNlYyA9IG90aGVyLnRvRXBvY2hTZWNvbmQoKTtcbiAgICByZXR1cm4gdGhpc0Vwb2NoU2VjIDwgb3RoZXJFcG9jaFNlYyB8fCB0aGlzRXBvY2hTZWMgPT09IG90aGVyRXBvY2hTZWMgJiYgdGhpcy50b0xvY2FsVGltZSgpLm5hbm8oKSA8IG90aGVyLnRvTG9jYWxUaW1lKCkubmFubygpO1xuICB9O1xuXG4gIF9wcm90by5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbChvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy50b0Vwb2NoU2Vjb25kKCkgPT09IG90aGVyLnRvRXBvY2hTZWNvbmQoKSAmJiB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpID09PSBvdGhlci50b0xvY2FsVGltZSgpLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBPZmZzZXREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLmVxdWFscyhvdGhlci5fZGF0ZVRpbWUpICYmIHRoaXMuX29mZnNldC5lcXVhbHMob3RoZXIuX29mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlVGltZS5oYXNoQ29kZSgpIF4gdGhpcy5fb2Zmc2V0Lmhhc2hDb2RlKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVUaW1lLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXQudG9TdHJpbmcoKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcbmZ1bmN0aW9uIF9pbml0JDYoKSB7XG4gIE9mZnNldERhdGVUaW1lLk1JTiA9IExvY2FsRGF0ZVRpbWUuTUlOLmF0T2Zmc2V0KFpvbmVPZmZzZXQuTUFYKTtcbiAgT2Zmc2V0RGF0ZVRpbWUuTUFYID0gTG9jYWxEYXRlVGltZS5NQVguYXRPZmZzZXQoWm9uZU9mZnNldC5NSU4pO1xuICBPZmZzZXREYXRlVGltZS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnT2Zmc2V0RGF0ZVRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgfSk7XG59XG5cbnZhciBEQVlTX1BFUl9DWUNMRSA9IDE0NjA5NztcbnZhciBEQVlTXzAwMDBfVE9fMTk3MCA9IERBWVNfUEVSX0NZQ0xFICogNSAtICgzMCAqIDM2NSArIDcpO1xudmFyIExvY2FsRGF0ZSA9IGZ1bmN0aW9uIChfQ2hyb25vTG9jYWxEYXRlKSB7XG4gIF9pbmhlcml0c0xvb3NlKExvY2FsRGF0ZSwgX0Nocm9ub0xvY2FsRGF0ZSk7XG5cbiAgTG9jYWxEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdyhjbG9ja09yWm9uZSkge1xuICAgIHZhciBjbG9jaztcblxuICAgIGlmIChjbG9ja09yWm9uZSA9PSBudWxsKSB7XG4gICAgICBjbG9jayA9IENsb2NrLnN5c3RlbURlZmF1bHRab25lKCk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIFpvbmVJZCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9jayA9IGNsb2NrT3Jab25lO1xuICAgIH1cblxuICAgIHJldHVybiBMb2NhbERhdGUub2ZJbnN0YW50KGNsb2NrLmluc3RhbnQoKSwgY2xvY2suem9uZSgpKTtcbiAgfTtcblxuICBMb2NhbERhdGUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICBpZiAoem9uZSA9PT0gdm9pZCAwKSB7XG4gICAgICB6b25lID0gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHZhciBvZmZzZXQgPSB6b25lLnJ1bGVzKCkub2Zmc2V0KGluc3RhbnQpO1xuICAgIHZhciBlcG9jaFNlYyA9IGluc3RhbnQuZXBvY2hTZWNvbmQoKSArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgZXBvY2hEYXkgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaFNlYywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KGVwb2NoRGF5KTtcbiAgfTtcblxuICBMb2NhbERhdGUub2YgPSBmdW5jdGlvbiBvZih5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfTtcblxuICBMb2NhbERhdGUub2ZZZWFyRGF5ID0gZnVuY3Rpb24gb2ZZZWFyRGF5KHllYXIsIGRheU9mWWVhcikge1xuICAgIENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZFZhbHVlKHllYXIpO1xuICAgIHZhciBsZWFwID0gSXNvQ2hyb25vbG9neS5pc0xlYXBZZWFyKHllYXIpO1xuXG4gICAgaWYgKGRheU9mWWVhciA9PT0gMzY2ICYmIGxlYXAgPT09IGZhbHNlKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsIFwiSW52YWxpZCBkYXRlICdEYXlPZlllYXIgMzY2JyBhcyAnXCIgKyB5ZWFyICsgXCInIGlzIG5vdCBhIGxlYXAgeWVhclwiLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIG1veSA9IE1vbnRoLm9mKE1hdGguZmxvb3IoKGRheU9mWWVhciAtIDEpIC8gMzEgKyAxKSk7XG4gICAgdmFyIG1vbnRoRW5kID0gbW95LmZpcnN0RGF5T2ZZZWFyKGxlYXApICsgbW95Lmxlbmd0aChsZWFwKSAtIDE7XG5cbiAgICBpZiAoZGF5T2ZZZWFyID4gbW9udGhFbmQpIHtcbiAgICAgIG1veSA9IG1veS5wbHVzKDEpO1xuICAgIH1cblxuICAgIHZhciBkb20gPSBkYXlPZlllYXIgLSBtb3kuZmlyc3REYXlPZlllYXIobGVhcCkgKyAxO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlKHllYXIsIG1veS52YWx1ZSgpLCBkb20pO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5vZkVwb2NoRGF5ID0gZnVuY3Rpb24gb2ZFcG9jaERheShlcG9jaERheSkge1xuICAgIGlmIChlcG9jaERheSA9PT0gdm9pZCAwKSB7XG4gICAgICBlcG9jaERheSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGFkanVzdCwgYWRqdXN0Q3ljbGVzLCBkb3lFc3QsIHllYXJFc3QsIHplcm9EYXk7XG4gICAgemVyb0RheSA9IGVwb2NoRGF5ICsgREFZU18wMDAwX1RPXzE5NzA7XG4gICAgemVyb0RheSAtPSA2MDtcbiAgICBhZGp1c3QgPSAwO1xuXG4gICAgaWYgKHplcm9EYXkgPCAwKSB7XG4gICAgICBhZGp1c3RDeWNsZXMgPSBNYXRoVXRpbC5pbnREaXYoemVyb0RheSArIDEsIERBWVNfUEVSX0NZQ0xFKSAtIDE7XG4gICAgICBhZGp1c3QgPSBhZGp1c3RDeWNsZXMgKiA0MDA7XG4gICAgICB6ZXJvRGF5ICs9IC1hZGp1c3RDeWNsZXMgKiBEQVlTX1BFUl9DWUNMRTtcbiAgICB9XG5cbiAgICB5ZWFyRXN0ID0gTWF0aFV0aWwuaW50RGl2KDQwMCAqIHplcm9EYXkgKyA1OTEsIERBWVNfUEVSX0NZQ0xFKTtcbiAgICBkb3lFc3QgPSB6ZXJvRGF5IC0gKDM2NSAqIHllYXJFc3QgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNCkgLSBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ZWFyRXN0LCA0MDApKTtcblxuICAgIGlmIChkb3lFc3QgPCAwKSB7XG4gICAgICB5ZWFyRXN0LS07XG4gICAgICBkb3lFc3QgPSB6ZXJvRGF5IC0gKDM2NSAqIHllYXJFc3QgKyBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgNCkgLSBNYXRoVXRpbC5pbnREaXYoeWVhckVzdCwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ZWFyRXN0LCA0MDApKTtcbiAgICB9XG5cbiAgICB5ZWFyRXN0ICs9IGFkanVzdDtcbiAgICB2YXIgbWFyY2hEb3kwID0gZG95RXN0O1xuICAgIHZhciBtYXJjaE1vbnRoMCA9IE1hdGhVdGlsLmludERpdihtYXJjaERveTAgKiA1ICsgMiwgMTUzKTtcbiAgICB2YXIgbW9udGggPSAobWFyY2hNb250aDAgKyAyKSAlIDEyICsgMTtcbiAgICB2YXIgZG9tID0gbWFyY2hEb3kwIC0gTWF0aFV0aWwuaW50RGl2KG1hcmNoTW9udGgwICogMzA2ICsgNSwgMTApICsgMTtcbiAgICB5ZWFyRXN0ICs9IE1hdGhVdGlsLmludERpdihtYXJjaE1vbnRoMCwgMTApO1xuICAgIHZhciB5ZWFyID0geWVhckVzdDtcbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZSh5ZWFyLCBtb250aCwgZG9tKTtcbiAgfTtcblxuICBMb2NhbERhdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG4gICAgdmFyIGRhdGUgPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpO1xuXG4gICAgaWYgKGRhdGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBMb2NhbERhdGUgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRleHQsIGZvcm1hdHRlcikge1xuICAgIGlmIChmb3JtYXR0ZXIgPT09IHZvaWQgMCkge1xuICAgICAgZm9ybWF0dGVyID0gRGF0ZVRpbWVGb3JtYXR0ZXIuSVNPX0xPQ0FMX0RBVEU7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZvcm1hdHRlciAhPSBudWxsLCAnZm9ybWF0dGVyJywgTnVsbFBvaW50ZXJFeGNlcHRpb24pO1xuICAgIHJldHVybiBmb3JtYXR0ZXIucGFyc2UodGV4dCwgTG9jYWxEYXRlLkZST00pO1xuICB9O1xuXG4gIExvY2FsRGF0ZS5fcmVzb2x2ZVByZXZpb3VzVmFsaWQgPSBmdW5jdGlvbiBfcmVzb2x2ZVByZXZpb3VzVmFsaWQoeWVhciwgbW9udGgsIGRheSkge1xuICAgIHN3aXRjaCAobW9udGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgZGF5ID0gTWF0aC5taW4oZGF5LCBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgOTpcbiAgICAgIGNhc2UgMTE6XG4gICAgICAgIGRheSA9IE1hdGgubWluKGRheSwgMzApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHllYXIsIG1vbnRoLCBkYXkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExvY2FsRGF0ZSh5ZWFyLCBtb250aCwgZGF5T2ZNb250aCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nocm9ub0xvY2FsRGF0ZS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgcmVxdWlyZU5vbk51bGwoeWVhciwgJ3llYXInKTtcbiAgICByZXF1aXJlTm9uTnVsbChtb250aCwgJ21vbnRoJyk7XG4gICAgcmVxdWlyZU5vbk51bGwoZGF5T2ZNb250aCwgJ2RheU9mTW9udGgnKTtcblxuICAgIGlmIChtb250aCBpbnN0YW5jZW9mIE1vbnRoKSB7XG4gICAgICBtb250aCA9IG1vbnRoLnZhbHVlKCk7XG4gICAgfVxuXG4gICAgX3RoaXMuX3llYXIgPSBNYXRoVXRpbC5zYWZlVG9JbnQoeWVhcik7XG4gICAgX3RoaXMuX21vbnRoID0gTWF0aFV0aWwuc2FmZVRvSW50KG1vbnRoKTtcbiAgICBfdGhpcy5fZGF5ID0gTWF0aFV0aWwuc2FmZVRvSW50KGRheU9mTW9udGgpO1xuXG4gICAgTG9jYWxEYXRlLl92YWxpZGF0ZShfdGhpcy5feWVhciwgX3RoaXMuX21vbnRoLCBfdGhpcy5fZGF5KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIExvY2FsRGF0ZS5fdmFsaWRhdGUgPSBmdW5jdGlvbiBfdmFsaWRhdGUoeWVhciwgbW9udGgsIGRheU9mTW9udGgpIHtcbiAgICB2YXIgZG9tO1xuICAgIENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZFZhbHVlKHllYXIpO1xuICAgIENocm9ub0ZpZWxkLk1PTlRIX09GX1lFQVIuY2hlY2tWYWxpZFZhbHVlKG1vbnRoKTtcbiAgICBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEguY2hlY2tWYWxpZFZhbHVlKGRheU9mTW9udGgpO1xuXG4gICAgaWYgKGRheU9mTW9udGggPiAyOCkge1xuICAgICAgZG9tID0gMzE7XG5cbiAgICAgIHN3aXRjaCAobW9udGgpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGRvbSA9IElzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBkb20gPSAzMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheU9mTW9udGggPiBkb20pIHtcbiAgICAgICAgaWYgKGRheU9mTW9udGggPT09IDI5KSB7XG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgZGF0ZSAnRmVicnVhcnkgMjknIGFzICdcIiArIHllYXIgKyBcIicgaXMgbm90IGEgbGVhcCB5ZWFyXCIsIERhdGVUaW1lRXhjZXB0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UsIFwiSW52YWxpZCBkYXRlICdcIiArIHllYXIgKyBcIicgJ1wiICsgbW9udGggKyBcIicgJ1wiICsgZGF5T2ZNb250aCArIFwiJ1wiLCBEYXRlVGltZUV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IExvY2FsRGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUuaXNTdXBwb3J0ZWQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkLmlzRGF0ZUJhc2VkKCkpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX01PTlRIOlxuICAgICAgICAgICAgcmV0dXJuIFZhbHVlUmFuZ2Uub2YoMSwgdGhpcy5sZW5ndGhPZk1vbnRoKCkpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfWUVBUjpcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZVJhbmdlLm9mKDEsIHRoaXMubGVuZ3RoT2ZZZWFyKCkpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfTU9OVEg6XG4gICAgICAgICAgICByZXR1cm4gVmFsdWVSYW5nZS5vZigxLCB0aGlzLm1vbnRoKCkgPT09IE1vbnRoLkZFQlJVQVJZICYmIHRoaXMuaXNMZWFwWWVhcigpID09PSBmYWxzZSA/IDQgOiA1KTtcblxuICAgICAgICAgIGNhc2UgQ2hyb25vRmllbGQuWUVBUl9PRl9FUkE6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feWVhciA8PSAwID8gVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSArIDEpIDogVmFsdWVSYW5nZS5vZigxLCBZZWFyLk1BWF9WQUxVRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmllbGQucmFuZ2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgZmllbGQ6IFwiICsgZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5yYW5nZVJlZmluZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpZWxkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TG9uZyhmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgYXNzZXJ0KGZpZWxkICE9IG51bGwsICcnLCBOdWxsUG9pbnRlckV4Y2VwdGlvbik7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldDAoZmllbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZC5nZXRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0MCA9IGZ1bmN0aW9uIF9nZXQwKGZpZWxkKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfV0VFSzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5T2ZXZWVrKCkudmFsdWUoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX01PTlRIOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2RheSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX0RBWV9PRl9XRUVLX0lOX1lFQVI6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnRNb2QodGhpcy5kYXlPZlllYXIoKSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5EQVlfT0ZfTU9OVEg6XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX1lFQVI6XG4gICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkVQT0NIX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9FcG9jaERheSgpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USDpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9kYXkgLSAxLCA3KSArIDE7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVI6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5kYXlPZlllYXIoKSAtIDEsIDcpICsgMTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGg7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuUFJPTEVQVElDX01PTlRIOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbGVwdGljTW9udGgoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSX09GX0VSQTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3llYXIgPj0gMSA/IHRoaXMuX3llYXIgOiAxIC0gdGhpcy5feWVhcjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5ZRUFSOlxuICAgICAgICByZXR1cm4gdGhpcy5feWVhcjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5FUkE6XG4gICAgICAgIHJldHVybiB0aGlzLl95ZWFyID49IDEgPyAxIDogMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLl9wcm9sZXB0aWNNb250aCA9IGZ1bmN0aW9uIF9wcm9sZXB0aWNNb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhciAqIDEyICsgKHRoaXMuX21vbnRoIC0gMSk7XG4gIH07XG5cbiAgX3Byb3RvLmNocm9ub2xvZ3kgPSBmdW5jdGlvbiBjaHJvbm9sb2d5KCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LklOU1RBTkNFO1xuICB9O1xuXG4gIF9wcm90by55ZWFyID0gZnVuY3Rpb24geWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5feWVhcjtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbnRoO1xuICB9O1xuXG4gIF9wcm90by5tb250aCA9IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgIHJldHVybiBNb250aC5vZih0aGlzLl9tb250aCk7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXk7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mWWVhciA9IGZ1bmN0aW9uIGRheU9mWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpLmZpcnN0RGF5T2ZZZWFyKHRoaXMuaXNMZWFwWWVhcigpKSArIHRoaXMuX2RheSAtIDE7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mV2VlayA9IGZ1bmN0aW9uIGRheU9mV2VlaygpIHtcbiAgICB2YXIgZG93MCA9IE1hdGhVdGlsLmZsb29yTW9kKHRoaXMudG9FcG9jaERheSgpICsgMywgNyk7XG4gICAgcmV0dXJuIERheU9mV2Vlay5vZihkb3cwICsgMSk7XG4gIH07XG5cbiAgX3Byb3RvLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKCkge1xuICAgIHJldHVybiBJc29DaHJvbm9sb2d5LmlzTGVhcFllYXIodGhpcy5feWVhcik7XG4gIH07XG5cbiAgX3Byb3RvLmxlbmd0aE9mTW9udGggPSBmdW5jdGlvbiBsZW5ndGhPZk1vbnRoKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbW9udGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMZWFwWWVhcigpID8gMjkgOiAyODtcblxuICAgICAgY2FzZSA0OlxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA5OlxuICAgICAgY2FzZSAxMTpcbiAgICAgICAgcmV0dXJuIDMwO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMzE7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5sZW5ndGhPZlllYXIgPSBmdW5jdGlvbiBsZW5ndGhPZlllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZWFwWWVhcigpID8gMzY2IDogMzY1O1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEFkanVzdGVyID0gZnVuY3Rpb24gX3dpdGhBZGp1c3RlcihhZGp1c3Rlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKGFkanVzdGVyLCAnYWRqdXN0ZXInKTtcblxuICAgIGlmIChhZGp1c3RlciBpbnN0YW5jZW9mIExvY2FsRGF0ZSkge1xuICAgICAgcmV0dXJuIGFkanVzdGVyO1xuICAgIH1cblxuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlLnByb3RvdHlwZS5fd2l0aEFkanVzdGVyLmNhbGwodGhpcywgYWRqdXN0ZXIpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICBhc3NlcnQoZmllbGQgIT0gbnVsbCwgJ2ZpZWxkJywgTnVsbFBvaW50ZXJFeGNlcHRpb24pO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHZhciBmID0gZmllbGQ7XG4gICAgICBmLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIHN3aXRjaCAoZikge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9XRUVLOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKG5ld1ZhbHVlIC0gdGhpcy5kYXlPZldlZWsoKS52YWx1ZSgpKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0RheXMobmV3VmFsdWUgLSB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9NT05USCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9EQVlfT0ZfV0VFS19JTl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkFMSUdORURfREFZX09GX1dFRUtfSU5fWUVBUikpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuREFZX09GX01PTlRIOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhEYXlPZk1vbnRoKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLkRBWV9PRl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhEYXlPZlllYXIobmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuRVBPQ0hfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheShuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5BTElHTkVEX1dFRUtfT0ZfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1dlZWtzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9NT05USCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQUxJR05FRF9XRUVLX09GX1lFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1dlZWtzKG5ld1ZhbHVlIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkFMSUdORURfV0VFS19PRl9ZRUFSKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhNb250aChuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEg6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01vbnRocyhuZXdWYWx1ZSAtIHRoaXMuZ2V0TG9uZyhDaHJvbm9GaWVsZC5QUk9MRVBUSUNfTU9OVEgpKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVJfT0ZfRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhZZWFyKHRoaXMuX3llYXIgPj0gMSA/IG5ld1ZhbHVlIDogMSAtIG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLllFQVI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aFllYXIobmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuRVJBOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldExvbmcoQ2hyb25vRmllbGQuRVJBKSA9PT0gbmV3VmFsdWUgPyB0aGlzIDogdGhpcy53aXRoWWVhcigxIC0gdGhpcy5feWVhcik7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIGlmICh0aGlzLl95ZWFyID09PSB5ZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRWYWx1ZSh5ZWFyKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZCh5ZWFyLCB0aGlzLl9tb250aCwgdGhpcy5fZGF5KTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE1vbnRoID0gZnVuY3Rpb24gd2l0aE1vbnRoKG1vbnRoKSB7XG4gICAgdmFyIG0gPSBtb250aCBpbnN0YW5jZW9mIE1vbnRoID8gbW9udGgudmFsdWUoKSA6IG1vbnRoO1xuXG4gICAgaWYgKHRoaXMuX21vbnRoID09PSBtKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5NT05USF9PRl9ZRUFSLmNoZWNrVmFsaWRWYWx1ZShtKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZCh0aGlzLl95ZWFyLCBtLCB0aGlzLl9kYXkpO1xuICB9O1xuXG4gIF9wcm90by53aXRoRGF5T2ZNb250aCA9IGZ1bmN0aW9uIHdpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpIHtcbiAgICBpZiAodGhpcy5fZGF5ID09PSBkYXlPZk1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTG9jYWxEYXRlLm9mKHRoaXMuX3llYXIsIHRoaXMuX21vbnRoLCBkYXlPZk1vbnRoKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgaWYgKHRoaXMuZGF5T2ZZZWFyKCkgPT09IGRheU9mWWVhcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIExvY2FsRGF0ZS5vZlllYXJEYXkodGhpcy5feWVhciwgZGF5T2ZZZWFyKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYW1vdW50VG9BZGQsICdhbW91bnRUb0FkZCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzRGF5cyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LldFRUtTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1PTlRIUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTW9udGhzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuWUVBUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuREVDQURFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMCkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5DRU5UVVJJRVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgMTAwKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTExFTk5JQTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzWWVhcnMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCAxMDAwKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkVSQVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2l0aChDaHJvbm9GaWVsZC5FUkEsIE1hdGhVdGlsLnNhZmVBZGQodGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSksIGFtb3VudFRvQWRkKSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYWRkVG8odGhpcywgYW1vdW50VG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzWWVhcnMgPSBmdW5jdGlvbiBwbHVzWWVhcnMoeWVhcnNUb0FkZCkge1xuICAgIGlmICh5ZWFyc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3WWVhciA9IENocm9ub0ZpZWxkLllFQVIuY2hlY2tWYWxpZEludFZhbHVlKHRoaXMuX3llYXIgKyB5ZWFyc1RvQWRkKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlLl9yZXNvbHZlUHJldmlvdXNWYWxpZChuZXdZZWFyLCB0aGlzLl9tb250aCwgdGhpcy5fZGF5KTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzVG9BZGQpIHtcbiAgICBpZiAobW9udGhzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBtb250aENvdW50ID0gdGhpcy5feWVhciAqIDEyICsgKHRoaXMuX21vbnRoIC0gMSk7XG4gICAgdmFyIGNhbGNNb250aHMgPSBtb250aENvdW50ICsgbW9udGhzVG9BZGQ7XG4gICAgdmFyIG5ld1llYXIgPSBDaHJvbm9GaWVsZC5ZRUFSLmNoZWNrVmFsaWRJbnRWYWx1ZShNYXRoVXRpbC5mbG9vckRpdihjYWxjTW9udGhzLCAxMikpO1xuICAgIHZhciBuZXdNb250aCA9IE1hdGhVdGlsLmZsb29yTW9kKGNhbGNNb250aHMsIDEyKSArIDE7XG4gICAgcmV0dXJuIExvY2FsRGF0ZS5fcmVzb2x2ZVByZXZpb3VzVmFsaWQobmV3WWVhciwgbmV3TW9udGgsIHRoaXMuX2RheSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNXZWVrcyA9IGZ1bmN0aW9uIHBsdXNXZWVrcyh3ZWVrc1RvQWRkKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KHdlZWtzVG9BZGQsIDcpKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzVG9BZGQpIHtcbiAgICBpZiAoZGF5c1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbWpEYXkgPSBNYXRoVXRpbC5zYWZlQWRkKHRoaXMudG9FcG9jaERheSgpLCBkYXlzVG9BZGQpO1xuICAgIHJldHVybiBMb2NhbERhdGUub2ZFcG9jaERheShtakRheSk7XG4gIH07XG5cbiAgX3Byb3RvLl9taW51c1VuaXQgPSBmdW5jdGlvbiBfbWludXNVbml0KGFtb3VudFRvU3VidHJhY3QsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhbW91bnRUb1N1YnRyYWN0LCAnYW1vdW50VG9TdWJ0cmFjdCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNZZWFycyh5ZWFyc1RvU3VidHJhY3QgKiAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTW9udGhzID0gZnVuY3Rpb24gbWludXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMobW9udGhzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNXZWVrcyA9IGZ1bmN0aW9uIG1pbnVzV2Vla3Mod2Vla3NUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1dlZWtzKHdlZWtzVG9TdWJ0cmFjdCAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXNUb1N1YnRyYWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c0RheXMoZGF5c1RvU3VidHJhY3QgKiAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gX0Nocm9ub0xvY2FsRGF0ZS5wcm90b3R5cGUuYWRqdXN0SW50by5jYWxsKHRoaXMsIHRlbXBvcmFsKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChwMSwgcDIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnVudGlsMShwMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVudGlsMihwMSwgcDIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udW50aWwyID0gZnVuY3Rpb24gdW50aWwyKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHZhciBlbmQgPSBMb2NhbERhdGUuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF5c1VudGlsKGVuZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LldFRUtTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5kYXlzVW50aWwoZW5kKSwgNyk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1PTlRIUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzVW50aWwoZW5kKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuWUVBUlM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9tb250aHNVbnRpbChlbmQpLCAxMik7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkRFQ0FERVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9tb250aHNVbnRpbChlbmQpLCAxMjApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5DRU5UVVJJRVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9tb250aHNVbnRpbChlbmQpLCAxMjAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTEVOTklBOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbW9udGhzVW50aWwoZW5kKSwgMTIwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5FUkFTOlxuICAgICAgICAgIHJldHVybiBlbmQuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUkEpIC0gdGhpcy5nZXRMb25nKENocm9ub0ZpZWxkLkVSQSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIHVuaXQ6IFwiICsgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuXG4gIF9wcm90by5kYXlzVW50aWwgPSBmdW5jdGlvbiBkYXlzVW50aWwoZW5kKSB7XG4gICAgcmV0dXJuIGVuZC50b0Vwb2NoRGF5KCkgLSB0aGlzLnRvRXBvY2hEYXkoKTtcbiAgfTtcblxuICBfcHJvdG8uX21vbnRoc1VudGlsID0gZnVuY3Rpb24gX21vbnRoc1VudGlsKGVuZCkge1xuICAgIHZhciBwYWNrZWQxID0gdGhpcy5fcHJvbGVwdGljTW9udGgoKSAqIDMyICsgdGhpcy5kYXlPZk1vbnRoKCk7XG4gICAgdmFyIHBhY2tlZDIgPSBlbmQuX3Byb2xlcHRpY01vbnRoKCkgKiAzMiArIGVuZC5kYXlPZk1vbnRoKCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihwYWNrZWQyIC0gcGFja2VkMSwgMzIpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbDEgPSBmdW5jdGlvbiB1bnRpbDEoZW5kRGF0ZSkge1xuICAgIHZhciBlbmQgPSBMb2NhbERhdGUuZnJvbShlbmREYXRlKTtcblxuICAgIHZhciB0b3RhbE1vbnRocyA9IGVuZC5fcHJvbGVwdGljTW9udGgoKSAtIHRoaXMuX3Byb2xlcHRpY01vbnRoKCk7XG5cbiAgICB2YXIgZGF5cyA9IGVuZC5fZGF5IC0gdGhpcy5fZGF5O1xuXG4gICAgaWYgKHRvdGFsTW9udGhzID4gMCAmJiBkYXlzIDwgMCkge1xuICAgICAgdG90YWxNb250aHMtLTtcbiAgICAgIHZhciBjYWxjRGF0ZSA9IHRoaXMucGx1c01vbnRocyh0b3RhbE1vbnRocyk7XG4gICAgICBkYXlzID0gZW5kLnRvRXBvY2hEYXkoKSAtIGNhbGNEYXRlLnRvRXBvY2hEYXkoKTtcbiAgICB9IGVsc2UgaWYgKHRvdGFsTW9udGhzIDwgMCAmJiBkYXlzID4gMCkge1xuICAgICAgdG90YWxNb250aHMrKztcbiAgICAgIGRheXMgLT0gZW5kLmxlbmd0aE9mTW9udGgoKTtcbiAgICB9XG5cbiAgICB2YXIgeWVhcnMgPSBNYXRoVXRpbC5pbnREaXYodG90YWxNb250aHMsIDEyKTtcbiAgICB2YXIgbW9udGhzID0gTWF0aFV0aWwuaW50TW9kKHRvdGFsTW9udGhzLCAxMik7XG4gICAgcmV0dXJuIFBlcmlvZC5vZih5ZWFycywgbW9udGhzLCBkYXlzKTtcbiAgfTtcblxuICBfcHJvdG8uYXRUaW1lID0gZnVuY3Rpb24gYXRUaW1lKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdFRpbWUxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmF0VGltZTQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF0VGltZTEgPSBmdW5jdGlvbiBhdFRpbWUxKHRpbWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0aW1lLCAndGltZScpO1xuXG4gICAgaWYgKHRpbWUgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mKHRoaXMsIHRpbWUpO1xuICAgIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIE9mZnNldFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdFRpbWVPZmZzZXRUaW1lKHRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwidGltZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIExvY2FsVGltZSBvciBPZmZzZXRUaW1lXCIgKyAodGltZSAmJiB0aW1lLmNvbnN0cnVjdG9yICYmIHRpbWUuY29uc3RydWN0b3IubmFtZSA/IFwiLCBidXQgaXMgXCIgKyB0aW1lLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYXRUaW1lNCA9IGZ1bmN0aW9uIGF0VGltZTQoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCkge1xuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXRUaW1lMShMb2NhbFRpbWUub2YoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCkpO1xuICB9O1xuXG4gIF9wcm90by5fYXRUaW1lT2Zmc2V0VGltZSA9IGZ1bmN0aW9uIF9hdFRpbWVPZmZzZXRUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gT2Zmc2V0RGF0ZVRpbWUub2YoTG9jYWxEYXRlVGltZS5vZih0aGlzLCB0aW1lLnRvTG9jYWxUaW1lKCkpLCB0aW1lLm9mZnNldCgpKTtcbiAgfTtcblxuICBfcHJvdG8uYXRTdGFydE9mRGF5ID0gZnVuY3Rpb24gYXRTdGFydE9mRGF5KHpvbmUpIHtcbiAgICBpZiAoem9uZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXRTdGFydE9mRGF5V2l0aFpvbmUoem9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mKHRoaXMsIExvY2FsVGltZS5NSUROSUdIVCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fYXRTdGFydE9mRGF5V2l0aFpvbmUgPSBmdW5jdGlvbiBfYXRTdGFydE9mRGF5V2l0aFpvbmUoem9uZSkge1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIGxkdCA9IHRoaXMuYXRUaW1lKExvY2FsVGltZS5NSUROSUdIVCk7XG5cbiAgICBpZiAoem9uZSBpbnN0YW5jZW9mIFpvbmVPZmZzZXQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgdHJhbnMgPSB6b25lLnJ1bGVzKCkudHJhbnNpdGlvbihsZHQpO1xuXG4gICAgICBpZiAodHJhbnMgIT0gbnVsbCAmJiB0cmFucy5pc0dhcCgpKSB7XG4gICAgICAgIGxkdCA9IHRyYW5zLmRhdGVUaW1lQWZ0ZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gWm9uZWREYXRlVGltZS5vZihsZHQsIHpvbmUpO1xuICB9O1xuXG4gIF9wcm90by50b0Vwb2NoRGF5ID0gZnVuY3Rpb24gdG9FcG9jaERheSgpIHtcbiAgICB2YXIgeSA9IHRoaXMuX3llYXI7XG4gICAgdmFyIG0gPSB0aGlzLl9tb250aDtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHRvdGFsICs9IDM2NSAqIHk7XG5cbiAgICBpZiAoeSA+PSAwKSB7XG4gICAgICB0b3RhbCArPSBNYXRoVXRpbC5pbnREaXYoeSArIDMsIDQpIC0gTWF0aFV0aWwuaW50RGl2KHkgKyA5OSwgMTAwKSArIE1hdGhVdGlsLmludERpdih5ICsgMzk5LCA0MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbCAtPSBNYXRoVXRpbC5pbnREaXYoeSwgLTQpIC0gTWF0aFV0aWwuaW50RGl2KHksIC0xMDApICsgTWF0aFV0aWwuaW50RGl2KHksIC00MDApO1xuICAgIH1cblxuICAgIHRvdGFsICs9IE1hdGhVdGlsLmludERpdigzNjcgKiBtIC0gMzYyLCAxMik7XG4gICAgdG90YWwgKz0gdGhpcy5kYXlPZk1vbnRoKCkgLSAxO1xuXG4gICAgaWYgKG0gPiAyKSB7XG4gICAgICB0b3RhbC0tO1xuXG4gICAgICBpZiAoIUlzb0Nocm9ub2xvZ3kuaXNMZWFwWWVhcih5KSkge1xuICAgICAgICB0b3RhbC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbCAtIERBWVNfMDAwMF9UT18xOTcwO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBMb2NhbERhdGUsICdvdGhlcicpO1xuICAgIHJldHVybiB0aGlzLl9jb21wYXJlVG8wKG90aGVyKTtcbiAgfTtcblxuICBfcHJvdG8uX2NvbXBhcmVUbzAgPSBmdW5jdGlvbiBfY29tcGFyZVRvMChvdGhlckRhdGUpIHtcbiAgICB2YXIgY21wID0gdGhpcy5feWVhciAtIG90aGVyRGF0ZS5feWVhcjtcblxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IHRoaXMuX21vbnRoIC0gb3RoZXJEYXRlLl9tb250aDtcblxuICAgICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICBjbXAgPSB0aGlzLl9kYXkgLSBvdGhlckRhdGUuX2RheTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb21wYXJlVG8wKG90aGVyKSA9PT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgdmFyIHllYXJWYWx1ZSA9IHRoaXMuX3llYXI7XG4gICAgdmFyIG1vbnRoVmFsdWUgPSB0aGlzLl9tb250aDtcbiAgICB2YXIgZGF5VmFsdWUgPSB0aGlzLl9kYXk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2goeWVhclZhbHVlICYgMHhGRkZGRjgwMCBeICh5ZWFyVmFsdWUgPDwgMTEpICsgKG1vbnRoVmFsdWUgPDwgNikgKyBkYXlWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIGRheVN0cmluZywgbW9udGhTdHJpbmcsIHllYXJTdHJpbmc7XG4gICAgdmFyIHllYXJWYWx1ZSA9IHRoaXMuX3llYXI7XG4gICAgdmFyIG1vbnRoVmFsdWUgPSB0aGlzLl9tb250aDtcbiAgICB2YXIgZGF5VmFsdWUgPSB0aGlzLl9kYXk7XG4gICAgdmFyIGFic1llYXIgPSBNYXRoLmFicyh5ZWFyVmFsdWUpO1xuXG4gICAgaWYgKGFic1llYXIgPCAxMDAwKSB7XG4gICAgICBpZiAoeWVhclZhbHVlIDwgMCkge1xuICAgICAgICB5ZWFyU3RyaW5nID0gXCItXCIgKyAoXCJcIiArICh5ZWFyVmFsdWUgLSAxMDAwMCkpLnNsaWNlKC00KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHllYXJTdHJpbmcgPSAoXCJcIiArICh5ZWFyVmFsdWUgKyAxMDAwMCkpLnNsaWNlKC00KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHllYXJWYWx1ZSA+IDk5OTkpIHtcbiAgICAgICAgeWVhclN0cmluZyA9IFwiK1wiICsgeWVhclZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWVhclN0cmluZyA9IFwiXCIgKyB5ZWFyVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vbnRoVmFsdWUgPCAxMCkge1xuICAgICAgbW9udGhTdHJpbmcgPSBcIi0wXCIgKyBtb250aFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb250aFN0cmluZyA9IFwiLVwiICsgbW9udGhWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZGF5VmFsdWUgPCAxMCkge1xuICAgICAgZGF5U3RyaW5nID0gXCItMFwiICsgZGF5VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRheVN0cmluZyA9IFwiLVwiICsgZGF5VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHllYXJTdHJpbmcgKyBtb250aFN0cmluZyArIGRheVN0cmluZztcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChmb3JtYXR0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2UoZm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlciwgJ2Zvcm1hdHRlcicpO1xuICAgIHJldHVybiBfQ2hyb25vTG9jYWxEYXRlLnByb3RvdHlwZS5mb3JtYXQuY2FsbCh0aGlzLCBmb3JtYXR0ZXIpO1xuICB9O1xuXG4gIHJldHVybiBMb2NhbERhdGU7XG59KENocm9ub0xvY2FsRGF0ZSk7XG5mdW5jdGlvbiBfaW5pdCQ1KCkge1xuICBMb2NhbERhdGUuTUlOID0gTG9jYWxEYXRlLm9mKFllYXJDb25zdGFudHMuTUlOX1ZBTFVFLCAxLCAxKTtcbiAgTG9jYWxEYXRlLk1BWCA9IExvY2FsRGF0ZS5vZihZZWFyQ29uc3RhbnRzLk1BWF9WQUxVRSwgMTIsIDMxKTtcbiAgTG9jYWxEYXRlLkVQT0NIXzAgPSBMb2NhbERhdGUub2ZFcG9jaERheSgwKTtcbiAgTG9jYWxEYXRlLkZST00gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdMb2NhbERhdGUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgQ2hyb25vTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hyb25vTG9jYWxEYXRlVGltZSwgX1RlbXBvcmFsKTtcblxuICBmdW5jdGlvbiBDaHJvbm9Mb2NhbERhdGVUaW1lKCkge1xuICAgIHJldHVybiBfVGVtcG9yYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENocm9ub0xvY2FsRGF0ZVRpbWUucHJvdG90eXBlO1xuXG4gIF9wcm90by5jaHJvbm9sb2d5ID0gZnVuY3Rpb24gY2hyb25vbG9neSgpIHtcbiAgICByZXR1cm4gdGhpcy50b0xvY2FsRGF0ZSgpLmNocm9ub2xvZ3koKTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaHJvbm9sb2d5KCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbERhdGUoKSkge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZS5vZkVwb2NoRGF5KHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCkpO1xuICAgIH0gZWxzZSBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxUaW1lKCk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuem9uZUlkKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgX3F1ZXJ5KTtcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0SW50byA9IGZ1bmN0aW9uIGFkanVzdEludG8odGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwud2l0aChDaHJvbm9GaWVsZC5FUE9DSF9EQVksIHRoaXMudG9Mb2NhbERhdGUoKS50b0Vwb2NoRGF5KCkpLndpdGgoQ2hyb25vRmllbGQuTkFOT19PRl9EQVksIHRoaXMudG9Mb2NhbFRpbWUoKS50b05hbm9PZkRheSgpKTtcbiAgfTtcblxuICBfcHJvdG8udG9JbnN0YW50ID0gZnVuY3Rpb24gdG9JbnN0YW50KG9mZnNldCkge1xuICAgIHJlcXVpcmVJbnN0YW5jZShvZmZzZXQsIFpvbmVPZmZzZXQsICd6b25lSWQnKTtcbiAgICByZXR1cm4gSW5zdGFudC5vZkVwb2NoU2Vjb25kKHRoaXMudG9FcG9jaFNlY29uZChvZmZzZXQpLCB0aGlzLnRvTG9jYWxUaW1lKCkubmFubygpKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQob2Zmc2V0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0LCAnb2Zmc2V0Jyk7XG4gICAgdmFyIGVwb2NoRGF5ID0gdGhpcy50b0xvY2FsRGF0ZSgpLnRvRXBvY2hEYXkoKTtcbiAgICB2YXIgc2VjcyA9IGVwb2NoRGF5ICogODY0MDAgKyB0aGlzLnRvTG9jYWxUaW1lKCkudG9TZWNvbmRPZkRheSgpO1xuICAgIHNlY3MgLT0gb2Zmc2V0LnRvdGFsU2Vjb25kcygpO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlVG9JbnQoc2Vjcyk7XG4gIH07XG5cbiAgcmV0dXJuIENocm9ub0xvY2FsRGF0ZVRpbWU7XG59KFRlbXBvcmFsKTtcblxudmFyIExvY2FsRGF0ZVRpbWUgPSBmdW5jdGlvbiAoX0Nocm9ub0xvY2FsRGF0ZVRpbWUpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxEYXRlVGltZSwgX0Nocm9ub0xvY2FsRGF0ZVRpbWUpO1xuXG4gIExvY2FsRGF0ZVRpbWUubm93ID0gZnVuY3Rpb24gbm93KGNsb2NrT3Jab25lKSB7XG4gICAgaWYgKGNsb2NrT3Jab25lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLl9ub3coQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUoKSk7XG4gICAgfSBlbHNlIGlmIChjbG9ja09yWm9uZSBpbnN0YW5jZW9mIENsb2NrKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUuX25vdyhDbG9jay5zeXN0ZW0oY2xvY2tPclpvbmUpKTtcbiAgICB9XG4gIH07XG5cbiAgTG9jYWxEYXRlVGltZS5fbm93ID0gZnVuY3Rpb24gX25vdyhjbG9jaykge1xuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZkluc3RhbnQoY2xvY2suaW5zdGFudCgpLCBjbG9jay56b25lKCkpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUuX29mRXBvY2hNaWxsaXMgPSBmdW5jdGlvbiBfb2ZFcG9jaE1pbGxpcyhlcG9jaE1pbGxpLCBvZmZzZXQpIHtcbiAgICB2YXIgbG9jYWxTZWNvbmQgPSBNYXRoVXRpbC5mbG9vckRpdihlcG9jaE1pbGxpLCAxMDAwKSArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgbG9jYWxFcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gTWF0aFV0aWwuZmxvb3JNb2QobG9jYWxTZWNvbmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHZhciBuYW5vT2ZTZWNvbmQgPSBNYXRoVXRpbC5mbG9vck1vZChlcG9jaE1pbGxpLCAxMDAwKSAqIDEwMDAwMDA7XG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2ZFcG9jaERheShsb2NhbEVwb2NoRGF5KTtcbiAgICB2YXIgdGltZSA9IExvY2FsVGltZS5vZlNlY29uZE9mRGF5KHNlY3NPZkRheSwgbmFub09mU2Vjb25kKTtcbiAgICByZXR1cm4gbmV3IExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSk7XG4gIH07XG5cbiAgTG9jYWxEYXRlVGltZS5vZiA9IGZ1bmN0aW9uIG9mKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2ZOdW1iZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZOdW1iZXJzID0gZnVuY3Rpb24gb2ZOdW1iZXJzKHllYXIsIG1vbnRoLCBkYXlPZk1vbnRoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKGhvdXIgPT09IHZvaWQgMCkge1xuICAgICAgaG91ciA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG1pbnV0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW51dGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRhdGUgPSBMb2NhbERhdGUub2YoeWVhciwgbW9udGgsIGRheU9mTW9udGgpO1xuICAgIHZhciB0aW1lID0gTG9jYWxUaW1lLm9mKGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgfTtcblxuICBMb2NhbERhdGVUaW1lLm9mRGF0ZUFuZFRpbWUgPSBmdW5jdGlvbiBvZkRhdGVBbmRUaW1lKGRhdGUsIHRpbWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChkYXRlLCAnZGF0ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHRpbWUsICd0aW1lJyk7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKGRhdGUsIHRpbWUpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZJbnN0YW50ID0gZnVuY3Rpb24gb2ZJbnN0YW50KGluc3RhbnQsIHpvbmUpIHtcbiAgICBpZiAoem9uZSA9PT0gdm9pZCAwKSB7XG4gICAgICB6b25lID0gWm9uZUlkLnN5c3RlbURlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChpbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShpbnN0YW50LCBJbnN0YW50LCAnaW5zdGFudCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKHpvbmUsICd6b25lJyk7XG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgcmV0dXJuIExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIGluc3RhbnQubmFubygpLCBvZmZzZXQpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUub2ZFcG9jaFNlY29uZCA9IGZ1bmN0aW9uIG9mRXBvY2hTZWNvbmQoZXBvY2hTZWNvbmQsIG5hbm9PZlNlY29uZCwgb2Zmc2V0KSB7XG4gICAgaWYgKGVwb2NoU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIGVwb2NoU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgbmFub09mU2Vjb25kIGluc3RhbmNlb2YgWm9uZU9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbmFub09mU2Vjb25kO1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChvZmZzZXQsICdvZmZzZXQnKTtcbiAgICB2YXIgbG9jYWxTZWNvbmQgPSBlcG9jaFNlY29uZCArIG9mZnNldC50b3RhbFNlY29uZHMoKTtcbiAgICB2YXIgbG9jYWxFcG9jaERheSA9IE1hdGhVdGlsLmZsb29yRGl2KGxvY2FsU2Vjb25kLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKTtcbiAgICB2YXIgc2Vjc09mRGF5ID0gTWF0aFV0aWwuZmxvb3JNb2QobG9jYWxTZWNvbmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHZhciBkYXRlID0gTG9jYWxEYXRlLm9mRXBvY2hEYXkobG9jYWxFcG9jaERheSk7XG4gICAgdmFyIHRpbWUgPSBMb2NhbFRpbWUub2ZTZWNvbmRPZkRheShzZWNzT2ZEYXksIG5hbm9PZlNlY29uZCk7XG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKGRhdGUsIHRpbWUpO1xuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGVtcG9yYWwpIHtcbiAgICByZXF1aXJlTm9uTnVsbCh0ZW1wb3JhbCwgJ3RlbXBvcmFsJyk7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGVtcG9yYWw7XG4gICAgfSBlbHNlIGlmICh0ZW1wb3JhbCBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUpIHtcbiAgICAgIHJldHVybiB0ZW1wb3JhbC50b0xvY2FsRGF0ZVRpbWUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIGRhdGUgPSBMb2NhbERhdGUuZnJvbSh0ZW1wb3JhbCk7XG4gICAgICB2YXIgdGltZSA9IExvY2FsVGltZS5mcm9tKHRlbXBvcmFsKTtcbiAgICAgIHJldHVybiBuZXcgTG9jYWxEYXRlVGltZShkYXRlLCB0aW1lKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBMb2NhbERhdGVUaW1lIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuICB9O1xuXG4gIExvY2FsRGF0ZVRpbWUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmb3JtYXR0ZXIpIHtcbiAgICBpZiAoZm9ybWF0dGVyID09PSB2b2lkIDApIHtcbiAgICAgIGZvcm1hdHRlciA9IERhdGVUaW1lRm9ybWF0dGVyLklTT19MT0NBTF9EQVRFX1RJTUU7XG4gICAgfVxuXG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5wYXJzZSh0ZXh0LCBMb2NhbERhdGVUaW1lLkZST00pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExvY2FsRGF0ZVRpbWUoZGF0ZSwgdGltZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Nocm9ub0xvY2FsRGF0ZVRpbWUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIHJlcXVpcmVJbnN0YW5jZShkYXRlLCBMb2NhbERhdGUsICdkYXRlJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKHRpbWUsIExvY2FsVGltZSwgJ3RpbWUnKTtcbiAgICBfdGhpcy5fZGF0ZSA9IGRhdGU7XG4gICAgX3RoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMb2NhbERhdGVUaW1lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3dpdGhEYXRlVGltZSA9IGZ1bmN0aW9uIF93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgbmV3VGltZSkge1xuICAgIGlmICh0aGlzLl9kYXRlLmVxdWFscyhuZXdEYXRlKSAmJiB0aGlzLl90aW1lLmVxdWFscyhuZXdUaW1lKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhbERhdGVUaW1lKG5ld0RhdGUsIG5ld1RpbWUpO1xuICB9O1xuXG4gIF9wcm90by5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKGZpZWxkT3JVbml0KSB7XG4gICAgaWYgKGZpZWxkT3JVbml0IGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc0RhdGVCYXNlZCgpIHx8IGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGQuaXNUaW1lQmFzZWQoKSA/IHRoaXMuX3RpbWUucmFuZ2UoZmllbGQpIDogdGhpcy5fZGF0ZS5yYW5nZShmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLnJhbmdlUmVmaW5lZEJ5KHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkLmlzVGltZUJhc2VkKCkgPyB0aGlzLl90aW1lLmdldChmaWVsZCkgOiB0aGlzLl9kYXRlLmdldChmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldExvbmcgPSBmdW5jdGlvbiBnZXRMb25nKGZpZWxkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIHJldHVybiBmaWVsZC5pc1RpbWVCYXNlZCgpID8gdGhpcy5fdGltZS5nZXRMb25nKGZpZWxkKSA6IHRoaXMuX2RhdGUuZ2V0TG9uZyhmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnllYXIgPSBmdW5jdGlvbiB5ZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLnllYXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubW9udGhWYWx1ZSA9IGZ1bmN0aW9uIG1vbnRoVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUubW9udGhWYWx1ZSgpO1xuICB9O1xuXG4gIF9wcm90by5tb250aCA9IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLm1vbnRoKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRheU9mTW9udGggPSBmdW5jdGlvbiBkYXlPZk1vbnRoKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLmRheU9mTW9udGgoKTtcbiAgfTtcblxuICBfcHJvdG8uZGF5T2ZZZWFyID0gZnVuY3Rpb24gZGF5T2ZZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlLmRheU9mWWVhcigpO1xuICB9O1xuXG4gIF9wcm90by5kYXlPZldlZWsgPSBmdW5jdGlvbiBkYXlPZldlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuZGF5T2ZXZWVrKCk7XG4gIH07XG5cbiAgX3Byb3RvLmhvdXIgPSBmdW5jdGlvbiBob3VyKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLmhvdXIoKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXRlID0gZnVuY3Rpb24gbWludXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm1pbnV0ZSgpO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmQgPSBmdW5jdGlvbiBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUuc2Vjb25kKCk7XG4gIH07XG5cbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lLm5hbm8oKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhBZGp1c3RlciA9IGZ1bmN0aW9uIF93aXRoQWRqdXN0ZXIoYWRqdXN0ZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChhZGp1c3RlciwgJ2FkanVzdGVyJyk7XG5cbiAgICBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUoYWRqdXN0ZXIsIHRoaXMuX3RpbWUpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbFRpbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgYWRqdXN0ZXIpO1xuICAgIH0gZWxzZSBpZiAoYWRqdXN0ZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gYWRqdXN0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5fd2l0aEFkanVzdGVyLmNhbGwodGhpcywgYWRqdXN0ZXIpO1xuICB9O1xuXG4gIF9wcm90by5fd2l0aEZpZWxkID0gZnVuY3Rpb24gX3dpdGhGaWVsZChmaWVsZCwgbmV3VmFsdWUpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgaWYgKGZpZWxkLmlzVGltZUJhc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLCB0aGlzLl90aW1lLndpdGgoZmllbGQsIG5ld1ZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUud2l0aChmaWVsZCwgbmV3VmFsdWUpLCB0aGlzLl90aW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhZZWFyID0gZnVuY3Rpb24gd2l0aFllYXIoeWVhcikge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoWWVhcih5ZWFyKSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNb250aCA9IGZ1bmN0aW9uIHdpdGhNb250aChtb250aCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZS53aXRoTW9udGgobW9udGgpLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mTW9udGggPSBmdW5jdGlvbiB3aXRoRGF5T2ZNb250aChkYXlPZk1vbnRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhEYXlPZk1vbnRoKGRheU9mTW9udGgpLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aERheU9mWWVhciA9IGZ1bmN0aW9uIHdpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLndpdGhEYXlPZlllYXIoZGF5T2ZZZWFyKSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhIb3VyID0gZnVuY3Rpb24gd2l0aEhvdXIoaG91cikge1xuICAgIHZhciBuZXdUaW1lID0gdGhpcy5fdGltZS53aXRoSG91cihob3VyKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhNaW51dGUgPSBmdW5jdGlvbiB3aXRoTWludXRlKG1pbnV0ZSkge1xuICAgIHZhciBuZXdUaW1lID0gdGhpcy5fdGltZS53aXRoTWludXRlKG1pbnV0ZSk7XG5cbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKHRoaXMuX2RhdGUsIG5ld1RpbWUpO1xuICB9O1xuXG4gIF9wcm90by53aXRoU2Vjb25kID0gZnVuY3Rpb24gd2l0aFNlY29uZChzZWNvbmQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aFNlY29uZChzZWNvbmQpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLCBuZXdUaW1lKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vT2ZTZWNvbmQpIHtcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuX3RpbWUud2l0aE5hbm8obmFub09mU2Vjb25kKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgbmV3VGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUodGhpcy5fZGF0ZSwgdGhpcy5fdGltZS50cnVuY2F0ZWRUbyh1bml0KSk7XG4gIH07XG5cbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG5cbiAgICBpZiAodW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICBjYXNlIENocm9ub1VuaXQuTkFOT1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlDUk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JQ1JPU19QRVJfREFZKSkucGx1c05hbm9zKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JQ1JPU19QRVJfREFZKSAqIDEwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0RheXMoTWF0aFV0aWwuaW50RGl2KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpKS5wbHVzTmFub3MoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpICogMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSU5VVEVTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaW51dGVzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNEYXlzKE1hdGhVdGlsLmludERpdihhbW91bnRUb0FkZCwgMjU2KSkucGx1c0hvdXJzKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgMjU2KSAqIDEyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZSh0aGlzLl9kYXRlLnBsdXMoYW1vdW50VG9BZGQsIHVuaXQpLCB0aGlzLl90aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNZZWFycyA9IGZ1bmN0aW9uIHBsdXNZZWFycyh5ZWFycykge1xuICAgIHZhciBuZXdEYXRlID0gdGhpcy5fZGF0ZS5wbHVzWWVhcnMoeWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZShuZXdEYXRlLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c01vbnRocyA9IGZ1bmN0aW9uIHBsdXNNb250aHMobW9udGhzKSB7XG4gICAgdmFyIG5ld0RhdGUgPSB0aGlzLl9kYXRlLnBsdXNNb250aHMobW9udGhzKTtcblxuICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNXZWVrcyA9IGZ1bmN0aW9uIHBsdXNXZWVrcyh3ZWVrcykge1xuICAgIHZhciBuZXdEYXRlID0gdGhpcy5fZGF0ZS5wbHVzV2Vla3Mod2Vla3MpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZShuZXdEYXRlLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0RheXMgPSBmdW5jdGlvbiBwbHVzRGF5cyhkYXlzKSB7XG4gICAgdmFyIG5ld0RhdGUgPSB0aGlzLl9kYXRlLnBsdXNEYXlzKGRheXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3dpdGhEYXRlVGltZShuZXdEYXRlLCB0aGlzLl90aW1lKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c0hvdXJzID0gZnVuY3Rpb24gcGx1c0hvdXJzKGhvdXJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgaG91cnMsIDAsIDAsIDAsIDEpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWludXRlcyA9IGZ1bmN0aW9uIHBsdXNNaW51dGVzKG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCBtaW51dGVzLCAwLCAwLCAxKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgMCwgc2Vjb25kcywgMCwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIDAsIDAsIG5hbm9zLCAxKTtcbiAgfTtcblxuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzWWVhcnMgPSBmdW5jdGlvbiBtaW51c1llYXJzKHllYXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1c1llYXJzKC0xICogeWVhcnMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01vbnRocyA9IGZ1bmN0aW9uIG1pbnVzTW9udGhzKG1vbnRocykge1xuICAgIHJldHVybiB0aGlzLnBsdXNNb250aHMoLTEgKiBtb250aHMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1dlZWtzID0gZnVuY3Rpb24gbWludXNXZWVrcyh3ZWVrcykge1xuICAgIHJldHVybiB0aGlzLnBsdXNXZWVrcygtMSAqIHdlZWtzKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNEYXlzID0gZnVuY3Rpb24gbWludXNEYXlzKGRheXMpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzRGF5cygtMSAqIGRheXMpO1xuICB9O1xuXG4gIF9wcm90by5taW51c0hvdXJzID0gZnVuY3Rpb24gbWludXNIb3Vycyhob3Vycykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIGhvdXJzLCAwLCAwLCAwLCAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNXaXRoT3ZlcmZsb3codGhpcy5fZGF0ZSwgMCwgbWludXRlcywgMCwgMCwgLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c1NlY29uZHMgPSBmdW5jdGlvbiBtaW51c1NlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiB0aGlzLl9wbHVzV2l0aE92ZXJmbG93KHRoaXMuX2RhdGUsIDAsIDAsIHNlY29uZHMsIDAsIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ubWludXNOYW5vcyA9IGZ1bmN0aW9uIG1pbnVzTmFub3MobmFub3MpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1c1dpdGhPdmVyZmxvdyh0aGlzLl9kYXRlLCAwLCAwLCAwLCBuYW5vcywgLTEpO1xuICB9O1xuXG4gIF9wcm90by5fcGx1c1dpdGhPdmVyZmxvdyA9IGZ1bmN0aW9uIF9wbHVzV2l0aE92ZXJmbG93KG5ld0RhdGUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBuYW5vcywgc2lnbikge1xuICAgIGlmIChob3VycyA9PT0gMCAmJiBtaW51dGVzID09PSAwICYmIHNlY29uZHMgPT09IDAgJiYgbmFub3MgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl93aXRoRGF0ZVRpbWUobmV3RGF0ZSwgdGhpcy5fdGltZSk7XG4gICAgfVxuXG4gICAgdmFyIHRvdERheXMgPSBNYXRoVXRpbC5pbnREaXYobmFub3MsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSArIE1hdGhVdGlsLmludERpdihzZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSArIE1hdGhVdGlsLmludERpdihtaW51dGVzLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKSArIE1hdGhVdGlsLmludERpdihob3VycywgTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVkpO1xuICAgIHRvdERheXMgKj0gc2lnbjtcbiAgICB2YXIgdG90TmFub3MgPSBNYXRoVXRpbC5pbnRNb2QobmFub3MsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSArIE1hdGhVdGlsLmludE1vZChzZWNvbmRzLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSAqIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EICsgTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXMsIExvY2FsVGltZS5NSU5VVEVTX1BFUl9EQVkpICogTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUgKyBNYXRoVXRpbC5pbnRNb2QoaG91cnMsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKSAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUjtcblxuICAgIHZhciBjdXJOb0QgPSB0aGlzLl90aW1lLnRvTmFub09mRGF5KCk7XG5cbiAgICB0b3ROYW5vcyA9IHRvdE5hbm9zICogc2lnbiArIGN1ck5vRDtcbiAgICB0b3REYXlzICs9IE1hdGhVdGlsLmZsb29yRGl2KHRvdE5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSk7XG4gICAgdmFyIG5ld05vRCA9IE1hdGhVdGlsLmZsb29yTW9kKHRvdE5hbm9zLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSk7XG4gICAgdmFyIG5ld1RpbWUgPSBuZXdOb0QgPT09IGN1ck5vRCA/IHRoaXMuX3RpbWUgOiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3Tm9EKTtcbiAgICByZXR1cm4gdGhpcy5fd2l0aERhdGVUaW1lKG5ld0RhdGUucGx1c0RheXModG90RGF5cyksIG5ld1RpbWUpO1xuICB9O1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvTG9jYWxEYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIF9xdWVyeSk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIF9DaHJvbm9Mb2NhbERhdGVUaW1lLnByb3RvdHlwZS5hZGp1c3RJbnRvLmNhbGwodGhpcywgdGVtcG9yYWwpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgdmFyIGVuZCA9IExvY2FsRGF0ZVRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBpZiAodW5pdC5pc1RpbWVCYXNlZCgpKSB7XG4gICAgICAgIHZhciBkYXlzVW50aWwgPSB0aGlzLl9kYXRlLmRheXNVbnRpbChlbmQuX2RhdGUpO1xuXG4gICAgICAgIHZhciB0aW1lVW50aWwgPSBlbmQuX3RpbWUudG9OYW5vT2ZEYXkoKSAtIHRoaXMuX3RpbWUudG9OYW5vT2ZEYXkoKTtcblxuICAgICAgICBpZiAoZGF5c1VudGlsID4gMCAmJiB0aW1lVW50aWwgPCAwKSB7XG4gICAgICAgICAgZGF5c1VudGlsLS07XG4gICAgICAgICAgdGltZVVudGlsICs9IExvY2FsVGltZS5OQU5PU19QRVJfREFZO1xuICAgICAgICB9IGVsc2UgaWYgKGRheXNVbnRpbCA8IDAgJiYgdGltZVVudGlsID4gMCkge1xuICAgICAgICAgIGRheXNVbnRpbCsrO1xuICAgICAgICAgIHRpbWVVbnRpbCAtPSBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbW91bnQgPSBkYXlzVW50aWw7XG5cbiAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCB0aW1lVW50aWwpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5NSUNST1NfUEVSX0RBWSk7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZChhbW91bnQsIE1hdGhVdGlsLmludERpdih0aW1lVW50aWwsIDEwMDApKTtcblxuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuTUlMTElTX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCAxMDAwMDAwKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuU0VDT05EUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQoYW1vdW50LCBNYXRoVXRpbC5pbnREaXYodGltZVVudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCkpO1xuXG4gICAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgICBhbW91bnQgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50LCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUpKTtcblxuICAgICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IT1VSUzpcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnQsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKGFtb3VudCwgTWF0aFV0aWwuaW50RGl2KHRpbWVVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKSk7XG5cbiAgICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudCwgMik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuc2FmZUFkZChhbW91bnQsIE1hdGhVdGlsLmludERpdih0aW1lVW50aWwsIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUiAqIDEyKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kRGF0ZSA9IGVuZC5fZGF0ZTtcbiAgICAgIHZhciBlbmRUaW1lID0gZW5kLl90aW1lO1xuXG4gICAgICBpZiAoZW5kRGF0ZS5pc0FmdGVyKHRoaXMuX2RhdGUpICYmIGVuZFRpbWUuaXNCZWZvcmUodGhpcy5fdGltZSkpIHtcbiAgICAgICAgZW5kRGF0ZSA9IGVuZERhdGUubWludXNEYXlzKDEpO1xuICAgICAgfSBlbHNlIGlmIChlbmREYXRlLmlzQmVmb3JlKHRoaXMuX2RhdGUpICYmIGVuZFRpbWUuaXNBZnRlcih0aGlzLl90aW1lKSkge1xuICAgICAgICBlbmREYXRlID0gZW5kRGF0ZS5wbHVzRGF5cygxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGUudW50aWwoZW5kRGF0ZSwgdW5pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuaXQuYmV0d2Vlbih0aGlzLCBlbmQpO1xuICB9O1xuXG4gIF9wcm90by5hdE9mZnNldCA9IGZ1bmN0aW9uIGF0T2Zmc2V0KG9mZnNldCkge1xuICAgIHJldHVybiBPZmZzZXREYXRlVGltZS5vZih0aGlzLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5hdFpvbmUgPSBmdW5jdGlvbiBhdFpvbmUoem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mKHRoaXMsIHpvbmUpO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsRGF0ZSA9IGZ1bmN0aW9uIHRvTG9jYWxEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICB9O1xuXG4gIF9wcm90by50b0xvY2FsVGltZSA9IGZ1bmN0aW9uIHRvTG9jYWxUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl90aW1lO1xuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXF1aXJlTm9uTnVsbChvdGhlciwgJ290aGVyJyk7XG4gICAgcmVxdWlyZUluc3RhbmNlKG90aGVyLCBMb2NhbERhdGVUaW1lLCAnb3RoZXInKTtcbiAgICByZXR1cm4gdGhpcy5fY29tcGFyZVRvMChvdGhlcik7XG4gIH07XG5cbiAgX3Byb3RvLl9jb21wYXJlVG8wID0gZnVuY3Rpb24gX2NvbXBhcmVUbzAob3RoZXIpIHtcbiAgICB2YXIgY21wID0gdGhpcy5fZGF0ZS5jb21wYXJlVG8ob3RoZXIudG9Mb2NhbERhdGUoKSk7XG5cbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICBjbXAgPSB0aGlzLl90aW1lLmNvbXBhcmVUbyhvdGhlci50b0xvY2FsVGltZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY21wO1xuICB9O1xuXG4gIF9wcm90by5pc0FmdGVyID0gZnVuY3Rpb24gaXNBZnRlcihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPiAwO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gIH07XG5cbiAgX3Byb3RvLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZS5lcXVhbHMob3RoZXIuX2RhdGUpICYmIHRoaXMuX3RpbWUuZXF1YWxzKG90aGVyLl90aW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGUuaGFzaENvZGUoKSBeIHRoaXMuX3RpbWUuaGFzaENvZGUoKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZS50b1N0cmluZygpICsgXCJUXCIgKyB0aGlzLl90aW1lLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIExvY2FsRGF0ZVRpbWU7XG59KENocm9ub0xvY2FsRGF0ZVRpbWUpO1xuZnVuY3Rpb24gX2luaXQkNCgpIHtcbiAgTG9jYWxEYXRlVGltZS5NSU4gPSBMb2NhbERhdGVUaW1lLm9mKExvY2FsRGF0ZS5NSU4sIExvY2FsVGltZS5NSU4pO1xuICBMb2NhbERhdGVUaW1lLk1BWCA9IExvY2FsRGF0ZVRpbWUub2YoTG9jYWxEYXRlLk1BWCwgTG9jYWxUaW1lLk1BWCk7XG4gIExvY2FsRGF0ZVRpbWUuRlJPTSA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ0xvY2FsRGF0ZVRpbWUuRlJPTScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIHJldHVybiBMb2NhbERhdGVUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cblxudmFyIExvY2FsVGltZSA9IGZ1bmN0aW9uIChfVGVtcG9yYWwpIHtcbiAgX2luaGVyaXRzTG9vc2UoTG9jYWxUaW1lLCBfVGVtcG9yYWwpO1xuXG4gIExvY2FsVGltZS5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2tPclpvbmUpIHtcbiAgICBpZiAoY2xvY2tPclpvbmUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KENsb2NrLnN5c3RlbURlZmF1bHRab25lKCkpO1xuICAgIH0gZWxzZSBpZiAoY2xvY2tPclpvbmUgaW5zdGFuY2VvZiBDbG9jaykge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KGNsb2NrT3Jab25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsVGltZS5fbm93KENsb2NrLnN5c3RlbShjbG9ja09yWm9uZSkpO1xuICAgIH1cbiAgfTtcblxuICBMb2NhbFRpbWUuX25vdyA9IGZ1bmN0aW9uIF9ub3coY2xvY2spIHtcbiAgICBpZiAoY2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW1EZWZhdWx0Wm9uZSgpO1xuICAgIH1cblxuICAgIHJlcXVpcmVOb25OdWxsKGNsb2NrLCAnY2xvY2snKTtcbiAgICByZXR1cm4gTG9jYWxUaW1lLm9mSW5zdGFudChjbG9jay5pbnN0YW50KCksIGNsb2NrLnpvbmUoKSk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLm9mSW5zdGFudCA9IGZ1bmN0aW9uIG9mSW5zdGFudChpbnN0YW50LCB6b25lKSB7XG4gICAgaWYgKHpvbmUgPT09IHZvaWQgMCkge1xuICAgICAgem9uZSA9IFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldCA9IHpvbmUucnVsZXMoKS5vZmZzZXQoaW5zdGFudCk7XG4gICAgdmFyIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChpbnN0YW50LmVwb2NoU2Vjb25kKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgIHNlY3NPZkRheSA9IE1hdGhVdGlsLmludE1vZChzZWNzT2ZEYXkgKyBvZmZzZXQudG90YWxTZWNvbmRzKCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuXG4gICAgaWYgKHNlY3NPZkRheSA8IDApIHtcbiAgICAgIHNlY3NPZkRheSArPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZO1xuICAgIH1cblxuICAgIHJldHVybiBMb2NhbFRpbWUub2ZTZWNvbmRPZkRheShzZWNzT2ZEYXksIGluc3RhbnQubmFubygpKTtcbiAgfTtcblxuICBMb2NhbFRpbWUub2YgPSBmdW5jdGlvbiBvZihob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLm9mU2Vjb25kT2ZEYXkgPSBmdW5jdGlvbiBvZlNlY29uZE9mRGF5KHNlY29uZE9mRGF5LCBuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kT2ZEYXkgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kT2ZEYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChuYW5vT2ZTZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mU2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5TRUNPTkRfT0ZfREFZLmNoZWNrVmFsaWRWYWx1ZShzZWNvbmRPZkRheSk7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gICAgdmFyIGhvdXJzID0gTWF0aFV0aWwuaW50RGl2KHNlY29uZE9mRGF5LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUik7XG4gICAgc2Vjb25kT2ZEYXkgLT0gaG91cnMgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUjtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihzZWNvbmRPZkRheSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgc2Vjb25kT2ZEYXkgLT0gbWludXRlcyAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZE9mRGF5LCBuYW5vT2ZTZWNvbmQpO1xuICB9O1xuXG4gIExvY2FsVGltZS5vZk5hbm9PZkRheSA9IGZ1bmN0aW9uIG9mTmFub09mRGF5KG5hbm9PZkRheSkge1xuICAgIGlmIChuYW5vT2ZEYXkgPT09IHZvaWQgMCkge1xuICAgICAgbmFub09mRGF5ID0gMDtcbiAgICB9XG5cbiAgICBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWS5jaGVja1ZhbGlkVmFsdWUobmFub09mRGF5KTtcbiAgICB2YXIgaG91cnMgPSBNYXRoVXRpbC5pbnREaXYobmFub09mRGF5LCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgIG5hbm9PZkRheSAtPSBob3VycyAqIExvY2FsVGltZS5OQU5PU19QRVJfSE9VUjtcbiAgICB2YXIgbWludXRlcyA9IE1hdGhVdGlsLmludERpdihuYW5vT2ZEYXksIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKTtcbiAgICBuYW5vT2ZEYXkgLT0gbWludXRlcyAqIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFO1xuICAgIHZhciBzZWNvbmRzID0gTWF0aFV0aWwuaW50RGl2KG5hbm9PZkRheSwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIG5hbm9PZkRheSAtPSBzZWNvbmRzICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG5hbm9PZkRheSk7XG4gIH07XG5cbiAgTG9jYWxUaW1lLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHZhciB0aW1lID0gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKTtcblxuICAgIGlmICh0aW1lID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gTG9jYWxUaW1lIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArICh0ZW1wb3JhbC5jb25zdHJ1Y3RvciAhPSBudWxsID8gdGVtcG9yYWwuY29uc3RydWN0b3IubmFtZSA6ICcnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWU7XG4gIH07XG5cbiAgTG9jYWxUaW1lLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgZm9ybWF0dGVyKSB7XG4gICAgaWYgKGZvcm1hdHRlciA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JtYXR0ZXIgPSBEYXRlVGltZUZvcm1hdHRlci5JU09fTE9DQUxfVElNRTtcbiAgICB9XG5cbiAgICByZXF1aXJlTm9uTnVsbChmb3JtYXR0ZXIsICdmb3JtYXR0ZXInKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnBhcnNlKHRleHQsIExvY2FsVGltZS5GUk9NKTtcbiAgfTtcblxuICBmdW5jdGlvbiBMb2NhbFRpbWUoaG91ciwgbWludXRlLCBzZWNvbmQsIG5hbm9PZlNlY29uZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChob3VyID09PSB2b2lkIDApIHtcbiAgICAgIGhvdXIgPSAwO1xuICAgIH1cblxuICAgIGlmIChtaW51dGUgPT09IHZvaWQgMCkge1xuICAgICAgbWludXRlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIHNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG5hbm9PZlNlY29uZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuYW5vT2ZTZWNvbmQgPSAwO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RlbXBvcmFsLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIHZhciBfaG91ciA9IE1hdGhVdGlsLnNhZmVUb0ludChob3VyKTtcblxuICAgIHZhciBfbWludXRlID0gTWF0aFV0aWwuc2FmZVRvSW50KG1pbnV0ZSk7XG5cbiAgICB2YXIgX3NlY29uZCA9IE1hdGhVdGlsLnNhZmVUb0ludChzZWNvbmQpO1xuXG4gICAgdmFyIF9uYW5vT2ZTZWNvbmQgPSBNYXRoVXRpbC5zYWZlVG9JbnQobmFub09mU2Vjb25kKTtcblxuICAgIExvY2FsVGltZS5fdmFsaWRhdGUoX2hvdXIsIF9taW51dGUsIF9zZWNvbmQsIF9uYW5vT2ZTZWNvbmQpO1xuXG4gICAgaWYgKF9taW51dGUgPT09IDAgJiYgX3NlY29uZCA9PT0gMCAmJiBfbmFub09mU2Vjb25kID09PSAwKSB7XG4gICAgICBpZiAoIUxvY2FsVGltZS5IT1VSU1tfaG91cl0pIHtcbiAgICAgICAgX3RoaXMuX2hvdXIgPSBfaG91cjtcbiAgICAgICAgX3RoaXMuX21pbnV0ZSA9IF9taW51dGU7XG4gICAgICAgIF90aGlzLl9zZWNvbmQgPSBfc2Vjb25kO1xuICAgICAgICBfdGhpcy5fbmFubyA9IF9uYW5vT2ZTZWNvbmQ7XG4gICAgICAgIExvY2FsVGltZS5IT1VSU1tfaG91cl0gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIExvY2FsVGltZS5IT1VSU1tfaG91cl0gfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyk7XG4gICAgfVxuXG4gICAgX3RoaXMuX2hvdXIgPSBfaG91cjtcbiAgICBfdGhpcy5fbWludXRlID0gX21pbnV0ZTtcbiAgICBfdGhpcy5fc2Vjb25kID0gX3NlY29uZDtcbiAgICBfdGhpcy5fbmFubyA9IF9uYW5vT2ZTZWNvbmQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgTG9jYWxUaW1lLl92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZShob3VyLCBtaW51dGUsIHNlY29uZCwgbmFub09mU2Vjb25kKSB7XG4gICAgQ2hyb25vRmllbGQuSE9VUl9PRl9EQVkuY2hlY2tWYWxpZFZhbHVlKGhvdXIpO1xuICAgIENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSLmNoZWNrVmFsaWRWYWx1ZShtaW51dGUpO1xuICAgIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEUuY2hlY2tWYWxpZFZhbHVlKHNlY29uZCk7XG4gICAgQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQuY2hlY2tWYWxpZFZhbHVlKG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IExvY2FsVGltZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGRPclVuaXQpIHtcbiAgICBpZiAoZmllbGRPclVuaXQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgcmV0dXJuIGZpZWxkT3JVbml0LmlzVGltZUJhc2VkKCk7XG4gICAgfSBlbHNlIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZE9yVW5pdCAhPSBudWxsICYmIGZpZWxkT3JVbml0LmlzU3VwcG9ydGVkQnkodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJhbmdlID0gZnVuY3Rpb24gcmFuZ2UoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCk7XG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUucmFuZ2UuY2FsbCh0aGlzLCBmaWVsZCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChmaWVsZCkge1xuICAgIHJldHVybiB0aGlzLmdldExvbmcoZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRMb25nID0gZnVuY3Rpb24gZ2V0TG9uZyhmaWVsZCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGZpZWxkLCAnZmllbGQnKTtcblxuICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0MChmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXQwID0gZnVuY3Rpb24gX2dldDAoZmllbGQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICByZXR1cm4gdGhpcy5fbmFubztcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5OQU5PX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9OYW5vT2ZEYXkoKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9TRUNPTkQ6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fbmFubywgMTAwMCk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfREFZOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMudG9OYW5vT2ZEYXkoKSwgMTAwMCk7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm8sIDEwMDAwMDApO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLnRvTmFub09mRGF5KCksIDEwMDAwMDApO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9NSU5VVEU6XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmQ7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuU0VDT05EX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TZWNvbmRPZkRheSgpO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9IT1VSOlxuICAgICAgICByZXR1cm4gdGhpcy5fbWludXRlO1xuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVk6XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3VyICogNjAgKyB0aGlzLl9taW51dGU7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuSE9VUl9PRl9BTVBNOlxuICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKTtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE06XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaGFtID0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKTtcbiAgICAgICAgICByZXR1cm4gaGFtICUgMTIgPT09IDAgPyAxMiA6IGhhbTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENocm9ub0ZpZWxkLkhPVVJfT0ZfREFZOlxuICAgICAgICByZXR1cm4gdGhpcy5faG91cjtcblxuICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvdXIgPT09IDAgPyAyNCA6IHRoaXMuX2hvdXI7XG5cbiAgICAgIGNhc2UgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk6XG4gICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5faG91ciwgMTIpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uaG91ciA9IGZ1bmN0aW9uIGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvdXI7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnV0ZSA9IGZ1bmN0aW9uIG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludXRlO1xuICB9O1xuXG4gIF9wcm90by5zZWNvbmQgPSBmdW5jdGlvbiBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZDtcbiAgfTtcblxuICBfcHJvdG8ubmFubyA9IGZ1bmN0aW9uIG5hbm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbm87XG4gIH07XG5cbiAgX3Byb3RvLl93aXRoQWRqdXN0ZXIgPSBmdW5jdGlvbiBfd2l0aEFkanVzdGVyKGFkanVzdGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoYWRqdXN0ZXIsICdhZGp1c3RlcicpO1xuXG4gICAgaWYgKGFkanVzdGVyIGluc3RhbmNlb2YgTG9jYWxUaW1lKSB7XG4gICAgICByZXR1cm4gYWRqdXN0ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9UZW1wb3JhbC5wcm90b3R5cGUuX3dpdGhBZGp1c3Rlci5jYWxsKHRoaXMsIGFkanVzdGVyKTtcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShmaWVsZCwgVGVtcG9yYWxGaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgZmllbGQuY2hlY2tWYWxpZFZhbHVlKG5ld1ZhbHVlKTtcblxuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfREFZOlxuICAgICAgICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkobmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlICogMTAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUNST19PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheShuZXdWYWx1ZSAqIDEwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLndpdGhOYW5vKG5ld1ZhbHVlICogMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheShuZXdWYWx1ZSAqIDEwMDAwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuU0VDT05EX09GX01JTlVURTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoU2Vjb25kKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLlNFQ09ORF9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMobmV3VmFsdWUgLSB0aGlzLnRvU2Vjb25kT2ZEYXkoKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSU5VVEVfT0ZfSE9VUjpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoTWludXRlKG5ld1ZhbHVlKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTlVURV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c01pbnV0ZXMobmV3VmFsdWUgLSAodGhpcy5faG91ciAqIDYwICsgdGhpcy5fbWludXRlKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0FNUE06XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKG5ld1ZhbHVlIC0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0FNUE06XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKChuZXdWYWx1ZSA9PT0gMTIgPyAwIDogbmV3VmFsdWUpIC0gTWF0aFV0aWwuaW50TW9kKHRoaXMuX2hvdXIsIDEyKSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5IT1VSX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSG91cihuZXdWYWx1ZSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5DTE9DS19IT1VSX09GX0RBWTpcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoSG91cihuZXdWYWx1ZSA9PT0gMjQgPyAwIDogbmV3VmFsdWUpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuQU1QTV9PRl9EQVk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c0hvdXJzKChuZXdWYWx1ZSAtIE1hdGhVdGlsLmludERpdih0aGlzLl9ob3VyLCAxMikpICogMTIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmFkanVzdEludG8odGhpcywgbmV3VmFsdWUpO1xuICB9O1xuXG4gIF9wcm90by53aXRoSG91ciA9IGZ1bmN0aW9uIHdpdGhIb3VyKGhvdXIpIHtcbiAgICBpZiAoaG91ciA9PT0gdm9pZCAwKSB7XG4gICAgICBob3VyID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faG91ciA9PT0gaG91cikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUoaG91ciwgdGhpcy5fbWludXRlLCB0aGlzLl9zZWNvbmQsIHRoaXMuX25hbm8pO1xuICB9O1xuXG4gIF9wcm90by53aXRoTWludXRlID0gZnVuY3Rpb24gd2l0aE1pbnV0ZShtaW51dGUpIHtcbiAgICBpZiAobWludXRlID09PSB2b2lkIDApIHtcbiAgICAgIG1pbnV0ZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21pbnV0ZSA9PT0gbWludXRlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExvY2FsVGltZSh0aGlzLl9ob3VyLCBtaW51dGUsIHRoaXMuX3NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLndpdGhTZWNvbmQgPSBmdW5jdGlvbiB3aXRoU2Vjb25kKHNlY29uZCkge1xuICAgIGlmIChzZWNvbmQgPT09IHZvaWQgMCkge1xuICAgICAgc2Vjb25kID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2Vjb25kID09PSBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKHRoaXMuX2hvdXIsIHRoaXMuX21pbnV0ZSwgc2Vjb25kLCB0aGlzLl9uYW5vKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aE5hbm8gPSBmdW5jdGlvbiB3aXRoTmFubyhuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAobmFub09mU2Vjb25kID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9PZlNlY29uZCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX25hbm8gPT09IG5hbm9PZlNlY29uZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBMb2NhbFRpbWUodGhpcy5faG91ciwgdGhpcy5fbWludXRlLCB0aGlzLl9zZWNvbmQsIG5hbm9PZlNlY29uZCk7XG4gIH07XG5cbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG5cbiAgICBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5OQU5PUykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHVuaXREdXIgPSB1bml0LmR1cmF0aW9uKCk7XG5cbiAgICBpZiAodW5pdER1ci5zZWNvbmRzKCkgPiBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgaXMgdG9vIGxhcmdlIHRvIGJlIHVzZWQgZm9yIHRydW5jYXRpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyID0gdW5pdER1ci50b05hbm9zKCk7XG5cbiAgICBpZiAoTWF0aFV0aWwuaW50TW9kKExvY2FsVGltZS5OQU5PU19QRVJfREFZLCBkdXIpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgbXVzdCBkaXZpZGUgaW50byBhIHN0YW5kYXJkIGRheSB3aXRob3V0IHJlbWFpbmRlcicpO1xuICAgIH1cblxuICAgIHZhciBub2QgPSB0aGlzLnRvTmFub09mRGF5KCk7XG4gICAgcmV0dXJuIExvY2FsVGltZS5vZk5hbm9PZkRheShNYXRoVXRpbC5pbnREaXYobm9kLCBkdXIpICogZHVyKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXNVbml0ID0gZnVuY3Rpb24gX3BsdXNVbml0KGFtb3VudFRvQWRkLCB1bml0KSB7XG4gICAgcmVxdWlyZU5vbk51bGwodW5pdCwgJ3VuaXQnKTtcblxuICAgIGlmICh1bml0IGluc3RhbmNlb2YgQ2hyb25vVW5pdCkge1xuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5OQU5PUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTmFub3MoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JQ1JPU19QRVJfREFZKSAqIDEwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUxMSVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKE1hdGhVdGlsLmludE1vZChhbW91bnRUb0FkZCwgTG9jYWxUaW1lLk1JTExJU19QRVJfREFZKSAqIDEwMDAwMDApO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWludXRlcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNIb3VycyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhBTEZfREFZUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzSG91cnMoTWF0aFV0aWwuaW50TW9kKGFtb3VudFRvQWRkLCAyKSAqIDEyKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uKFwiVW5zdXBwb3J0ZWQgdW5pdDogXCIgKyB1bml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdC5hZGRUbyh0aGlzLCBhbW91bnRUb0FkZCk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNIb3VycyA9IGZ1bmN0aW9uIHBsdXNIb3Vycyhob3Vyc1RvQWRkKSB7XG4gICAgaWYgKGhvdXJzVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBuZXdIb3VyID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludE1vZChob3Vyc1RvQWRkLCBMb2NhbFRpbWUuSE9VUlNfUEVSX0RBWSkgKyB0aGlzLl9ob3VyICsgTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVksIExvY2FsVGltZS5IT1VSU19QRVJfREFZKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCB0aGlzLl9taW51dGUsIHRoaXMuX3NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNNaW51dGVzID0gZnVuY3Rpb24gcGx1c01pbnV0ZXMobWludXRlc1RvQWRkKSB7XG4gICAgaWYgKG1pbnV0ZXNUb0FkZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1vZmQgPSB0aGlzLl9ob3VyICogTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIgKyB0aGlzLl9taW51dGU7XG4gICAgdmFyIG5ld01vZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXNUb0FkZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSkgKyBtb2ZkICsgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSk7XG5cbiAgICBpZiAobW9mZCA9PT0gbmV3TW9mZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3TW9mZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QobmV3TW9mZCwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKG5ld0hvdXIsIG5ld01pbnV0ZSwgdGhpcy5fc2Vjb25kLCB0aGlzLl9uYW5vKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzVG9BZGQpIHtcbiAgICBpZiAoc2Vjb25kc1RvQWRkID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgc29mZCA9IHRoaXMuX2hvdXIgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiArIHRoaXMuX21pbnV0ZSAqIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUgKyB0aGlzLl9zZWNvbmQ7XG4gICAgdmFyIG5ld1NvZmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50TW9kKHNlY29uZHNUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKyBzb2ZkICsgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSk7XG5cbiAgICBpZiAoc29mZCA9PT0gbmV3U29mZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hvdXIgPSBNYXRoVXRpbC5pbnREaXYobmV3U29mZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld1NvZmQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpLCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUik7XG4gICAgdmFyIG5ld1NlY29uZCA9IE1hdGhVdGlsLmludE1vZChuZXdTb2ZkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICByZXR1cm4gbmV3IExvY2FsVGltZShuZXdIb3VyLCBuZXdNaW51dGUsIG5ld1NlY29uZCwgdGhpcy5fbmFubyk7XG4gIH07XG5cbiAgX3Byb3RvLnBsdXNOYW5vcyA9IGZ1bmN0aW9uIHBsdXNOYW5vcyhuYW5vc1RvQWRkKSB7XG4gICAgaWYgKG5hbm9zVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBub2ZkID0gdGhpcy50b05hbm9PZkRheSgpO1xuICAgIHZhciBuZXdOb2ZkID0gTWF0aFV0aWwuaW50TW9kKE1hdGhVdGlsLmludE1vZChuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0RBWSkgKyBub2ZkICsgTG9jYWxUaW1lLk5BTk9TX1BFUl9EQVksIExvY2FsVGltZS5OQU5PU19QRVJfREFZKTtcblxuICAgIGlmIChub2ZkID09PSBuZXdOb2ZkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3SG91ciA9IE1hdGhVdGlsLmludERpdihuZXdOb2ZkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdNaW51dGUgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld05vZmQsIExvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFKSwgTG9jYWxUaW1lLk1JTlVURVNfUEVSX0hPVVIpO1xuICAgIHZhciBuZXdTZWNvbmQgPSBNYXRoVXRpbC5pbnRNb2QoTWF0aFV0aWwuaW50RGl2KG5ld05vZmQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG4gICAgdmFyIG5ld05hbm8gPSBNYXRoVXRpbC5pbnRNb2QobmV3Tm9mZCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpO1xuICAgIHJldHVybiBuZXcgTG9jYWxUaW1lKG5ld0hvdXIsIG5ld01pbnV0ZSwgbmV3U2Vjb25kLCBuZXdOYW5vKTtcbiAgfTtcblxuICBfcHJvdG8uX21pbnVzVW5pdCA9IGZ1bmN0aW9uIF9taW51c1VuaXQoYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzSG91cnMgPSBmdW5jdGlvbiBtaW51c0hvdXJzKGhvdXJzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNIb3VycygtMSAqIE1hdGhVdGlsLmludE1vZChob3Vyc1RvU3VidHJhY3QsIExvY2FsVGltZS5IT1VSU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWludXRlcyA9IGZ1bmN0aW9uIG1pbnVzTWludXRlcyhtaW51dGVzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNaW51dGVzKC0xICogTWF0aFV0aWwuaW50TW9kKG1pbnV0ZXNUb1N1YnRyYWN0LCBMb2NhbFRpbWUuTUlOVVRFU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKC0xICogTWF0aFV0aWwuaW50TW9kKHNlY29uZHNUb1N1YnRyYWN0LCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcygtMSAqIE1hdGhVdGlsLmludE1vZChuYW5vc1RvU3VidHJhY3QsIExvY2FsVGltZS5OQU5PU19QRVJfREFZKSk7XG4gIH07XG5cbiAgX3Byb3RvLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkoX3F1ZXJ5KSB7XG4gICAgcmVxdWlyZU5vbk51bGwoX3F1ZXJ5LCAncXVlcnknKTtcblxuICAgIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5wcmVjaXNpb24oKSkge1xuICAgICAgcmV0dXJuIENocm9ub1VuaXQuTkFOT1M7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5sb2NhbFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmNocm9ub2xvZ3koKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lSWQoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMub2Zmc2V0KCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfcXVlcnkucXVlcnlGcm9tKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5hZGp1c3RJbnRvID0gZnVuY3Rpb24gYWRqdXN0SW50byh0ZW1wb3JhbCkge1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKExvY2FsVGltZS5OQU5PX09GX0RBWSwgdGhpcy50b05hbm9PZkRheSgpKTtcbiAgfTtcblxuICBfcHJvdG8udW50aWwgPSBmdW5jdGlvbiB1bnRpbChlbmRFeGNsdXNpdmUsIHVuaXQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChlbmRFeGNsdXNpdmUsICdlbmRFeGNsdXNpdmUnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHZhciBlbmQgPSBMb2NhbFRpbWUuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICB2YXIgbmFub3NVbnRpbCA9IGVuZC50b05hbm9PZkRheSgpIC0gdGhpcy50b05hbm9PZkRheSgpO1xuXG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiBuYW5vc1VudGlsO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5NSUNST1M6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgMTAwMDAwMCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LlNFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdihuYW5vc1VudGlsLCBMb2NhbFRpbWUuTkFOT1NfUEVSX01JTlVURSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYobmFub3NVbnRpbCwgMTIgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVIpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcblxuICBfcHJvdG8uYXREYXRlID0gZnVuY3Rpb24gYXREYXRlKGRhdGUpIHtcbiAgICByZXR1cm4gTG9jYWxEYXRlVGltZS5vZihkYXRlLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYXRPZmZzZXQgPSBmdW5jdGlvbiBhdE9mZnNldChvZmZzZXQpIHtcbiAgICByZXR1cm4gT2Zmc2V0VGltZS5vZih0aGlzLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by50b1NlY29uZE9mRGF5ID0gZnVuY3Rpb24gdG9TZWNvbmRPZkRheSgpIHtcbiAgICB2YXIgdG90YWwgPSB0aGlzLl9ob3VyICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVI7XG4gICAgdG90YWwgKz0gdGhpcy5fbWludXRlICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURTtcbiAgICB0b3RhbCArPSB0aGlzLl9zZWNvbmQ7XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9O1xuXG4gIF9wcm90by50b05hbm9PZkRheSA9IGZ1bmN0aW9uIHRvTmFub09mRGF5KCkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMuX2hvdXIgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX0hPVVI7XG4gICAgdG90YWwgKz0gdGhpcy5fbWludXRlICogTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEU7XG4gICAgdG90YWwgKz0gdGhpcy5fc2Vjb25kICogTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgdG90YWwgKz0gdGhpcy5fbmFubztcbiAgICByZXR1cm4gdG90YWw7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVyLCAnb3RoZXInKTtcbiAgICByZXF1aXJlSW5zdGFuY2Uob3RoZXIsIExvY2FsVGltZSwgJ290aGVyJyk7XG4gICAgdmFyIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMuX2hvdXIsIG90aGVyLl9ob3VyKTtcblxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIGNtcCA9IE1hdGhVdGlsLmNvbXBhcmVOdW1iZXJzKHRoaXMuX21pbnV0ZSwgb3RoZXIuX21pbnV0ZSk7XG5cbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fc2Vjb25kLCBvdGhlci5fc2Vjb25kKTtcblxuICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fbmFubywgb3RoZXIuX25hbm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtcDtcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID4gMDtcbiAgfTtcblxuICBfcHJvdG8uaXNCZWZvcmUgPSBmdW5jdGlvbiBpc0JlZm9yZShvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAwO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIExvY2FsVGltZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hvdXIgPT09IG90aGVyLl9ob3VyICYmIHRoaXMuX21pbnV0ZSA9PT0gb3RoZXIuX21pbnV0ZSAmJiB0aGlzLl9zZWNvbmQgPT09IG90aGVyLl9zZWNvbmQgJiYgdGhpcy5fbmFubyA9PT0gb3RoZXIuX25hbm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHZhciBub2QgPSB0aGlzLnRvTmFub09mRGF5KCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLmhhc2gobm9kKTtcbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgdmFyIGhvdXJWYWx1ZSA9IHRoaXMuX2hvdXI7XG4gICAgdmFyIG1pbnV0ZVZhbHVlID0gdGhpcy5fbWludXRlO1xuICAgIHZhciBzZWNvbmRWYWx1ZSA9IHRoaXMuX3NlY29uZDtcbiAgICB2YXIgbmFub1ZhbHVlID0gdGhpcy5fbmFubztcbiAgICBidWYgKz0gaG91clZhbHVlIDwgMTAgPyAnMCcgOiAnJztcbiAgICBidWYgKz0gaG91clZhbHVlO1xuICAgIGJ1ZiArPSBtaW51dGVWYWx1ZSA8IDEwID8gJzowJyA6ICc6JztcbiAgICBidWYgKz0gbWludXRlVmFsdWU7XG5cbiAgICBpZiAoc2Vjb25kVmFsdWUgPiAwIHx8IG5hbm9WYWx1ZSA+IDApIHtcbiAgICAgIGJ1ZiArPSBzZWNvbmRWYWx1ZSA8IDEwID8gJzowJyA6ICc6JztcbiAgICAgIGJ1ZiArPSBzZWNvbmRWYWx1ZTtcblxuICAgICAgaWYgKG5hbm9WYWx1ZSA+IDApIHtcbiAgICAgICAgYnVmICs9ICcuJztcblxuICAgICAgICBpZiAoTWF0aFV0aWwuaW50TW9kKG5hbm9WYWx1ZSwgMTAwMDAwMCkgPT09IDApIHtcbiAgICAgICAgICBidWYgKz0gKFwiXCIgKyAoTWF0aFV0aWwuaW50RGl2KG5hbm9WYWx1ZSwgMTAwMDAwMCkgKyAxMDAwKSkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGhVdGlsLmludE1vZChuYW5vVmFsdWUsIDEwMDApID09PSAwKSB7XG4gICAgICAgICAgYnVmICs9IChcIlwiICsgKE1hdGhVdGlsLmludERpdihuYW5vVmFsdWUsIDEwMDApICsgMTAwMDAwMCkpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gKFwiXCIgKyAobmFub1ZhbHVlICsgMTAwMDAwMDAwMCkpLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH07XG5cbiAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuXG4gIF9wcm90by5mb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQoZm9ybWF0dGVyKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZm9ybWF0dGVyLCAnZm9ybWF0dGVyJyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIExvY2FsVGltZTtcbn0oVGVtcG9yYWwpO1xuZnVuY3Rpb24gX2luaXQkMygpIHtcbiAgTG9jYWxUaW1lLkhPVVJTID0gW107XG5cbiAgZm9yICh2YXIgaG91ciA9IDA7IGhvdXIgPCAyNDsgaG91cisrKSB7XG4gICAgTG9jYWxUaW1lLm9mKGhvdXIsIDAsIDAsIDApO1xuICB9XG5cbiAgTG9jYWxUaW1lLk1JTiA9IExvY2FsVGltZS5IT1VSU1swXTtcbiAgTG9jYWxUaW1lLk1BWCA9IG5ldyBMb2NhbFRpbWUoMjMsIDU5LCA1OSwgOTk5OTk5OTk5KTtcbiAgTG9jYWxUaW1lLk1JRE5JR0hUID0gTG9jYWxUaW1lLkhPVVJTWzBdO1xuICBMb2NhbFRpbWUuTk9PTiA9IExvY2FsVGltZS5IT1VSU1sxMl07XG4gIExvY2FsVGltZS5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnTG9jYWxUaW1lLkZST00nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gTG9jYWxUaW1lLmZyb20odGVtcG9yYWwpO1xuICB9KTtcbn1cbkxvY2FsVGltZS5IT1VSU19QRVJfREFZID0gMjQ7XG5Mb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUiA9IDYwO1xuTG9jYWxUaW1lLk1JTlVURVNfUEVSX0RBWSA9IExvY2FsVGltZS5NSU5VVEVTX1BFUl9IT1VSICogTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVk7XG5Mb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFID0gNjA7XG5Mb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiA9IExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUgKiBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUjtcbkxvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkgPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUiAqIExvY2FsVGltZS5IT1VSU19QRVJfREFZO1xuTG9jYWxUaW1lLk1JTExJU19QRVJfREFZID0gTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSAqIDEwMDA7XG5Mb2NhbFRpbWUuTUlDUk9TX1BFUl9EQVkgPSBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZICogMTAwMDAwMDtcbkxvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EID0gMTAwMDAwMDAwMDtcbkxvY2FsVGltZS5OQU5PU19QRVJfTUlOVVRFID0gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQgKiBMb2NhbFRpbWUuU0VDT05EU19QRVJfTUlOVVRFO1xuTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSID0gTG9jYWxUaW1lLk5BTk9TX1BFUl9NSU5VVEUgKiBMb2NhbFRpbWUuTUlOVVRFU19QRVJfSE9VUjtcbkxvY2FsVGltZS5OQU5PU19QRVJfREFZID0gTG9jYWxUaW1lLk5BTk9TX1BFUl9IT1VSICogTG9jYWxUaW1lLkhPVVJTX1BFUl9EQVk7XG5cbnZhciBOQU5PU19QRVJfTUlMTEkgPSAxMDAwMDAwO1xudmFyIEluc3RhbnQgPSBmdW5jdGlvbiAoX1RlbXBvcmFsKSB7XG4gIF9pbmhlcml0c0xvb3NlKEluc3RhbnQsIF9UZW1wb3JhbCk7XG5cbiAgSW5zdGFudC5ub3cgPSBmdW5jdGlvbiBub3coY2xvY2spIHtcbiAgICBpZiAoY2xvY2sgPT09IHZvaWQgMCkge1xuICAgICAgY2xvY2sgPSBDbG9jay5zeXN0ZW1VVEMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvY2suaW5zdGFudCgpO1xuICB9O1xuXG4gIEluc3RhbnQub2ZFcG9jaFNlY29uZCA9IGZ1bmN0aW9uIG9mRXBvY2hTZWNvbmQoZXBvY2hTZWNvbmQsIG5hbm9BZGp1c3RtZW50KSB7XG4gICAgaWYgKG5hbm9BZGp1c3RtZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hbm9BZGp1c3RtZW50ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc2VjcyA9IGVwb2NoU2Vjb25kICsgTWF0aFV0aWwuZmxvb3JEaXYobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICB2YXIgbm9zID0gTWF0aFV0aWwuZmxvb3JNb2QobmFub0FkanVzdG1lbnQsIExvY2FsVGltZS5OQU5PU19QRVJfU0VDT05EKTtcbiAgICByZXR1cm4gSW5zdGFudC5fY3JlYXRlKHNlY3MsIG5vcyk7XG4gIH07XG5cbiAgSW5zdGFudC5vZkVwb2NoTWlsbGkgPSBmdW5jdGlvbiBvZkVwb2NoTWlsbGkoZXBvY2hNaWxsaSkge1xuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuZmxvb3JEaXYoZXBvY2hNaWxsaSwgMTAwMCk7XG4gICAgdmFyIG1vcyA9IE1hdGhVdGlsLmZsb29yTW9kKGVwb2NoTWlsbGksIDEwMDApO1xuICAgIHJldHVybiBJbnN0YW50Ll9jcmVhdGUoc2VjcywgbW9zICogMTAwMDAwMCk7XG4gIH07XG5cbiAgSW5zdGFudC5vZkVwb2NoTWljcm8gPSBmdW5jdGlvbiBvZkVwb2NoTWljcm8oZXBvY2hNaWNybykge1xuICAgIHZhciBzZWNzID0gTWF0aFV0aWwuZmxvb3JEaXYoZXBvY2hNaWNybywgMTAwMDAwMCk7XG4gICAgdmFyIG1vcyA9IE1hdGhVdGlsLmZsb29yTW9kKGVwb2NoTWljcm8sIDEwMDAwMDApO1xuICAgIHJldHVybiBJbnN0YW50Ll9jcmVhdGUoc2VjcywgbW9zICogMTAwMCk7XG4gIH07XG5cbiAgSW5zdGFudC5mcm9tID0gZnVuY3Rpb24gZnJvbSh0ZW1wb3JhbCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5zdGFudFNlY3MgPSB0ZW1wb3JhbC5nZXRMb25nKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyk7XG4gICAgICB2YXIgbmFub09mU2Vjb25kID0gdGVtcG9yYWwuZ2V0KENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EKTtcbiAgICAgIHJldHVybiBJbnN0YW50Lm9mRXBvY2hTZWNvbmQoaW5zdGFudFNlY3MsIG5hbm9PZlNlY29uZCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbihcIlVuYWJsZSB0byBvYnRhaW4gSW5zdGFudCBmcm9tIFRlbXBvcmFsQWNjZXNzb3I6IFwiICsgdGVtcG9yYWwgKyBcIiwgdHlwZSBcIiArIHR5cGVvZiB0ZW1wb3JhbCwgZXgpO1xuICAgIH1cbiAgfTtcblxuICBJbnN0YW50LnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCkge1xuICAgIHJldHVybiBEYXRlVGltZUZvcm1hdHRlci5JU09fSU5TVEFOVC5wYXJzZSh0ZXh0LCBJbnN0YW50LkZST00pO1xuICB9O1xuXG4gIEluc3RhbnQuX2NyZWF0ZSA9IGZ1bmN0aW9uIF9jcmVhdGUoc2Vjb25kcywgbmFub09mU2Vjb25kKSB7XG4gICAgaWYgKHNlY29uZHMgPT09IDAgJiYgbmFub09mU2Vjb25kID09PSAwKSB7XG4gICAgICByZXR1cm4gSW5zdGFudC5FUE9DSDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEluc3RhbnQoc2Vjb25kcywgbmFub09mU2Vjb25kKTtcbiAgfTtcblxuICBJbnN0YW50Ll92YWxpZGF0ZSA9IGZ1bmN0aW9uIF92YWxpZGF0ZShzZWNvbmRzLCBuYW5vT2ZTZWNvbmQpIHtcbiAgICBpZiAoc2Vjb25kcyA8IEluc3RhbnQuTUlOX1NFQ09ORFMgfHwgc2Vjb25kcyA+IEluc3RhbnQuTUFYX1NFQ09ORFMpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSW5zdGFudCBleGNlZWRzIG1pbmltdW0gb3IgbWF4aW11bSBpbnN0YW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKG5hbm9PZlNlY29uZCA8IDAgfHwgbmFub09mU2Vjb25kID4gTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQpIHtcbiAgICAgIHRocm93IG5ldyBEYXRlVGltZUV4Y2VwdGlvbignSW5zdGFudCBleGNlZWRzIG1pbmltdW0gb3IgbWF4aW11bSBpbnN0YW50Jyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEluc3RhbnQoc2Vjb25kcywgbmFub09mU2Vjb25kKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfVGVtcG9yYWwuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgSW5zdGFudC5fdmFsaWRhdGUoc2Vjb25kcywgbmFub09mU2Vjb25kKTtcblxuICAgIF90aGlzLl9zZWNvbmRzID0gTWF0aFV0aWwuc2FmZVRvSW50KHNlY29uZHMpO1xuICAgIF90aGlzLl9uYW5vcyA9IE1hdGhVdGlsLnNhZmVUb0ludChuYW5vT2ZTZWNvbmQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnN0YW50LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiBpc1N1cHBvcnRlZChmaWVsZE9yVW5pdCkge1xuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub0ZpZWxkKSB7XG4gICAgICByZXR1cm4gZmllbGRPclVuaXQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZE9yVW5pdCA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQgfHwgZmllbGRPclVuaXQgPT09IENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORCB8fCBmaWVsZE9yVW5pdCA9PT0gQ2hyb25vRmllbGQuTUlMTElfT0ZfU0VDT05EO1xuICAgIH1cblxuICAgIGlmIChmaWVsZE9yVW5pdCBpbnN0YW5jZW9mIENocm9ub1VuaXQpIHtcbiAgICAgIHJldHVybiBmaWVsZE9yVW5pdC5pc1RpbWVCYXNlZCgpIHx8IGZpZWxkT3JVbml0ID09PSBDaHJvbm9Vbml0LkRBWVM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkT3JVbml0ICE9IG51bGwgJiYgZmllbGRPclVuaXQuaXNTdXBwb3J0ZWRCeSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8ucmFuZ2UgPSBmdW5jdGlvbiByYW5nZShmaWVsZCkge1xuICAgIHJldHVybiBfVGVtcG9yYWwucHJvdG90eXBlLnJhbmdlLmNhbGwodGhpcywgZmllbGQpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9uYW5vcztcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JQ1JPX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCAxMDAwKTtcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk1JTExJX09GX1NFQ09ORDpcbiAgICAgICAgICByZXR1cm4gTWF0aFV0aWwuaW50RGl2KHRoaXMuX25hbm9zLCBOQU5PU19QRVJfTUlMTEkpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuSU5TVEFOVF9TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9zZWNvbmRzO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmVwb2NoU2Vjb25kID0gZnVuY3Rpb24gZXBvY2hTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY29uZHM7XG4gIH07XG5cbiAgX3Byb3RvLm5hbm8gPSBmdW5jdGlvbiBuYW5vKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW5vcztcbiAgfTtcblxuICBfcHJvdG8uX3dpdGhGaWVsZCA9IGZ1bmN0aW9uIF93aXRoRmllbGQoZmllbGQsIG5ld1ZhbHVlKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoZmllbGQsICdmaWVsZCcpO1xuXG4gICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgQ2hyb25vRmllbGQpIHtcbiAgICAgIGZpZWxkLmNoZWNrVmFsaWRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5NSUxMSV9PRl9TRUNPTkQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG52YWwgPSBuZXdWYWx1ZSAqIE5BTk9TX1BFUl9NSUxMSTtcbiAgICAgICAgICAgIHJldHVybiBudmFsICE9PSB0aGlzLl9uYW5vcyA/IEluc3RhbnQuX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBudmFsKSA6IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2hyb25vRmllbGQuTUlDUk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbnZhbCA9IG5ld1ZhbHVlICogMTAwMDtcblxuICAgICAgICAgICAgcmV0dXJuIF9udmFsICE9PSB0aGlzLl9uYW5vcyA/IEluc3RhbnQuX2NyZWF0ZSh0aGlzLl9zZWNvbmRzLCBfbnZhbCkgOiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSAhPT0gdGhpcy5fbmFub3MgPyBJbnN0YW50Ll9jcmVhdGUodGhpcy5fc2Vjb25kcywgbmV3VmFsdWUpIDogdGhpcztcblxuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gbmV3VmFsdWUgIT09IHRoaXMuX3NlY29uZHMgPyBJbnN0YW50Ll9jcmVhdGUobmV3VmFsdWUsIHRoaXMuX25hbm9zKSA6IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFRlbXBvcmFsVHlwZUV4Y2VwdGlvbihcIlVuc3VwcG9ydGVkIGZpZWxkOiBcIiArIGZpZWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQuYWRqdXN0SW50byh0aGlzLCBuZXdWYWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRydW5jYXRlZFRvID0gZnVuY3Rpb24gdHJ1bmNhdGVkVG8odW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG5cbiAgICBpZiAodW5pdCA9PT0gQ2hyb25vVW5pdC5OQU5PUykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHVuaXREdXIgPSB1bml0LmR1cmF0aW9uKCk7XG5cbiAgICBpZiAodW5pdER1ci5zZWNvbmRzKCkgPiBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgaXMgdG9vIGxhcmdlIHRvIGJlIHVzZWQgZm9yIHRydW5jYXRpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgZHVyID0gdW5pdER1ci50b05hbm9zKCk7XG5cbiAgICBpZiAoTWF0aFV0aWwuaW50TW9kKExvY2FsVGltZS5OQU5PU19QRVJfREFZLCBkdXIpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRGF0ZVRpbWVFeGNlcHRpb24oJ1VuaXQgbXVzdCBkaXZpZGUgaW50byBhIHN0YW5kYXJkIGRheSB3aXRob3V0IHJlbWFpbmRlcicpO1xuICAgIH1cblxuICAgIHZhciBub2QgPSBNYXRoVXRpbC5pbnRNb2QodGhpcy5fc2Vjb25kcywgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkgKiBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCArIHRoaXMuX25hbm9zO1xuXG4gICAgdmFyIHJlc3VsdCA9IE1hdGhVdGlsLmludERpdihub2QsIGR1cikgKiBkdXI7XG4gICAgcmV0dXJuIHRoaXMucGx1c05hbm9zKHJlc3VsdCAtIG5vZCk7XG4gIH07XG5cbiAgX3Byb3RvLl9wbHVzVW5pdCA9IGZ1bmN0aW9uIF9wbHVzVW5pdChhbW91bnRUb0FkZCwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGFtb3VudFRvQWRkLCAnYW1vdW50VG9BZGQnKTtcbiAgICByZXF1aXJlTm9uTnVsbCh1bml0LCAndW5pdCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZSh1bml0LCBUZW1wb3JhbFVuaXQpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcyhhbW91bnRUb0FkZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzTWljcm9zKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNNaWxsaXMoYW1vdW50VG9BZGQpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5TRUNPTkRTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKGFtb3VudFRvQWRkKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlOVVRFUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wbHVzU2Vjb25kcyhNYXRoVXRpbC5zYWZlTXVsdGlwbHkoYW1vdW50VG9BZGQsIExvY2FsVGltZS5TRUNPTkRTX1BFUl9NSU5VVEUpKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSE9VUlM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfSE9VUikpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5IQUxGX0RBWVM6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGx1c1NlY29uZHMoTWF0aFV0aWwuc2FmZU11bHRpcGx5KGFtb3VudFRvQWRkLCBMb2NhbFRpbWUuU0VDT05EU19QRVJfREFZIC8gMikpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5EQVlTOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKE1hdGhVdGlsLnNhZmVNdWx0aXBseShhbW91bnRUb0FkZCwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0RBWSkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmFkZFRvKHRoaXMsIGFtb3VudFRvQWRkKTtcbiAgfTtcblxuICBfcHJvdG8ucGx1c1NlY29uZHMgPSBmdW5jdGlvbiBwbHVzU2Vjb25kcyhzZWNvbmRzVG9BZGQpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1cyhzZWNvbmRzVG9BZGQsIDApO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWlsbGlzID0gZnVuY3Rpb24gcGx1c01pbGxpcyhtaWxsaXNUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzKE1hdGhVdGlsLmludERpdihtaWxsaXNUb0FkZCwgMTAwMCksIE1hdGhVdGlsLmludE1vZChtaWxsaXNUb0FkZCwgMTAwMCkgKiBOQU5PU19QRVJfTUlMTEkpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTmFub3MgPSBmdW5jdGlvbiBwbHVzTmFub3MobmFub3NUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzKDAsIG5hbm9zVG9BZGQpO1xuICB9O1xuXG4gIF9wcm90by5wbHVzTWljcm9zID0gZnVuY3Rpb24gcGx1c01pY3JvcyhtaWNyb3NUb0FkZCkge1xuICAgIHJldHVybiB0aGlzLl9wbHVzKE1hdGhVdGlsLmludERpdihtaWNyb3NUb0FkZCwgMTAwMDAwMCksIE1hdGhVdGlsLmludE1vZChtaWNyb3NUb0FkZCwgMTAwMDAwMCkgKiAxMDAwKTtcbiAgfTtcblxuICBfcHJvdG8uX3BsdXMgPSBmdW5jdGlvbiBfcGx1cyhzZWNvbmRzVG9BZGQsIG5hbm9zVG9BZGQpIHtcbiAgICBpZiAoc2Vjb25kc1RvQWRkID09PSAwICYmIG5hbm9zVG9BZGQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBlcG9jaFNlYyA9IHRoaXMuX3NlY29uZHMgKyBzZWNvbmRzVG9BZGQ7XG4gICAgZXBvY2hTZWMgPSBlcG9jaFNlYyArIE1hdGhVdGlsLmludERpdihuYW5vc1RvQWRkLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgdmFyIG5hbm9BZGp1c3RtZW50ID0gdGhpcy5fbmFub3MgKyBuYW5vc1RvQWRkICUgTG9jYWxUaW1lLk5BTk9TX1BFUl9TRUNPTkQ7XG4gICAgcmV0dXJuIEluc3RhbnQub2ZFcG9jaFNlY29uZChlcG9jaFNlYywgbmFub0FkanVzdG1lbnQpO1xuICB9O1xuXG4gIF9wcm90by5fbWludXNVbml0ID0gZnVuY3Rpb24gX21pbnVzVW5pdChhbW91bnRUb1N1YnRyYWN0LCB1bml0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdXNVbml0KC0xICogYW1vdW50VG9TdWJ0cmFjdCwgdW5pdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzU2Vjb25kcyA9IGZ1bmN0aW9uIG1pbnVzU2Vjb25kcyhzZWNvbmRzVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNTZWNvbmRzKHNlY29uZHNUb1N1YnRyYWN0ICogLTEpO1xuICB9O1xuXG4gIF9wcm90by5taW51c01pbGxpcyA9IGZ1bmN0aW9uIG1pbnVzTWlsbGlzKG1pbGxpc1RvU3VidHJhY3QpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVzTWlsbGlzKC0xICogbWlsbGlzVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTmFub3MgPSBmdW5jdGlvbiBtaW51c05hbm9zKG5hbm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNOYW5vcygtMSAqIG5hbm9zVG9TdWJ0cmFjdCk7XG4gIH07XG5cbiAgX3Byb3RvLm1pbnVzTWljcm9zID0gZnVuY3Rpb24gbWludXNNaWNyb3MobWljcm9zVG9TdWJ0cmFjdCkge1xuICAgIHJldHVybiB0aGlzLnBsdXNNaWNyb3MoLTEgKiBtaWNyb3NUb1N1YnRyYWN0KTtcbiAgfTtcblxuICBfcHJvdG8ucXVlcnkgPSBmdW5jdGlvbiBxdWVyeShfcXVlcnkpIHtcbiAgICByZXF1aXJlTm9uTnVsbChfcXVlcnksICdxdWVyeScpO1xuXG4gICAgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnByZWNpc2lvbigpKSB7XG4gICAgICByZXR1cm4gQ2hyb25vVW5pdC5OQU5PUztcbiAgICB9XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxUaW1lKCkgfHwgX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMuY2hyb25vbG9neSgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmVJZCgpIHx8IF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLnpvbmUoKSB8fCBfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy5vZmZzZXQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9xdWVyeS5xdWVyeUZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmFkanVzdEludG8gPSBmdW5jdGlvbiBhZGp1c3RJbnRvKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHJldHVybiB0ZW1wb3JhbC53aXRoKENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUywgdGhpcy5fc2Vjb25kcykud2l0aChDaHJvbm9GaWVsZC5OQU5PX09GX1NFQ09ORCwgdGhpcy5fbmFub3MpO1xuICB9O1xuXG4gIF9wcm90by51bnRpbCA9IGZ1bmN0aW9uIHVudGlsKGVuZEV4Y2x1c2l2ZSwgdW5pdCkge1xuICAgIHJlcXVpcmVOb25OdWxsKGVuZEV4Y2x1c2l2ZSwgJ2VuZEV4Y2x1c2l2ZScpO1xuICAgIHJlcXVpcmVOb25OdWxsKHVuaXQsICd1bml0Jyk7XG4gICAgdmFyIGVuZCA9IEluc3RhbnQuZnJvbShlbmRFeGNsdXNpdmUpO1xuXG4gICAgaWYgKHVuaXQgaW5zdGFuY2VvZiBDaHJvbm9Vbml0KSB7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk5BTk9TOlxuICAgICAgICAgIHJldHVybiB0aGlzLl9uYW5vc1VudGlsKGVuZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JQ1JPUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWljcm9zVW50aWwoZW5kKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuTUlMTElTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5zYWZlU3VidHJhY3QoZW5kLnRvRXBvY2hNaWxsaSgpLCB0aGlzLnRvRXBvY2hNaWxsaSgpKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuU0VDT05EUzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vjb25kc1VudGlsKGVuZCk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0Lk1JTlVURVM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmludERpdih0aGlzLl9zZWNvbmRzVW50aWwoZW5kKSwgTG9jYWxUaW1lLlNFQ09ORFNfUEVSX01JTlVURSk7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9Vbml0LkhPVVJTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kc1VudGlsKGVuZCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9IT1VSKTtcblxuICAgICAgICBjYXNlIENocm9ub1VuaXQuSEFMRl9EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kc1VudGlsKGVuZCksIDEyICogTG9jYWxUaW1lLlNFQ09ORFNfUEVSX0hPVVIpO1xuXG4gICAgICAgIGNhc2UgQ2hyb25vVW5pdC5EQVlTOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5pbnREaXYodGhpcy5fc2Vjb25kc1VudGlsKGVuZCksIExvY2FsVGltZS5TRUNPTkRTX1BFUl9EQVkpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCB1bml0OiBcIiArIHVuaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB1bml0LmJldHdlZW4odGhpcywgZW5kKTtcbiAgfTtcblxuICBfcHJvdG8uX21pY3Jvc1VudGlsID0gZnVuY3Rpb24gX21pY3Jvc1VudGlsKGVuZCkge1xuICAgIHZhciBzZWNzRGlmZiA9IE1hdGhVdGlsLnNhZmVTdWJ0cmFjdChlbmQuZXBvY2hTZWNvbmQoKSwgdGhpcy5lcG9jaFNlY29uZCgpKTtcbiAgICB2YXIgdG90YWxNaWNyb3MgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkoc2Vjc0RpZmYsIDEwMDAwMDApO1xuICAgIHJldHVybiBNYXRoVXRpbC5zYWZlQWRkKHRvdGFsTWljcm9zLCBNYXRoVXRpbC5pbnREaXYoZW5kLm5hbm8oKSAtIHRoaXMubmFubygpLCAxMDAwKSk7XG4gIH07XG5cbiAgX3Byb3RvLl9uYW5vc1VudGlsID0gZnVuY3Rpb24gX25hbm9zVW50aWwoZW5kKSB7XG4gICAgdmFyIHNlY3NEaWZmID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGVuZC5lcG9jaFNlY29uZCgpLCB0aGlzLmVwb2NoU2Vjb25kKCkpO1xuICAgIHZhciB0b3RhbE5hbm9zID0gTWF0aFV0aWwuc2FmZU11bHRpcGx5KHNlY3NEaWZmLCBMb2NhbFRpbWUuTkFOT1NfUEVSX1NFQ09ORCk7XG4gICAgcmV0dXJuIE1hdGhVdGlsLnNhZmVBZGQodG90YWxOYW5vcywgZW5kLm5hbm8oKSAtIHRoaXMubmFubygpKTtcbiAgfTtcblxuICBfcHJvdG8uX3NlY29uZHNVbnRpbCA9IGZ1bmN0aW9uIF9zZWNvbmRzVW50aWwoZW5kKSB7XG4gICAgdmFyIHNlY3NEaWZmID0gTWF0aFV0aWwuc2FmZVN1YnRyYWN0KGVuZC5lcG9jaFNlY29uZCgpLCB0aGlzLmVwb2NoU2Vjb25kKCkpO1xuICAgIHZhciBuYW5vc0RpZmYgPSBlbmQubmFubygpIC0gdGhpcy5uYW5vKCk7XG5cbiAgICBpZiAoc2Vjc0RpZmYgPiAwICYmIG5hbm9zRGlmZiA8IDApIHtcbiAgICAgIHNlY3NEaWZmLS07XG4gICAgfSBlbHNlIGlmIChzZWNzRGlmZiA8IDAgJiYgbmFub3NEaWZmID4gMCkge1xuICAgICAgc2Vjc0RpZmYrKztcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vjc0RpZmY7XG4gIH07XG5cbiAgX3Byb3RvLmF0T2Zmc2V0ID0gZnVuY3Rpb24gYXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgcmV0dXJuIE9mZnNldERhdGVUaW1lLm9mSW5zdGFudCh0aGlzLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5hdFpvbmUgPSBmdW5jdGlvbiBhdFpvbmUoem9uZSkge1xuICAgIHJldHVybiBab25lZERhdGVUaW1lLm9mSW5zdGFudCh0aGlzLCB6b25lKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaE1pbGxpID0gZnVuY3Rpb24gdG9FcG9jaE1pbGxpKCkge1xuICAgIHZhciBtaWxsaXMgPSBNYXRoVXRpbC5zYWZlTXVsdGlwbHkodGhpcy5fc2Vjb25kcywgMTAwMCk7XG4gICAgcmV0dXJuIG1pbGxpcyArIE1hdGhVdGlsLmludERpdih0aGlzLl9uYW5vcywgTkFOT1NfUEVSX01JTExJKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvKG90aGVySW5zdGFudCkge1xuICAgIHJlcXVpcmVOb25OdWxsKG90aGVySW5zdGFudCwgJ290aGVySW5zdGFudCcpO1xuICAgIHJlcXVpcmVJbnN0YW5jZShvdGhlckluc3RhbnQsIEluc3RhbnQsICdvdGhlckluc3RhbnQnKTtcbiAgICB2YXIgY21wID0gTWF0aFV0aWwuY29tcGFyZU51bWJlcnModGhpcy5fc2Vjb25kcywgb3RoZXJJbnN0YW50Ll9zZWNvbmRzKTtcblxuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX25hbm9zIC0gb3RoZXJJbnN0YW50Ll9uYW5vcztcbiAgfTtcblxuICBfcHJvdG8uaXNBZnRlciA9IGZ1bmN0aW9uIGlzQWZ0ZXIob3RoZXJJbnN0YW50KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVySW5zdGFudCkgPiAwO1xuICB9O1xuXG4gIF9wcm90by5pc0JlZm9yZSA9IGZ1bmN0aW9uIGlzQmVmb3JlKG90aGVySW5zdGFudCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlckluc3RhbnQpIDwgMDtcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5lcG9jaFNlY29uZCgpID09PSBvdGhlci5lcG9jaFNlY29uZCgpICYmIHRoaXMubmFubygpID09PSBvdGhlci5uYW5vKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiBNYXRoVXRpbC5oYXNoQ29kZSh0aGlzLl9zZWNvbmRzLCB0aGlzLl9uYW5vcyk7XG4gIH07XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIERhdGVUaW1lRm9ybWF0dGVyLklTT19JTlNUQU5ULmZvcm1hdCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEluc3RhbnQ7XG59KFRlbXBvcmFsKTtcbmZ1bmN0aW9uIF9pbml0JDIoKSB7XG4gIEluc3RhbnQuTUlOX1NFQ09ORFMgPSAtMzE2MTkxMTkyMTkyMDA7XG4gIEluc3RhbnQuTUFYX1NFQ09ORFMgPSAzMTQ5NDgxNjQwMzE5OTtcbiAgSW5zdGFudC5FUE9DSCA9IG5ldyBJbnN0YW50KDAsIDApO1xuICBJbnN0YW50Lk1JTiA9IEluc3RhbnQub2ZFcG9jaFNlY29uZChJbnN0YW50Lk1JTl9TRUNPTkRTLCAwKTtcbiAgSW5zdGFudC5NQVggPSBJbnN0YW50Lm9mRXBvY2hTZWNvbmQoSW5zdGFudC5NQVhfU0VDT05EUywgOTk5OTk5OTk5KTtcbiAgSW5zdGFudC5GUk9NID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnSW5zdGFudC5GUk9NJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIEluc3RhbnQuZnJvbSh0ZW1wb3JhbCk7XG4gIH0pO1xufVxuXG52YXIgQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsb2NrKCkge31cblxuICBDbG9jay5zeXN0ZW1VVEMgPSBmdW5jdGlvbiBzeXN0ZW1VVEMoKSB7XG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1DbG9jayhab25lT2Zmc2V0LlVUQyk7XG4gIH07XG5cbiAgQ2xvY2suc3lzdGVtRGVmYXVsdFpvbmUgPSBmdW5jdGlvbiBzeXN0ZW1EZWZhdWx0Wm9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUNsb2NrKFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCkpO1xuICB9O1xuXG4gIENsb2NrLnN5c3RlbSA9IGZ1bmN0aW9uIHN5c3RlbSh6b25lKSB7XG4gICAgcmV0dXJuIG5ldyBTeXN0ZW1DbG9jayh6b25lKTtcbiAgfTtcblxuICBDbG9jay5maXhlZCA9IGZ1bmN0aW9uIGZpeGVkKGZpeGVkSW5zdGFudCwgem9uZUlkKSB7XG4gICAgcmV0dXJuIG5ldyBGaXhlZENsb2NrKGZpeGVkSW5zdGFudCwgem9uZUlkKTtcbiAgfTtcblxuICBDbG9jay5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQoYmFzZUNsb2NrLCBkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgT2Zmc2V0Q2xvY2soYmFzZUNsb2NrLCBkdXJhdGlvbik7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IENsb2NrLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubWlsbGlzID0gZnVuY3Rpb24gbWlsbGlzKCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2subWlsbGlzJyk7XG4gIH07XG5cbiAgX3Byb3RvLmluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIGFic3RyYWN0TWV0aG9kRmFpbCgnQ2xvY2suaW5zdGFudCcpO1xuICB9O1xuXG4gIF9wcm90by56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ0Nsb2NrLnpvbmUnKTtcbiAgfTtcblxuICBfcHJvdG8ud2l0aFpvbmUgPSBmdW5jdGlvbiB3aXRoWm9uZSgpIHtcbiAgICBhYnN0cmFjdE1ldGhvZEZhaWwoJ0Nsb2NrLndpdGhab25lJyk7XG4gIH07XG5cbiAgcmV0dXJuIENsb2NrO1xufSgpO1xuXG52YXIgU3lzdGVtQ2xvY2sgPSBmdW5jdGlvbiAoX0Nsb2NrKSB7XG4gIF9pbmhlcml0c0xvb3NlKFN5c3RlbUNsb2NrLCBfQ2xvY2spO1xuXG4gIGZ1bmN0aW9uIFN5c3RlbUNsb2NrKHpvbmUpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICByZXF1aXJlTm9uTnVsbCh6b25lLCAnem9uZScpO1xuICAgIF90aGlzID0gX0Nsb2NrLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fem9uZSA9IHpvbmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBTeXN0ZW1DbG9jay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi56b25lID0gZnVuY3Rpb24gem9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9uZTtcbiAgfTtcblxuICBfcHJvdG8yLm1pbGxpcyA9IGZ1bmN0aW9uIG1pbGxpcygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgX3Byb3RvMi5pbnN0YW50ID0gZnVuY3Rpb24gaW5zdGFudCgpIHtcbiAgICByZXR1cm4gSW5zdGFudC5vZkVwb2NoTWlsbGkodGhpcy5taWxsaXMoKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFN5c3RlbUNsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fem9uZS5lcXVhbHMob2JqLl96b25lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvMi53aXRoWm9uZSA9IGZ1bmN0aW9uIHdpdGhab25lKHpvbmUpIHtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy5fem9uZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3lzdGVtQ2xvY2soem9uZSk7XG4gIH07XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlN5c3RlbUNsb2NrW1wiICsgdGhpcy5fem9uZS50b1N0cmluZygpICsgXCJdXCI7XG4gIH07XG5cbiAgcmV0dXJuIFN5c3RlbUNsb2NrO1xufShDbG9jayk7XG5cbnZhciBGaXhlZENsb2NrID0gZnVuY3Rpb24gKF9DbG9jazIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRml4ZWRDbG9jaywgX0Nsb2NrMik7XG5cbiAgZnVuY3Rpb24gRml4ZWRDbG9jayhmaXhlZEluc3RhbnQsIHpvbmVJZCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfQ2xvY2syLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpczIuX2luc3RhbnQgPSBmaXhlZEluc3RhbnQ7XG4gICAgX3RoaXMyLl96b25lSWQgPSB6b25lSWQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRml4ZWRDbG9jay5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5pbnN0YW50ID0gZnVuY3Rpb24gaW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFudDtcbiAgfTtcblxuICBfcHJvdG8zLm1pbGxpcyA9IGZ1bmN0aW9uIG1pbGxpcygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFudC50b0Vwb2NoTWlsbGkoKTtcbiAgfTtcblxuICBfcHJvdG8zLnpvbmUgPSBmdW5jdGlvbiB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lSWQ7XG4gIH07XG5cbiAgX3Byb3RvMy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnRml4ZWRDbG9ja1tdJztcbiAgfTtcblxuICBfcHJvdG8zLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRml4ZWRDbG9jaykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbnQuZXF1YWxzKG9iai5faW5zdGFudCkgJiYgdGhpcy5fem9uZUlkLmVxdWFscyhvYmouX3pvbmVJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90bzMud2l0aFpvbmUgPSBmdW5jdGlvbiB3aXRoWm9uZSh6b25lKSB7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuX3pvbmVJZCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRml4ZWRDbG9jayh0aGlzLl9pbnN0YW50LCB6b25lKTtcbiAgfTtcblxuICByZXR1cm4gRml4ZWRDbG9jaztcbn0oQ2xvY2spO1xuXG52YXIgT2Zmc2V0Q2xvY2sgPSBmdW5jdGlvbiAoX0Nsb2NrMykge1xuICBfaW5oZXJpdHNMb29zZShPZmZzZXRDbG9jaywgX0Nsb2NrMyk7XG5cbiAgZnVuY3Rpb24gT2Zmc2V0Q2xvY2soYmFzZUNsb2NrLCBvZmZzZXQpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgX3RoaXMzID0gX0Nsb2NrMy5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMzLl9iYXNlQ2xvY2sgPSBiYXNlQ2xvY2s7XG4gICAgX3RoaXMzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gT2Zmc2V0Q2xvY2sucHJvdG90eXBlO1xuXG4gIF9wcm90bzQuem9uZSA9IGZ1bmN0aW9uIHpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VDbG9jay56b25lKCk7XG4gIH07XG5cbiAgX3Byb3RvNC53aXRoWm9uZSA9IGZ1bmN0aW9uIHdpdGhab25lKHpvbmUpIHtcbiAgICBpZiAoem9uZS5lcXVhbHModGhpcy5fYmFzZUNsb2NrLnpvbmUoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT2Zmc2V0Q2xvY2sodGhpcy5fYmFzZUNsb2NrLndpdGhab25lKHpvbmUpLCB0aGlzLl9vZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90bzQubWlsbGlzID0gZnVuY3Rpb24gbWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlQ2xvY2subWlsbGlzKCkgKyB0aGlzLl9vZmZzZXQudG9NaWxsaXMoKTtcbiAgfTtcblxuICBfcHJvdG80Lmluc3RhbnQgPSBmdW5jdGlvbiBpbnN0YW50KCkge1xuICAgIHJldHVybiB0aGlzLl9iYXNlQ2xvY2suaW5zdGFudCgpLnBsdXModGhpcy5fb2Zmc2V0KTtcbiAgfTtcblxuICBfcHJvdG80LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgT2Zmc2V0Q2xvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlQ2xvY2suZXF1YWxzKG9iai5fYmFzZUNsb2NrKSAmJiB0aGlzLl9vZmZzZXQuZXF1YWxzKG9iai5fb2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvNC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIk9mZnNldENsb2NrW1wiICsgdGhpcy5fYmFzZUNsb2NrICsgXCIsXCIgKyB0aGlzLl9vZmZzZXQgKyBcIl1cIjtcbiAgfTtcblxuICByZXR1cm4gT2Zmc2V0Q2xvY2s7XG59KENsb2NrKTtcblxuLypcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTYsIFBoaWxpcHAgVGjDvHJ3w6RjaHRlciAmIFBhdHRyaWNrIEjDvHBlclxuICogQGNvcHlyaWdodCAoYykgMjAwNy1wcmVzZW50LCBTdGVwaGVuIENvbGVib3VybmUgJiBNaWNoYWVsIE5hc2NpbWVudG8gU2FudG9zXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgWm9uZU9mZnNldFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIFpvbmVPZmZzZXRUcmFuc2l0aW9uLm9mID0gZnVuY3Rpb24gb2YodHJhbnNpdGlvbiwgb2Zmc2V0QmVmb3JlLCBvZmZzZXRBZnRlcikge1xuICAgIHJldHVybiBuZXcgWm9uZU9mZnNldFRyYW5zaXRpb24odHJhbnNpdGlvbiwgb2Zmc2V0QmVmb3JlLCBvZmZzZXRBZnRlcik7XG4gIH07XG5cbiAgZnVuY3Rpb24gWm9uZU9mZnNldFRyYW5zaXRpb24odHJhbnNpdGlvbiwgb2Zmc2V0QmVmb3JlLCBvZmZzZXRBZnRlcikge1xuICAgIHJlcXVpcmVOb25OdWxsKHRyYW5zaXRpb24sICd0cmFuc2l0aW9uJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0QmVmb3JlLCAnb2Zmc2V0QmVmb3JlJyk7XG4gICAgcmVxdWlyZU5vbk51bGwob2Zmc2V0QWZ0ZXIsICdvZmZzZXRBZnRlcicpO1xuXG4gICAgaWYgKG9mZnNldEJlZm9yZS5lcXVhbHMob2Zmc2V0QWZ0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdPZmZzZXRzIG11c3Qgbm90IGJlIGVxdWFsJyk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24ubmFubygpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdOYW5vLW9mLXNlY29uZCBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIExvY2FsRGF0ZVRpbWUpIHtcbiAgICAgIHRoaXMuX3RyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90cmFuc2l0aW9uID0gTG9jYWxEYXRlVGltZS5vZkVwb2NoU2Vjb25kKHRyYW5zaXRpb24sIDAsIG9mZnNldEJlZm9yZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb2Zmc2V0QmVmb3JlID0gb2Zmc2V0QmVmb3JlO1xuICAgIHRoaXMuX29mZnNldEFmdGVyID0gb2Zmc2V0QWZ0ZXI7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gWm9uZU9mZnNldFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnN0YW50ID0gZnVuY3Rpb24gaW5zdGFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbi50b0luc3RhbnQodGhpcy5fb2Zmc2V0QmVmb3JlKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaFNlY29uZCA9IGZ1bmN0aW9uIHRvRXBvY2hTZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24udG9FcG9jaFNlY29uZCh0aGlzLl9vZmZzZXRCZWZvcmUpO1xuICB9O1xuXG4gIF9wcm90by5kYXRlVGltZUJlZm9yZSA9IGZ1bmN0aW9uIGRhdGVUaW1lQmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5kYXRlVGltZUFmdGVyID0gZnVuY3Rpb24gZGF0ZVRpbWVBZnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbi5wbHVzU2Vjb25kcyh0aGlzLmR1cmF0aW9uU2Vjb25kcygpKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0QmVmb3JlID0gZnVuY3Rpb24gb2Zmc2V0QmVmb3JlKCkge1xuICAgIHJldHVybiB0aGlzLl9vZmZzZXRCZWZvcmU7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldEFmdGVyID0gZnVuY3Rpb24gb2Zmc2V0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyO1xuICB9O1xuXG4gIF9wcm90by5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKCkge1xuICAgIHJldHVybiBEdXJhdGlvbi5vZlNlY29uZHModGhpcy5kdXJhdGlvblNlY29uZHMoKSk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uU2Vjb25kcyA9IGZ1bmN0aW9uIGR1cmF0aW9uU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0QWZ0ZXIudG90YWxTZWNvbmRzKCkgLSB0aGlzLl9vZmZzZXRCZWZvcmUudG90YWxTZWNvbmRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzR2FwID0gZnVuY3Rpb24gaXNHYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyLnRvdGFsU2Vjb25kcygpID4gdGhpcy5fb2Zmc2V0QmVmb3JlLnRvdGFsU2Vjb25kcygpO1xuICB9O1xuXG4gIF9wcm90by5pc092ZXJsYXAgPSBmdW5jdGlvbiBpc092ZXJsYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29mZnNldEFmdGVyLnRvdGFsU2Vjb25kcygpIDwgdGhpcy5fb2Zmc2V0QmVmb3JlLnRvdGFsU2Vjb25kcygpO1xuICB9O1xuXG4gIF9wcm90by5pc1ZhbGlkT2Zmc2V0ID0gZnVuY3Rpb24gaXNWYWxpZE9mZnNldChvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0dhcCgpID8gZmFsc2UgOiB0aGlzLl9vZmZzZXRCZWZvcmUuZXF1YWxzKG9mZnNldCkgfHwgdGhpcy5fb2Zmc2V0QWZ0ZXIuZXF1YWxzKG9mZnNldCk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbGlkT2Zmc2V0cyA9IGZ1bmN0aW9uIHZhbGlkT2Zmc2V0cygpIHtcbiAgICBpZiAodGhpcy5pc0dhcCgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbdGhpcy5fb2Zmc2V0QmVmb3JlLCB0aGlzLl9vZmZzZXRBZnRlcl07XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8odHJhbnNpdGlvbikge1xuICAgIHJldHVybiB0aGlzLmluc3RhbnQoKS5jb21wYXJlVG8odHJhbnNpdGlvbi5pbnN0YW50KCkpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFpvbmVPZmZzZXRUcmFuc2l0aW9uKSB7XG4gICAgICB2YXIgZCA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb24uZXF1YWxzKGQuX3RyYW5zaXRpb24pICYmIHRoaXMuX29mZnNldEJlZm9yZS5lcXVhbHMoZC5vZmZzZXRCZWZvcmUoKSkgJiYgdGhpcy5fb2Zmc2V0QWZ0ZXIuZXF1YWxzKGQub2Zmc2V0QWZ0ZXIoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uLmhhc2hDb2RlKCkgXiB0aGlzLl9vZmZzZXRCZWZvcmUuaGFzaENvZGUoKSBeIHRoaXMuX29mZnNldEFmdGVyLmhhc2hDb2RlKCkgPj4+IDE2O1xuICB9O1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIlRyYW5zaXRpb25bXCIgKyAodGhpcy5pc0dhcCgpID8gJ0dhcCcgOiAnT3ZlcmxhcCcpICsgXCIgYXQgXCIgKyB0aGlzLl90cmFuc2l0aW9uLnRvU3RyaW5nKCkgKyB0aGlzLl9vZmZzZXRCZWZvcmUudG9TdHJpbmcoKSArIFwiIHRvIFwiICsgdGhpcy5fb2Zmc2V0QWZ0ZXIgKyBcIl1cIjtcbiAgfTtcblxuICByZXR1cm4gWm9uZU9mZnNldFRyYW5zaXRpb247XG59KCk7XG5cbi8qXG4gKiBAY29weXJpZ2h0IChjKSAyMDE2LCBQaGlsaXBwIFRow7xyd8OkY2h0ZXIgJiBQYXR0cmljayBIw7xwZXJcbiAqIEBjb3B5cmlnaHQgKGMpIDIwMDctcHJlc2VudCwgU3RlcGhlbiBDb2xlYm91cm5lICYgTWljaGFlbCBOYXNjaW1lbnRvIFNhbnRvc1xuICogQGxpY2Vuc2UgQlNELTMtQ2xhdXNlIChzZWUgTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZSlcbiAqL1xuZnVuY3Rpb24gX2luaXQkMSgpIHtcbiAgVGVtcG9yYWxRdWVyaWVzLlpPTkVfSUQgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdaT05FX0lEJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5aT05FX0lEKTtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5DSFJPTk8gPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdDSFJPTk8nLCBmdW5jdGlvbiAodGVtcG9yYWwpIHtcbiAgICByZXR1cm4gdGVtcG9yYWwucXVlcnkoVGVtcG9yYWxRdWVyaWVzLkNIUk9OTyk7XG4gIH0pO1xuICBUZW1wb3JhbFF1ZXJpZXMuUFJFQ0lTSU9OID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnUFJFQ0lTSU9OJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgcmV0dXJuIHRlbXBvcmFsLnF1ZXJ5KFRlbXBvcmFsUXVlcmllcy5QUkVDSVNJT04pO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLk9GRlNFVCA9IGNyZWF0ZVRlbXBvcmFsUXVlcnkoJ09GRlNFVCcsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykpIHtcbiAgICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKHRlbXBvcmFsLmdldChDaHJvbm9GaWVsZC5PRkZTRVRfU0VDT05EUykpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgVGVtcG9yYWxRdWVyaWVzLlpPTkUgPSBjcmVhdGVUZW1wb3JhbFF1ZXJ5KCdaT05FJywgZnVuY3Rpb24gKHRlbXBvcmFsKSB7XG4gICAgdmFyIHpvbmUgPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMuWk9ORV9JRCk7XG4gICAgcmV0dXJuIHpvbmUgIT0gbnVsbCA/IHpvbmUgOiB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMuT0ZGU0VUKTtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9EQVRFID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnTE9DQUxfREFURScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5FUE9DSF9EQVkpKSB7XG4gICAgICByZXR1cm4gTG9jYWxEYXRlLm9mRXBvY2hEYXkodGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5FUE9DSF9EQVkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG4gIFRlbXBvcmFsUXVlcmllcy5MT0NBTF9USU1FID0gY3JlYXRlVGVtcG9yYWxRdWVyeSgnTE9DQUxfVElNRScsIGZ1bmN0aW9uICh0ZW1wb3JhbCkge1xuICAgIGlmICh0ZW1wb3JhbC5pc1N1cHBvcnRlZChDaHJvbm9GaWVsZC5OQU5PX09GX0RBWSkpIHtcbiAgICAgIHJldHVybiBMb2NhbFRpbWUub2ZOYW5vT2ZEYXkodGVtcG9yYWwuZ2V0TG9uZyhDaHJvbm9GaWVsZC5OQU5PX09GX0RBWSkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbn1cblxudmFyIFN5c3RlbURlZmF1bHRab25lUnVsZXMgPSBmdW5jdGlvbiAoX1pvbmVSdWxlcykge1xuICBfaW5oZXJpdHNMb29zZShTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzLCBfWm9uZVJ1bGVzKTtcblxuICBmdW5jdGlvbiBTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzKCkge1xuICAgIHJldHVybiBfWm9uZVJ1bGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uaXNGaXhlZE9mZnNldCA9IGZ1bmN0aW9uIGlzRml4ZWRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5vZmZzZXRPZkluc3RhbnQgPSBmdW5jdGlvbiBvZmZzZXRPZkluc3RhbnQoaW5zdGFudCkge1xuICAgIHZhciBvZmZzZXRJbk1pbnV0ZXMgPSBuZXcgRGF0ZShpbnN0YW50LnRvRXBvY2hNaWxsaSgpKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiBab25lT2Zmc2V0Lm9mVG90YWxNaW51dGVzKG9mZnNldEluTWludXRlcyAqIC0xKTtcbiAgfTtcblxuICBfcHJvdG8ub2Zmc2V0T2ZFcG9jaE1pbGxpID0gZnVuY3Rpb24gb2Zmc2V0T2ZFcG9jaE1pbGxpKGVwb2NoTWlsbGkpIHtcbiAgICB2YXIgb2Zmc2V0SW5NaW51dGVzID0gbmV3IERhdGUoZXBvY2hNaWxsaSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICByZXR1cm4gWm9uZU9mZnNldC5vZlRvdGFsTWludXRlcyhvZmZzZXRJbk1pbnV0ZXMgKiAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLm9mZnNldE9mTG9jYWxEYXRlVGltZSA9IGZ1bmN0aW9uIG9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKSB7XG4gICAgdmFyIGVwb2NoTWlsbGkgPSBsb2NhbERhdGVUaW1lLnRvRXBvY2hTZWNvbmQoWm9uZU9mZnNldC5VVEMpICogMTAwMDtcbiAgICB2YXIgb2Zmc2V0SW5NaW51dGVzQmVmb3JlUG9zc2libGVUcmFuc2l0aW9uID0gbmV3IERhdGUoZXBvY2hNaWxsaSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICB2YXIgZXBvY2hNaWxsaVN5c3RlbVpvbmUgPSBlcG9jaE1pbGxpICsgb2Zmc2V0SW5NaW51dGVzQmVmb3JlUG9zc2libGVUcmFuc2l0aW9uICogNjAwMDA7XG4gICAgdmFyIG9mZnNldEluTWludXRlc0FmdGVyUG9zc2libGVUcmFuc2l0aW9uID0gbmV3IERhdGUoZXBvY2hNaWxsaVN5c3RlbVpvbmUpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgcmV0dXJuIFpvbmVPZmZzZXQub2ZUb3RhbE1pbnV0ZXMob2Zmc2V0SW5NaW51dGVzQWZ0ZXJQb3NzaWJsZVRyYW5zaXRpb24gKiAtMSk7XG4gIH07XG5cbiAgX3Byb3RvLnZhbGlkT2Zmc2V0cyA9IGZ1bmN0aW9uIHZhbGlkT2Zmc2V0cyhsb2NhbERhdGVUaW1lKSB7XG4gICAgcmV0dXJuIFt0aGlzLm9mZnNldE9mTG9jYWxEYXRlVGltZShsb2NhbERhdGVUaW1lKV07XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zaXRpb24gPSBmdW5jdGlvbiB0cmFuc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5zdGFuZGFyZE9mZnNldCA9IGZ1bmN0aW9uIHN0YW5kYXJkT2Zmc2V0KGluc3RhbnQpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRPZkluc3RhbnQoaW5zdGFudCk7XG4gIH07XG5cbiAgX3Byb3RvLmRheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGRheWxpZ2h0U2F2aW5ncygpIHtcbiAgICB0aGlzLl90aHJvd05vdFN1cHBvcnRlZCgpO1xuICB9O1xuXG4gIF9wcm90by5pc0RheWxpZ2h0U2F2aW5ncyA9IGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdzKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLmlzVmFsaWRPZmZzZXQgPSBmdW5jdGlvbiBpc1ZhbGlkT2Zmc2V0KGRhdGVUaW1lLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRPZkxvY2FsRGF0ZVRpbWUoZGF0ZVRpbWUpLmVxdWFscyhvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5uZXh0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIG5leHRUcmFuc2l0aW9uKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLnByZXZpb3VzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIHByZXZpb3VzVHJhbnNpdGlvbigpIHtcbiAgICB0aGlzLl90aHJvd05vdFN1cHBvcnRlZCgpO1xuICB9O1xuXG4gIF9wcm90by50cmFuc2l0aW9ucyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25zKCkge1xuICAgIHRoaXMuX3Rocm93Tm90U3VwcG9ydGVkKCk7XG4gIH07XG5cbiAgX3Byb3RvLnRyYW5zaXRpb25SdWxlcyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25SdWxlcygpIHtcbiAgICB0aGlzLl90aHJvd05vdFN1cHBvcnRlZCgpO1xuICB9O1xuXG4gIF9wcm90by5fdGhyb3dOb3RTdXBwb3J0ZWQgPSBmdW5jdGlvbiBfdGhyb3dOb3RTdXBwb3J0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKCdub3Qgc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIgfHwgb3RoZXIgaW5zdGFuY2VvZiBTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NZU1RFTSc7XG4gIH07XG5cbiAgcmV0dXJuIFN5c3RlbURlZmF1bHRab25lUnVsZXM7XG59KFpvbmVSdWxlcyk7XG5cbnZhciBTeXN0ZW1EZWZhdWx0Wm9uZUlkID0gZnVuY3Rpb24gKF9ab25lSWQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3lzdGVtRGVmYXVsdFpvbmVJZCwgX1pvbmVJZCk7XG5cbiAgZnVuY3Rpb24gU3lzdGVtRGVmYXVsdFpvbmVJZCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9ab25lSWQuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9ydWxlcyA9IG5ldyBTeXN0ZW1EZWZhdWx0Wm9uZVJ1bGVzKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN5c3RlbURlZmF1bHRab25lSWQucHJvdG90eXBlO1xuXG4gIF9wcm90by5ydWxlcyA9IGZ1bmN0aW9uIHJ1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ydWxlcztcbiAgfTtcblxuICBfcHJvdG8uZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLmlkID0gZnVuY3Rpb24gaWQoKSB7XG4gICAgcmV0dXJuICdTWVNURU0nO1xuICB9O1xuXG4gIHJldHVybiBTeXN0ZW1EZWZhdWx0Wm9uZUlkO1xufShab25lSWQpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAY29weXJpZ2h0IChjKSAyMDA3LXByZXNlbnQsIFN0ZXBoZW4gQ29sZWJvdXJuZSAmIE1pY2hhZWwgTmFzY2ltZW50byBTYW50b3NcbiAqIEBsaWNlbnNlIEJTRC0zLUNsYXVzZSAoc2VlIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUpXG4gKi9cbnZhciBab25lSWRGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab25lSWRGYWN0b3J5KCkge31cblxuICBab25lSWRGYWN0b3J5LnN5c3RlbURlZmF1bHQgPSBmdW5jdGlvbiBzeXN0ZW1EZWZhdWx0KCkge1xuICAgIHJldHVybiBTWVNURU1fREVGQVVMVF9aT05FX0lEX0lOU1RBTkNFO1xuICB9O1xuXG4gIFpvbmVJZEZhY3RvcnkuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IGZ1bmN0aW9uIGdldEF2YWlsYWJsZVpvbmVJZHMoKSB7XG4gICAgcmV0dXJuIFpvbmVSdWxlc1Byb3ZpZGVyLmdldEF2YWlsYWJsZVpvbmVJZHMoKTtcbiAgfTtcblxuICBab25lSWRGYWN0b3J5Lm9mID0gZnVuY3Rpb24gb2Yoem9uZUlkKSB7XG4gICAgcmVxdWlyZU5vbk51bGwoem9uZUlkLCAnem9uZUlkJyk7XG5cbiAgICBpZiAoem9uZUlkID09PSAnWicpIHtcbiAgICAgIHJldHVybiBab25lT2Zmc2V0LlVUQztcbiAgICB9XG5cbiAgICBpZiAoem9uZUlkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiSW52YWxpZCB6b25lOiBcIiArIHpvbmVJZCk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICcrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJy0nKSkge1xuICAgICAgcmV0dXJuIFpvbmVPZmZzZXQub2Yoem9uZUlkKTtcbiAgICB9XG5cbiAgICBpZiAoem9uZUlkID09PSAnVVRDJyB8fCB6b25lSWQgPT09ICdHTVQnIHx8IHpvbmVJZCA9PT0gJ0dNVDAnIHx8IHpvbmVJZCA9PT0gJ1VUJykge1xuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHpvbmVJZCwgWm9uZU9mZnNldC5VVEMucnVsZXMoKSk7XG4gICAgfVxuXG4gICAgaWYgKFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdVVEMrJykgfHwgU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ0dNVCsnKSB8fCBTdHJpbmdVdGlsLnN0YXJ0c1dpdGgoem9uZUlkLCAnVVRDLScpIHx8IFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdHTVQtJykpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBab25lT2Zmc2V0Lm9mKHpvbmVJZC5zdWJzdHJpbmcoMykpO1xuXG4gICAgICBpZiAob2Zmc2V0LnRvdGFsU2Vjb25kcygpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQuc3Vic3RyaW5nKDAsIDMpLCBvZmZzZXQucnVsZXMoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgWm9uZVJlZ2lvbih6b25lSWQuc3Vic3RyaW5nKDAsIDMpICsgb2Zmc2V0LmlkKCksIG9mZnNldC5ydWxlcygpKTtcbiAgICB9XG5cbiAgICBpZiAoU3RyaW5nVXRpbC5zdGFydHNXaXRoKHpvbmVJZCwgJ1VUKycpIHx8IFN0cmluZ1V0aWwuc3RhcnRzV2l0aCh6b25lSWQsICdVVC0nKSkge1xuICAgICAgdmFyIF9vZmZzZXQgPSBab25lT2Zmc2V0Lm9mKHpvbmVJZC5zdWJzdHJpbmcoMikpO1xuXG4gICAgICBpZiAoX29mZnNldC50b3RhbFNlY29uZHMoKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24oJ1VUJywgX29mZnNldC5ydWxlcygpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKFwiVVRcIiArIF9vZmZzZXQuaWQoKSwgX29mZnNldC5ydWxlcygpKTtcbiAgICB9XG5cbiAgICBpZiAoem9uZUlkID09PSAnU1lTVEVNJykge1xuICAgICAgcmV0dXJuIFpvbmVJZC5zeXN0ZW1EZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpvbmVSZWdpb24ub2ZJZCh6b25lSWQpO1xuICB9O1xuXG4gIFpvbmVJZEZhY3Rvcnkub2ZPZmZzZXQgPSBmdW5jdGlvbiBvZk9mZnNldChwcmVmaXgsIG9mZnNldCkge1xuICAgIHJlcXVpcmVOb25OdWxsKHByZWZpeCwgJ3ByZWZpeCcpO1xuICAgIHJlcXVpcmVOb25OdWxsKG9mZnNldCwgJ29mZnNldCcpO1xuXG4gICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeCA9PT0gJ0dNVCcgfHwgcHJlZml4ID09PSAnVVRDJyB8fCBwcmVmaXggPT09ICdVVCcpIHtcbiAgICAgIGlmIChvZmZzZXQudG90YWxTZWNvbmRzKCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab25lUmVnaW9uKHByZWZpeCwgb2Zmc2V0LnJ1bGVzKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFpvbmVSZWdpb24ocHJlZml4ICsgb2Zmc2V0LmlkKCksIG9mZnNldC5ydWxlcygpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiSW52YWxpZCBwcmVmaXgsIG11c3QgYmUgR01ULCBVVEMgb3IgVVQ6IFwiICsgcHJlZml4KTtcbiAgfTtcblxuICBab25lSWRGYWN0b3J5LmZyb20gPSBmdW5jdGlvbiBmcm9tKHRlbXBvcmFsKSB7XG4gICAgcmVxdWlyZU5vbk51bGwodGVtcG9yYWwsICd0ZW1wb3JhbCcpO1xuICAgIHZhciBvYmogPSB0ZW1wb3JhbC5xdWVyeShUZW1wb3JhbFF1ZXJpZXMuem9uZSgpKTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IERhdGVUaW1lRXhjZXB0aW9uKFwiVW5hYmxlIHRvIG9idGFpbiBab25lSWQgZnJvbSBUZW1wb3JhbEFjY2Vzc29yOiBcIiArIHRlbXBvcmFsICsgXCIsIHR5cGUgXCIgKyAodGVtcG9yYWwuY29uc3RydWN0b3IgIT0gbnVsbCA/IHRlbXBvcmFsLmNvbnN0cnVjdG9yLm5hbWUgOiAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgcmV0dXJuIFpvbmVJZEZhY3Rvcnk7XG59KCk7XG52YXIgU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRSA9IG51bGw7XG5mdW5jdGlvbiBfaW5pdCgpIHtcbiAgU1lTVEVNX0RFRkFVTFRfWk9ORV9JRF9JTlNUQU5DRSA9IG5ldyBTeXN0ZW1EZWZhdWx0Wm9uZUlkKCk7XG4gIFpvbmVJZC5zeXN0ZW1EZWZhdWx0ID0gWm9uZUlkRmFjdG9yeS5zeXN0ZW1EZWZhdWx0O1xuICBab25lSWQuZ2V0QXZhaWxhYmxlWm9uZUlkcyA9IFpvbmVJZEZhY3RvcnkuZ2V0QXZhaWxhYmxlWm9uZUlkcztcbiAgWm9uZUlkLm9mID0gWm9uZUlkRmFjdG9yeS5vZjtcbiAgWm9uZUlkLm9mT2Zmc2V0ID0gWm9uZUlkRmFjdG9yeS5vZk9mZnNldDtcbiAgWm9uZUlkLmZyb20gPSBab25lSWRGYWN0b3J5LmZyb207XG4gIFpvbmVPZmZzZXQuZnJvbSA9IFpvbmVJZEZhY3RvcnkuZnJvbTtcbiAgWm9uZUlkLlNZU1RFTSA9IFNZU1RFTV9ERUZBVUxUX1pPTkVfSURfSU5TVEFOQ0U7XG4gIFpvbmVJZC5VVEMgPSBab25lT2Zmc2V0Lm9mVG90YWxTZWNvbmRzKDApO1xufVxuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgaXNJbml0ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmIChpc0luaXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpc0luaXQgPSB0cnVlO1xuICBfaW5pdCRtKCk7XG4gIF9pbml0JG4oKTtcbiAgX2luaXQkbCgpO1xuICBfaW5pdCRrKCk7XG4gIF9pbml0JDMoKTtcbiAgX2luaXQkZigpO1xuICBfaW5pdCQxKCk7XG4gIF9pbml0JGooKTtcbiAgX2luaXQkMigpO1xuICBfaW5pdCQ1KCk7XG4gIF9pbml0JDQoKTtcbiAgX2luaXQkYSgpO1xuICBfaW5pdCRpKCk7XG4gIF9pbml0JGIoKTtcbiAgX2luaXQkYygpO1xuICBfaW5pdCRoKCk7XG4gIF9pbml0JGcoKTtcbiAgX2luaXQkNygpO1xuICBfaW5pdCgpO1xuICBfaW5pdCQ5KCk7XG4gIF9pbml0JGQoKTtcbiAgX2luaXQkZSgpO1xuICBfaW5pdCQ2KCk7XG4gIF9pbml0JDgoKTtcbn1cblxuaW5pdCgpO1xuXG4vKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG5cbnZhciBUb05hdGl2ZUpzQ29udmVydGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb05hdGl2ZUpzQ29udmVydGVyKHRlbXBvcmFsLCB6b25lKSB7XG4gICAgdmFyIHpvbmVkRGF0ZVRpbWU7XG5cbiAgICBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBJbnN0YW50KSB7XG4gICAgICB0aGlzLmluc3RhbnQgPSB0ZW1wb3JhbDtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRlbXBvcmFsIGluc3RhbmNlb2YgTG9jYWxEYXRlKSB7XG4gICAgICB6b25lID0gem9uZSA9PSBudWxsID8gWm9uZUlkLnN5c3RlbURlZmF1bHQoKSA6IHpvbmU7XG4gICAgICB6b25lZERhdGVUaW1lID0gdGVtcG9yYWwuYXRTdGFydE9mRGF5KHpvbmUpO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBMb2NhbERhdGVUaW1lKSB7XG4gICAgICB6b25lID0gem9uZSA9PSBudWxsID8gWm9uZUlkLnN5c3RlbURlZmF1bHQoKSA6IHpvbmU7XG4gICAgICB6b25lZERhdGVUaW1lID0gdGVtcG9yYWwuYXRab25lKHpvbmUpO1xuICAgIH0gZWxzZSBpZiAodGVtcG9yYWwgaW5zdGFuY2VvZiBab25lZERhdGVUaW1lKSB7XG4gICAgICBpZiAoem9uZSA9PSBudWxsKSB7XG4gICAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmVkRGF0ZVRpbWUgPSB0ZW1wb3JhbC53aXRoWm9uZVNhbWVJbnN0YW50KHpvbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwidW5zdXBwb3J0ZWQgaW5zdGFuY2UgZm9yIGNvbnZlcnQgb3BlcmF0aW9uOlwiICsgdGVtcG9yYWwpO1xuICAgIH1cblxuICAgIHRoaXMuaW5zdGFudCA9IHpvbmVkRGF0ZVRpbWUudG9JbnN0YW50KCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVG9OYXRpdmVKc0NvbnZlcnRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvRGF0ZSA9IGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pbnN0YW50LnRvRXBvY2hNaWxsaSgpKTtcbiAgfTtcblxuICBfcHJvdG8udG9FcG9jaE1pbGxpID0gZnVuY3Rpb24gdG9FcG9jaE1pbGxpKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbnQudG9FcG9jaE1pbGxpKCk7XG4gIH07XG5cbiAgcmV0dXJuIFRvTmF0aXZlSnNDb252ZXJ0ZXI7XG59KCk7XG5cbmZ1bmN0aW9uIGNvbnZlcnQodGVtcG9yYWwsIHpvbmUpIHtcbiAgcmV0dXJuIG5ldyBUb05hdGl2ZUpzQ29udmVydGVyKHRlbXBvcmFsLCB6b25lKTtcbn1cblxudmFyIE5hdGl2ZUpzVGVtcG9yYWwgPSBmdW5jdGlvbiAoX1RlbXBvcmFsQWNjZXNzb3IpIHtcbiAgX2luaGVyaXRzTG9vc2UoTmF0aXZlSnNUZW1wb3JhbCwgX1RlbXBvcmFsQWNjZXNzb3IpO1xuXG4gIGZ1bmN0aW9uIE5hdGl2ZUpzVGVtcG9yYWwoZGF0ZSwgem9uZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmICh6b25lID09PSB2b2lkIDApIHtcbiAgICAgIHpvbmUgPSBab25lSWQuc3lzdGVtRGVmYXVsdCgpO1xuICAgIH1cblxuICAgIF90aGlzID0gX1RlbXBvcmFsQWNjZXNzb3IuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl96b25lID0gem9uZTtcblxuICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgX3RoaXMuX2Vwb2NoTWlsbGkgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRlLnRvRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkYXRlLnRvRGF0ZSgpIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgX3RoaXMuX2Vwb2NoTWlsbGkgPSBkYXRlLnRvRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICB9XG5cbiAgICBhc3NlcnQoZmFsc2UsICdkYXRlIG11c3QgYmUgZWl0aGVyIGEgamF2YXNjcmlwdCBkYXRlIG9yIGEgbW9tZW50Jyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE5hdGl2ZUpzVGVtcG9yYWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeSkge1xuICAgIHJlcXVpcmVOb25OdWxsKF9xdWVyeSwgJ3F1ZXJ5Jyk7XG5cbiAgICBpZiAoX3F1ZXJ5ID09PSBUZW1wb3JhbFF1ZXJpZXMubG9jYWxEYXRlKCkpIHtcbiAgICAgIHJldHVybiBMb2NhbERhdGUub2ZJbnN0YW50KEluc3RhbnQub2ZFcG9jaE1pbGxpKHRoaXMuX2Vwb2NoTWlsbGkpLCB0aGlzLl96b25lKTtcbiAgICB9IGVsc2UgaWYgKF9xdWVyeSA9PT0gVGVtcG9yYWxRdWVyaWVzLmxvY2FsVGltZSgpKSB7XG4gICAgICByZXR1cm4gTG9jYWxUaW1lLm9mSW5zdGFudChJbnN0YW50Lm9mRXBvY2hNaWxsaSh0aGlzLl9lcG9jaE1pbGxpKSwgdGhpcy5fem9uZSk7XG4gICAgfSBlbHNlIGlmIChfcXVlcnkgPT09IFRlbXBvcmFsUXVlcmllcy56b25lKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl96b25lO1xuICAgIH1cblxuICAgIHJldHVybiBfVGVtcG9yYWxBY2Nlc3Nvci5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBfcXVlcnkpO1xuICB9O1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoZmllbGQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMb25nKGZpZWxkKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TG9uZyA9IGZ1bmN0aW9uIGdldExvbmcoZmllbGQpIHtcbiAgICByZXF1aXJlTm9uTnVsbChmaWVsZCwgJ2ZpZWxkJyk7XG5cbiAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBDaHJvbm9GaWVsZCkge1xuICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICBjYXNlIENocm9ub0ZpZWxkLk5BTk9fT0ZfU0VDT05EOlxuICAgICAgICAgIHJldHVybiBNYXRoVXRpbC5mbG9vck1vZCh0aGlzLl9lcG9jaE1pbGxpLCAxMDAwKSAqIDEwMDAwMDA7XG5cbiAgICAgICAgY2FzZSBDaHJvbm9GaWVsZC5JTlNUQU5UX1NFQ09ORFM6XG4gICAgICAgICAgcmV0dXJuIE1hdGhVdGlsLmZsb29yRGl2KHRoaXMuX2Vwb2NoTWlsbGksIDEwMDApO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24oXCJVbnN1cHBvcnRlZCBmaWVsZDogXCIgKyBmaWVsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkLmdldEZyb20odGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gaXNTdXBwb3J0ZWQoZmllbGQpIHtcbiAgICByZXR1cm4gZmllbGQgPT09IENocm9ub0ZpZWxkLklOU1RBTlRfU0VDT05EUyB8fCBmaWVsZCA9PT0gQ2hyb25vRmllbGQuTkFOT19PRl9TRUNPTkQ7XG4gIH07XG5cbiAgcmV0dXJuIE5hdGl2ZUpzVGVtcG9yYWw7XG59KFRlbXBvcmFsQWNjZXNzb3IpO1xuXG5mdW5jdGlvbiBuYXRpdmVKcyhkYXRlLCB6b25lKSB7XG4gIHJldHVybiBuZXcgTmF0aXZlSnNUZW1wb3JhbChkYXRlLCB6b25lKTtcbn1cblxuZnVuY3Rpb24gYmluZFVzZShqc0pvZGEpIHtcbiAgdmFyIHVzZWQgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZShmbikge1xuICAgIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICAgIGZuKGpzSm9kYSk7XG4gICAgICB1c2VkLnB1c2goZm4pO1xuICAgIH1cblxuICAgIHJldHVybiBqc0pvZGE7XG4gIH07XG59XG5cbi8qKlxuICogQGNvcHlyaWdodCAoYykgMjAxNiwgUGhpbGlwcCBUaMO8cnfDpGNodGVyICYgUGF0dHJpY2sgSMO8cGVyXG4gKiBAbGljZW5zZSBCU0QtMy1DbGF1c2UgKHNlZSBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlKVxuICovXG52YXIgXyA9IHtcbiAgYXNzZXJ0OiBhc3NlcnQkMSxcbiAgRGF0ZVRpbWVCdWlsZGVyOiBEYXRlVGltZUJ1aWxkZXIsXG4gIERhdGVUaW1lUGFyc2VDb250ZXh0OiBEYXRlVGltZVBhcnNlQ29udGV4dCxcbiAgRGF0ZVRpbWVQcmludENvbnRleHQ6IERhdGVUaW1lUHJpbnRDb250ZXh0LFxuICBNYXRoVXRpbDogTWF0aFV0aWwsXG4gIFN0cmluZ1V0aWw6IFN0cmluZ1V0aWwsXG4gIFN0cmluZ0J1aWxkZXI6IFN0cmluZ0J1aWxkZXJcbn07XG52YXIganNKb2RhRXhwb3J0cyA9IHtcbiAgXzogXyxcbiAgY29udmVydDogY29udmVydCxcbiAgbmF0aXZlSnM6IG5hdGl2ZUpzLFxuICBBcml0aG1ldGljRXhjZXB0aW9uOiBBcml0aG1ldGljRXhjZXB0aW9uLFxuICBEYXRlVGltZUV4Y2VwdGlvbjogRGF0ZVRpbWVFeGNlcHRpb24sXG4gIERhdGVUaW1lUGFyc2VFeGNlcHRpb246IERhdGVUaW1lUGFyc2VFeGNlcHRpb24sXG4gIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjogSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLFxuICBJbGxlZ2FsU3RhdGVFeGNlcHRpb246IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbixcbiAgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb246IFVuc3VwcG9ydGVkVGVtcG9yYWxUeXBlRXhjZXB0aW9uLFxuICBOdWxsUG9pbnRlckV4Y2VwdGlvbjogTnVsbFBvaW50ZXJFeGNlcHRpb24sXG4gIENsb2NrOiBDbG9jayxcbiAgRGF5T2ZXZWVrOiBEYXlPZldlZWssXG4gIER1cmF0aW9uOiBEdXJhdGlvbixcbiAgSW5zdGFudDogSW5zdGFudCxcbiAgTG9jYWxEYXRlOiBMb2NhbERhdGUsXG4gIExvY2FsVGltZTogTG9jYWxUaW1lLFxuICBMb2NhbERhdGVUaW1lOiBMb2NhbERhdGVUaW1lLFxuICBPZmZzZXRUaW1lOiBPZmZzZXRUaW1lLFxuICBPZmZzZXREYXRlVGltZTogT2Zmc2V0RGF0ZVRpbWUsXG4gIE1vbnRoOiBNb250aCxcbiAgTW9udGhEYXk6IE1vbnRoRGF5LFxuICBQZXJpb2Q6IFBlcmlvZCxcbiAgWWVhcjogWWVhcixcbiAgWWVhckNvbnN0YW50czogWWVhckNvbnN0YW50cyxcbiAgWWVhck1vbnRoOiBZZWFyTW9udGgsXG4gIFpvbmVkRGF0ZVRpbWU6IFpvbmVkRGF0ZVRpbWUsXG4gIFpvbmVPZmZzZXQ6IFpvbmVPZmZzZXQsXG4gIFpvbmVJZDogWm9uZUlkLFxuICBab25lUmVnaW9uOiBab25lUmVnaW9uLFxuICBab25lT2Zmc2V0VHJhbnNpdGlvbjogWm9uZU9mZnNldFRyYW5zaXRpb24sXG4gIFpvbmVSdWxlczogWm9uZVJ1bGVzLFxuICBab25lUnVsZXNQcm92aWRlcjogWm9uZVJ1bGVzUHJvdmlkZXIsXG4gIENocm9ub0xvY2FsRGF0ZTogQ2hyb25vTG9jYWxEYXRlLFxuICBDaHJvbm9Mb2NhbERhdGVUaW1lOiBDaHJvbm9Mb2NhbERhdGVUaW1lLFxuICBDaHJvbm9ab25lZERhdGVUaW1lOiBDaHJvbm9ab25lZERhdGVUaW1lLFxuICBJc29DaHJvbm9sb2d5OiBJc29DaHJvbm9sb2d5LFxuICBDaHJvbm9GaWVsZDogQ2hyb25vRmllbGQsXG4gIENocm9ub1VuaXQ6IENocm9ub1VuaXQsXG4gIElzb0ZpZWxkczogSXNvRmllbGRzLFxuICBUZW1wb3JhbDogVGVtcG9yYWwsXG4gIFRlbXBvcmFsQWNjZXNzb3I6IFRlbXBvcmFsQWNjZXNzb3IsXG4gIFRlbXBvcmFsQWRqdXN0ZXI6IFRlbXBvcmFsQWRqdXN0ZXIsXG4gIFRlbXBvcmFsQWRqdXN0ZXJzOiBUZW1wb3JhbEFkanVzdGVycyxcbiAgVGVtcG9yYWxBbW91bnQ6IFRlbXBvcmFsQW1vdW50LFxuICBUZW1wb3JhbEZpZWxkOiBUZW1wb3JhbEZpZWxkLFxuICBUZW1wb3JhbFF1ZXJpZXM6IFRlbXBvcmFsUXVlcmllcyxcbiAgVGVtcG9yYWxRdWVyeTogVGVtcG9yYWxRdWVyeSxcbiAgVGVtcG9yYWxVbml0OiBUZW1wb3JhbFVuaXQsXG4gIFZhbHVlUmFuZ2U6IFZhbHVlUmFuZ2UsXG4gIERhdGVUaW1lRm9ybWF0dGVyOiBEYXRlVGltZUZvcm1hdHRlcixcbiAgRGF0ZVRpbWVGb3JtYXR0ZXJCdWlsZGVyOiBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIsXG4gIERlY2ltYWxTdHlsZTogRGVjaW1hbFN0eWxlLFxuICBSZXNvbHZlclN0eWxlOiBSZXNvbHZlclN0eWxlLFxuICBTaWduU3R5bGU6IFNpZ25TdHlsZSxcbiAgVGV4dFN0eWxlOiBUZXh0U3R5bGVcbn07XG52YXIgdXNlID0gYmluZFVzZShqc0pvZGFFeHBvcnRzKTtcbmpzSm9kYUV4cG9ydHMudXNlID0gdXNlO1xuXG5leHBvcnQgeyBBcml0aG1ldGljRXhjZXB0aW9uLCBDaHJvbm9GaWVsZCwgQ2hyb25vTG9jYWxEYXRlLCBDaHJvbm9Mb2NhbERhdGVUaW1lLCBDaHJvbm9Vbml0LCBDaHJvbm9ab25lZERhdGVUaW1lLCBDbG9jaywgRGF0ZVRpbWVFeGNlcHRpb24sIERhdGVUaW1lRm9ybWF0dGVyLCBEYXRlVGltZUZvcm1hdHRlckJ1aWxkZXIsIERhdGVUaW1lUGFyc2VFeGNlcHRpb24sIERheU9mV2VlaywgRGVjaW1hbFN0eWxlLCBEdXJhdGlvbiwgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLCBJbGxlZ2FsU3RhdGVFeGNlcHRpb24sIEluc3RhbnQsIElzb0Nocm9ub2xvZ3ksIElzb0ZpZWxkcywgTG9jYWxEYXRlLCBMb2NhbERhdGVUaW1lLCBMb2NhbFRpbWUsIE1vbnRoLCBNb250aERheSwgTnVsbFBvaW50ZXJFeGNlcHRpb24sIE9mZnNldERhdGVUaW1lLCBPZmZzZXRUaW1lLCBQZXJpb2QsIFJlc29sdmVyU3R5bGUsIFNpZ25TdHlsZSwgVGVtcG9yYWwsIFRlbXBvcmFsQWNjZXNzb3IsIFRlbXBvcmFsQWRqdXN0ZXIsIFRlbXBvcmFsQWRqdXN0ZXJzLCBUZW1wb3JhbEFtb3VudCwgVGVtcG9yYWxGaWVsZCwgVGVtcG9yYWxRdWVyaWVzLCBUZW1wb3JhbFF1ZXJ5LCBUZW1wb3JhbFVuaXQsIFRleHRTdHlsZSwgVW5zdXBwb3J0ZWRUZW1wb3JhbFR5cGVFeGNlcHRpb24sIFZhbHVlUmFuZ2UsIFllYXIsIFllYXJDb25zdGFudHMsIFllYXJNb250aCwgWm9uZUlkLCBab25lT2Zmc2V0LCBab25lT2Zmc2V0VHJhbnNpdGlvbiwgWm9uZVJlZ2lvbiwgWm9uZVJ1bGVzLCBab25lUnVsZXNQcm92aWRlciwgWm9uZWREYXRlVGltZSwgXywgY29udmVydCwgbmF0aXZlSnMsIHVzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anMtam9kYS5lc20uanMubWFwXG4iLCJpbXBvcnQge1xuICAgIExvY2FsRGF0ZSxcbiAgICBMb2NhbERhdGVUaW1lLFxuICAgIExvY2FsVGltZSxcbiAgICBQZXJpb2QsXG4gICAgQ2hyb25vVW5pdCxcbiAgICBcbn0gZnJvbSBcIkBqcy1qb2RhL2NvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRheXNCZXR3ZWVuKFxuICAgIHN0YXJ0OiBMb2NhbERhdGUsXG4gICAgZW5kOiBMb2NhbERhdGUsXG4pOiBudW1iZXJ7XG4gICAgdmFyIGRheXMgPSAwO1xuICAgIGRheXMgPSBzdGFydC51bnRpbChlbmQsQ2hyb25vVW5pdC5EQVlTKTtcbiAgICByZXR1cm4gZGF5cztcbiAgICB9OyBcblxuXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJJbnRlcnZhbFRpbWVzKFxuICAgIHN0YXJ0OiBMb2NhbERhdGUsXG4gICAgaW50ZXJ2YWw6IFBlcmlvZCxcbiAgICBtdWx0aXBsaWVyOiBudW1iZXIsXG4pOiBMb2NhbERhdGUge1xuICAgIHZhciBuZXdQZXJpb2QgPSBpbnRlcnZhbC5tdWx0aXBsaWVkQnkobXVsdGlwbGllcik7XG4gICAgdmFyIHJldHVybkRhdGUgPSBzdGFydC5wbHVzKG5ld1BlcmlvZCk7IFxuICAgIHJldHVybiByZXR1cm5EYXRlO1xuICAgIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdXJyaW5nRXZlbnQoXG4gICAgc3RhcnQ6IExvY2FsRGF0ZVRpbWUsXG4gICAgZW5kOiBMb2NhbERhdGVUaW1lLFxuICAgIGludGVydmFsOiBQZXJpb2QsXG4gICAgdGltZU9mRGF5OiBMb2NhbFRpbWUsXG4pOiBMb2NhbERhdGVUaW1lW10ge1xuXG4gICAvL2luaXRpYWxpemUgYXJyYXlcbiAgICB2YXIgcmVjdXJyRXZlbnRzPVtdO1xuXG4gICAvL3N0YXkgaW4gbG9vcCB1bnRpbCB3ZSd2ZSB0cmF2ZXJzZWQgYWxsIGRheXNcbiAgIHdoaWxlIChlbmQuY29tcGFyZVRvKHN0YXJ0KT49MCl7XG4gICAgICAgLy9JZiB0aGUgYHN0YXJ0YCB0aW1lIGlzICoqZWFybGllciBpbiB0aGUgZGF5KiogdGhhbiBgdGltZU9mRGF5YCwgdGhlIGZpcnN0IGV2ZW50IHNob3VsZCB0YWtlIHBsYWNlIG9uIHRoZSBgc3RhcnRgIGRhdGU7IG90aGVyd2lzZSwgdGhlIGZpcnN0IGV2ZW50IHNob3VsZCB0YWtlIHBsYWNlICoqZXhhY3RseSoqIG9uZSBgaW50ZXJ2YWxgIGFmdGVyIHRoZSBgc3RhcnRgIGRhdGVcbiAgICAgICBpZiAoc3RhcnQuY29tcGFyZVRvKHN0YXJ0LndpdGgodGltZU9mRGF5KSkgPiAwKXtcbiAgICAgICBzdGFydCA9IHN0YXJ0LndpdGgodGltZU9mRGF5KTtcbiAgICAgICBzdGFydCA9IHN0YXJ0LnBsdXMoaW50ZXJ2YWwpO1xuICAgfVxuICAgICAgZWxzZXtcbiAgICAgICBzdGFydCA9IHN0YXJ0LndpdGgodGltZU9mRGF5KTtcbiAgICAgICByZWN1cnJFdmVudHMucHVzaChzdGFydCk7XG4gICAgICAgc3RhcnQgPSBzdGFydC5wbHVzKGludGVydmFsKTtcbiAgIH1cblxuICAgfS8vZW5kIFdoaWxlIExvb3BcbiAgICByZXR1cm4gcmVjdXJyRXZlbnRzO1xufSIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuaW1wb3J0IHtcbiAgICBEYXRlVGltZVBhcnNlRXhjZXB0aW9uLFxuICAgIExvY2FsRGF0ZSxcbiAgICBMb2NhbERhdGVUaW1lLFxuICAgIExvY2FsVGltZSxcbiAgICBQZXJpb2QsXG59IGZyb20gXCJAanMtam9kYS9jb3JlXCI7XG5cbmltcG9ydCB7XG4gICAgYWZ0ZXJJbnRlcnZhbFRpbWVzLFxuICAgIGRheXNCZXR3ZWVuLFxuICAgIHJlY3VycmluZ0V2ZW50LFxufSBmcm9tIFwiLi9DYWxjdWxhdG9yXCI7XG5cbmNvbnN0IGhhbmRsZU9uU3VibWl0ID0gKG91dHB1dElEOiBzdHJpbmcsIHJ1bjogKCkgPT4gc3RyaW5nKSA9PiAoKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3V0cHV0SUQpITtcbiAgICB0cnkge1xuICAgICAgICBvdXRwdXQuaW5uZXJIVE1MID0gcnVuKCk7XG4gICAgfSBjYXRjaCAoZTogdW5rbm93bikge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIERhdGVUaW1lUGFyc2VFeGNlcHRpb24pXG4gICAgICAgICAgICBvdXRwdXQuaW5uZXJUZXh0ID0gXCJwYXJzZSBlcnJvclwiO1xuICAgICAgICBlbHNlIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke2UuY29uc3RydWN0b3IubmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKChlIGFzIG9iamVjdCkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGdldElucHV0RWxlbWVudEJ5SWQgPSAoaWQ6IHN0cmluZyk6IEhUTUxJbnB1dEVsZW1lbnQgfCBudWxsID0+XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbmNvbnN0IHBhcnNlTm9uTmVnYXRpdmVJbnQgPSAoc3RyOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBhcnNlSW50KHN0cik7XG4gICAgaWYgKGlzTmFOKHZhbCkpXG4gICAgICAgIHRocm93IG5ldyBEYXRlVGltZVBhcnNlRXhjZXB0aW9uKFwiaW52YWxpZCBpbnRlZ2VyOiBcIiArIHN0cik7XG4gICAgZWxzZSBpZiAodmFsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IERhdGVUaW1lUGFyc2VFeGNlcHRpb24oXCJleHBlY3RlZCBhIHBvc2l0aXZlIGludGVnZXI6IFwiICsgc3RyKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB2YWw7XG59O1xuXG53aW5kb3cub25sb2FkID0gKCkgPT4ge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGF5c0JldHdlZW5cIikhLm9uc3VibWl0ID1cbiAgICBoYW5kbGVPblN1Ym1pdChcImRheXNCZXR3ZWVuT3V0cHV0XCIsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRJbnB1dEVsZW1lbnRCeUlkKFwiZGF5c0JldHdlZW5TdGFydFwiKSE7XG4gICAgICAgIGNvbnN0IGVuZCA9IGdldElucHV0RWxlbWVudEJ5SWQoXCJkYXlzQmV0d2VlbkVuZFwiKSE7XG4gICAgICAgIHJldHVybiBkYXlzQmV0d2VlbihcbiAgICAgICAgICAgIExvY2FsRGF0ZS5wYXJzZShzdGFydC52YWx1ZSksXG4gICAgICAgICAgICBMb2NhbERhdGUucGFyc2UoZW5kLnZhbHVlKSxcbiAgICAgICAgKS50b1N0cmluZygpO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhZnRlckludGVydmFsVGltZXNcIikhLm9uc3VibWl0ID1cbiAgICBoYW5kbGVPblN1Ym1pdChcImFmdGVySW50ZXJ2YWxUaW1lc091dHB1dFwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0SW5wdXRFbGVtZW50QnlJZChcImFmdGVySW50ZXJ2YWxUaW1lc1N0YXJ0XCIpITtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBnZXRJbnB1dEVsZW1lbnRCeUlkKFwiYWZ0ZXJJbnRlcnZhbFRpbWVzSW50ZXJ2YWxcIikhO1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0SW5wdXRFbGVtZW50QnlJZChcImFmdGVySW50ZXJ2YWxUaW1lc011bHRpcGxpZXJcIikhO1xuICAgICAgICByZXR1cm4gYWZ0ZXJJbnRlcnZhbFRpbWVzKFxuICAgICAgICAgICAgTG9jYWxEYXRlLnBhcnNlKHN0YXJ0LnZhbHVlKSxcbiAgICAgICAgICAgIFBlcmlvZC5wYXJzZShpbnRlcnZhbC52YWx1ZSksXG4gICAgICAgICAgICBwYXJzZU5vbk5lZ2F0aXZlSW50KG11bHRpcGxpZXIudmFsdWUpLFxuICAgICAgICApLnRvU3RyaW5nKCk7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlY3VycmluZ0V2ZW50XCIpIS5vbnN1Ym1pdCA9XG4gICAgaGFuZGxlT25TdWJtaXQoXCJyZWN1cnJpbmdFdmVudE91dHB1dFwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0SW5wdXRFbGVtZW50QnlJZChcInJlY3VycmluZ0V2ZW50U3RhcnRcIikhO1xuICAgICAgICBjb25zdCBlbmQgPSBnZXRJbnB1dEVsZW1lbnRCeUlkKFwicmVjdXJyaW5nRXZlbnRFbmRcIikhO1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGdldElucHV0RWxlbWVudEJ5SWQoXCJyZWN1cnJpbmdFdmVudEludGVydmFsXCIpITtcbiAgICAgICAgY29uc3QgdGltZU9mRGF5ID0gZ2V0SW5wdXRFbGVtZW50QnlJZChcInJlY3VycmluZ0V2ZW50VGltZU9mRGF5XCIpITtcbiAgICAgICAgcmV0dXJuIHJlY3VycmluZ0V2ZW50KFxuICAgICAgICAgICAgTG9jYWxEYXRlVGltZS5wYXJzZShzdGFydC52YWx1ZSksXG4gICAgICAgICAgICBMb2NhbERhdGVUaW1lLnBhcnNlKGVuZC52YWx1ZSksXG4gICAgICAgICAgICBQZXJpb2QucGFyc2UoaW50ZXJ2YWwudmFsdWUpLFxuICAgICAgICAgICAgTG9jYWxUaW1lLnBhcnNlKHRpbWVPZkRheS52YWx1ZSksXG4gICAgICAgICkucmVkdWNlKChvdXRwdXQsIGV2ZW50KSA9PiBvdXRwdXQgKyBcIjxicj5cIiArIGV2ZW50LnRvU3RyaW5nKCksIFwiXCIpO1xuICAgIH0pO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=